var documenterSearchIndex = {"docs":
[{"location":"boxmaps/pointdiscretized/#PointDiscretizedBoxMap","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"","category":"section"},{"location":"boxmaps/pointdiscretized/","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"A generalization of MonteCarloBoxMap and GridBoxMap can be defined as follows: ","category":"page"},{"location":"boxmaps/pointdiscretized/","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"we provide a \"global\" set of test points within the unit cube -11^d. \nFor each box Box(c,r), we rescale the global test points to lie within the box by calculating c .+ r .* p for each global test point p. ","category":"page"},{"location":"boxmaps/pointdiscretized/","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"PointDiscretizedBoxMap","category":"page"},{"location":"boxmaps/pointdiscretized/#GAIO.PointDiscretizedBoxMap","page":"PointDiscretizedBoxMap","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, map, domain, points) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses the iterator points as test points.  points must be an array or iterator of test points within the unit cube  [-1,1]^N. \n\n\n\n\n\nBoxMap(:pointdiscretized, :simd, map, domain, points) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses the iterator  points as test points. points must have eltype  SVector{N, SIMD.Vec{S,T}} and be within the unit  cube [-1,1]^N. \n\n\n\n\n\nBoxMap(:pointdiscretized, :gpu, map, domain, points) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses the Vector points as test points.  points must be a VECTOR of test points within the unit cube  [-1,1]^N. \n\nRequires a CUDA-capable gpu. \n\n\n\n\n\n","category":"function"},{"location":"boxmaps/pointdiscretized/#Example","page":"PointDiscretizedBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/pointdiscretized/","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/pointdiscretized/","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"using StaticArrays\n# create a map that tests the vertices of a box\nglobal_test_points = SVector{2,Float64}[\n    (1,  1),\n    (1, -1),\n    (-1, 1),\n    (-1, -1)\n]\nF = BoxMap(:pointdiscretized, f, domain, global_test_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"Images of test points along the vertices\"\n)\n\nsavefig(\"pointdiscretized.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/pointdiscretized/","page":"PointDiscretizedBoxMap","title":"PointDiscretizedBoxMap","text":"(Image: Point Discretized BoxMap)","category":"page"},{"location":"algorithms/control/#Optimal-Control","page":"Optimal Control","title":"Optimal Control","text":"","category":"section"},{"location":"algorithms/control/","page":"Optimal Control","title":"Optimal Control","text":"(TODO)","category":"page"},{"location":"algorithms/control/#References","page":"Optimal Control","title":"References","text":"","category":"section"},{"location":"algorithms/control/","page":"Optimal Control","title":"Optimal Control","text":"[1] Grüne, L., Junge, O. Global Optimal Control of Perturbed Systems. J Optim Theory Appl 136, 411–429 (2008). https://doi.org/10.1007/s10957-007-9312-z","category":"page"},{"location":"algorithms/implicit_manifold/#Covering-Implicitly-Defined-Manifolds","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"","category":"section"},{"location":"algorithms/implicit_manifold/#Mathematical-Background","page":"Covering Implicitly Defined Manifolds","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"For a smooth function h  mathbbR^d to mathbbR^k whose total derivative has full row rank, the set left x in mathbbR^d  h(x) = mathbf0 right defines a smooth manifold. ","category":"page"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"One can follow a technique very similar to the root finding technique using Newton's method to obtain an algorithm to cover such implicitly defined manifolds","category":"page"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: All boxes whose image under h does not contain mathbf0 are removed from B. ","category":"page"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"While this is very similar to the root finding algorithm, it differs in that we use a binary search instead of Newton's method to guarantee that the entire manifold is covered. In order to practically realise the selection step, GAIO.jl uses interval arithmetic to obtain a rigorous outer covering of the setwise images of h. ","category":"page"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"cover_manifold","category":"page"},{"location":"algorithms/implicit_manifold/#GAIO.cover_manifold","page":"Covering Implicitly Defined Manifolds","title":"GAIO.cover_manifold","text":"cover_manifold(f, B::BoxSet; steps=12)\n\nUse interval arithmetic to compute a covering of  an implicitly defined manifold M of the form \n\nf(M) equiv 0\n\nfor some function f  mathbbR^N to mathbbR. \n\nThe starting BoxSet B should (coarsely) cover  the manifold. \n\n\n\n\n\n","category":"function"},{"location":"algorithms/implicit_manifold/#Example","page":"Covering Implicitly Defined Manifolds","title":"Example","text":"","category":"section"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"using GAIO\nusing Plots\n\n# Devil's curve\nconst a, b = 0.9, 1.0\nH((x, y)) = x^2 * (x^2 - b^2) - y^2 * (y^2 - a^2)\n\ndomain = Box((0,0), (2,2))\nP = BoxPartition(domain)\nS = cover(P, :)\n\nM = cover_manifold(H, S; steps=16)\np = plot(M);\n\nsavefig(\"implicit_manifold.svg\"); nothing # hide","category":"page"},{"location":"algorithms/implicit_manifold/","page":"Covering Implicitly Defined Manifolds","title":"Covering Implicitly Defined Manifolds","text":"(Image: Devil's curve)","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/#Almost-Invariant-and-(Lagrangian)-Coherent-Sets","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"","category":"section"},{"location":"algorithms/almost_invariant_coherent_sets/#Mathematical-Background","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"(TODO)","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/#Example","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Example","text":"","category":"section"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"We already constructed almost invariant sets in the section on Sparse Eigenbasis Approximation (SEBA). However, we will use the symmetrized transfer operator in this example. We will continue using the periodically driven double-gyre introduced in the section on Finite Time Lyapunov Exponents. See that code block for the definition of the map. ","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"using StaticArrays # hide\ntest_points = SVector{2,Float64}[               # hide\n (0.26421612450244525, -0.25171763065858643),   # hide\n (0.4570855415305548, -0.9944470807059835),     # hide\n (-0.7306293386393881, 0.06379824546718038),    # hide\n (-0.85365817202697, 0.003511957106970387),     # hide\n (0.8138787776391052, -0.7664619370413657),     # hide\n (-0.2656048895026608, 0.7623267304924846), # hide \n (0.3437809335388058, -0.04027514156212453),    # hide\n (0.8999366397342172, -0.9475337796543073),     # hide\n (-0.30562250022109194, 0.6385081180020975),    # hide\n (0.5856626450795162, 0.934459449090036),       # hide\n (-0.0570952388870527, -0.6124402435996972),    # hide\n (0.8835618643488619, 0.33877549491860126),     # hide\n (0.7842181008345479, -0.2865702451606791),     # hide\n (0.45789504382722646, -0.1981801086140511),    # hide\n (-0.3709621343679155, 0.6094401439758141),     # hide\n (-0.7824441817855012, -0.0038770520790678553), # hide\n (0.10746570024408109, -0.022132632765053062),  # hide\n (-0.01683850957330124, 0.8655654869678553),    # hide\n (-0.08440158133026743, -0.17554973990426515),  # hide\n (-0.9262043546704484, 0.5106870713714742),     # hide\n (-0.6038030997879464, 0.41831615567516445),    # hide\n (0.16940903178018019, -0.626636883009092),     # hide\n (0.520026360934053, 0.3865846340173611),       # hide\n (-0.5823409268978248, -0.5940812669648463),    # hide\n (-0.12895805044268127, -0.766415470911298),    # hide\n (-0.858084556900655, 0.7777874203199997),      # hide\n (-0.37851170163453807, -0.704391110155435),    # hide\n (-0.44135552456739613, -0.3992132574381311),   # hide\n (0.22286176973262561, 0.48927750394661396),    # hide\n (-0.4399148899674712, 0.3714369719228312),     # hide\n (-0.7224409142472934, 0.9945315869571947),     # hide\n (0.49288810186172594, -0.8347990196625026)     # hide\n] # hide\n\nusing GAIO\nusing Plots\n\nconst A, ϵ, ω = 0.25, 0.25, 2π\nfunction double_gyre(x, y, t)\n    f(x, t)  =  ϵ * sin(ω*t) * x^2 + (1 - 2ϵ * sin(ω*t)) * x\n    df(x, t) = 2ϵ * sin(ω*t) * x   + (1 - 2ϵ * sin(ω*t))\n\n    return (\n        -π * A * sin(π * f(x, t)) * cos(π * y),\n         π * A * cos(π * f(x, t)) * sin(π * y) * df(x, t),\n         1\n    )\nend\n\ndouble_gyre((x, y, t)) = double_gyre(x, y, t)\n\n# create a point map ℝ² → ℝ² that \n# integrates the vector field \n# with fixed start time t₀, step size τ \n# until a fixed end time t₁ is reached\nfunction Φ((x₀, y₀), t₀, τ, t₁)\n    z = (x₀, y₀, t₀)\n    for _ in t₀ : τ : t₁-τ\n        z = rk4(double_gyre, z, τ)\n    end\n    (x₁, y₁, t₁) = z\n    return (x₁, y₁)\nend","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"t₀, τ, t₁ = 0, 0.1, 2\nΦₜ₀ᵗ¹(z) = Φ(z, t₀, τ, t₁)\n\ndomain = Box((1.0, 0.5), (1.0, 0.5))\nP = BoxPartition(domain, (256, 128))\nS = cover(P, :)\n\nF = BoxMap(:montecarlo, Φₜ₀ᵗ¹, domain)\nF = BoxMap(:pointdiscretized, Φₜ₀ᵗ¹, domain, test_points) # hide\n\nT = SymmetricTransferOperator(F, S, S)  # (TODO)\n\n# we give Arpack some help converging to the eigenvalues,\n# see the Arpack docs for explanations of keywords\ntol, maxiter, v0 = eps()^(1/4), 1000, ones(size(T, 2))\nλ, ev = eigs(T; nev=2, which=:LR, maxiter=maxiter, tol=tol, v0=v0)\nμ = log ∘ abs ∘ ev[2]\n\np = plot(μ);\n\nsavefig(\"almost_inv.svg\"); nothing # hide","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"(insert plot here)","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"We notice there are two \"blobs\" defining the second eigenmeasure. These correspond to the almost invariant sets; there are two \"vortices\" where mass flows in a circular pattern and doesn't mix with the rest of the domain. ","category":"page"},{"location":"algorithms/almost_invariant_coherent_sets/#References","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"References","text":"","category":"section"},{"location":"algorithms/almost_invariant_coherent_sets/","page":"Almost Invariant and (Lagrangian) Coherent Sets","title":"Almost Invariant and (Lagrangian) Coherent Sets","text":"[1] Froyland, Gary & Padberg-Gehle, Kathrin. (2014). Almost-Invariant and Finite-Time Coherent Sets: Directionality, Duration, and Diffusion. 10.1007/978-1-4939-0419-8_9. ","category":"page"},{"location":"library_reference/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"library_reference/","page":"Library Reference","title":"Library Reference","text":"Pages = [\"library_reference.md\"]","category":"page"},{"location":"library_reference/","page":"Library Reference","title":"Library Reference","text":"Modules = [GAIO]","category":"page"},{"location":"library_reference/#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}","page":"Library Reference","title":"GAIO.BoxMap","text":"BoxMap(map, domain; no_of_points=ntuple(_->4, N)) -> SampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a SampledBoxMap defined  on Boxes. \n\nBy default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated BoxMaps, uses a grid of test points by default. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{P1}, Tuple{B1}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{B, T, P}, Any}} where {B, T, B1, P1, R, S<:BoxSet{B1, P1, R}, P<:(TransferOperator{B, T, S})}","page":"Library Reference","title":"GAIO.BoxSet","text":"BoxSet(boxgraph, graph_index_or_indices) -> BoxSet\n\nConstruct a BoxSet from some  index / indices of vertices in a BoxGraph. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.Node","page":"Library Reference","title":"GAIO.Node","text":"Node structure used for TreePartitions\n\nFields:\n\nleft and right refer to indices w.r.t. \n\ntrp.nodes for a TreePartition trp. \n\n\n\n\n\n","category":"type"},{"location":"library_reference/#Arpack.eigs","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d,[v,],nconv,niter,nmult,resid)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#Arpack.eigs-2","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d,[v,],nconv,niter,nmult,resid)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#Arpack.eigs-3","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d,[v,],nconv,niter,nmult,resid)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#Arpack.svds-Tuple{Adjoint{<:Any, <:TransferOperator}}","page":"Library Reference","title":"Arpack.svds","text":"svds(gstar::TransferOperator [; kwargs...]) -> ([U,], σ, [V,], nconv, niter, nmult, resid)\n\nCompute a set of \n\nsingular values σ\nleft singular vectors U \nright singular vectors V\n\nof gstar, where U and V are Vectors of BoxFuns.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.svds can be passed. See the  documentation for Arpack.svds. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#Arpack.svds-Tuple{TransferOperator}","page":"Library Reference","title":"Arpack.svds","text":"svds(gstar::TransferOperator [; kwargs...]) -> ([U,], σ, [V,], nconv, niter, nmult, resid)\n\nCompute a set of \n\nsingular values σ\nleft singular vectors U \nright singular vectors V\n\nof gstar, where U and V are Vectors of BoxFuns.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.svds can be passed. See the  documentation for Arpack.svds. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#Arpack.svds-Tuple{Transpose{<:Any, <:TransferOperator}}","page":"Library Reference","title":"Arpack.svds","text":"svds(gstar::TransferOperator [; kwargs...]) -> ([U,], σ, [V,], nconv, niter, nmult, resid)\n\nCompute a set of \n\nsingular values σ\nleft singular vectors U \nright singular vectors V\n\nof gstar, where U and V are Vectors of BoxFuns.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.svds can be passed. See the  documentation for Arpack.svds. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}","page":"Library Reference","title":"Base.sum","text":"sum(f, μ::BoxFun)\nsum(f, μ::BoxFun, B::BoxSet)\nμ(B) = sum(x->1, μ, B)\n\nIntegrate a function f using μ as a density, that is, if boxfun is the discretization of a measure mu over the domain  Q, then approximate the value of \n\nint_Q f  dmu \n\nIf a BoxSet B is passed as the third argument, then the  integration is restricted to the boxes in B\n\nint_Q cap bigcup_b in B b f  dmu \n\nThe notation μ(B) is offered to compute  mu (bigcup_b in B b). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.AdaptiveBoxMap","text":"BoxMap(:adaptive, f, domain::Box) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses sample_adaptive to  generate test points as described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses n_points  Monte-Carlo test points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}","page":"Library Reference","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, map, domain, points) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses the iterator points as test points.  points must be an array or iterator of test points within the unit cube  [-1,1]^N. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, :gpu, map, domain, points) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses the Vector points as test points.  points must be a VECTOR of test points within the unit cube  [-1,1]^N. \n\nRequires a CUDA-capable gpu. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, :simd, map, domain, points) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses the iterator  points as test points. points must have eltype  SVector{N, SIMD.Vec{S,T}} and be within the unit  cube [-1,1]^N. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.adaptive_newton_step","page":"Library Reference","title":"GAIO.adaptive_newton_step","text":"adaptive_newton_step(g, g_jacobian, x, k=1)\n\nReturn one step of the adaptive Newton algorithm for the point x. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.approx_lipschitz","text":"approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -> Matrix\n\nCompute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies \n\n f(x) - f(y)  leq L  x - y  quad forall  xy in textBox(center radius)\n\ncomponentwise. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.armijo_rule","page":"Library Reference","title":"GAIO.armijo_rule","text":"armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)\n\nFind a step size multiplier alpha in (alpha_0 alpha_1  such that \n\ng(x + alpha d) - g(x) leq alpha sigma  Dg(x) cdot d\n\nThis is done by initializing alpha = 1 and testing the  above condition. If it is not satisfied, scale alpha  by some constant rho  1 (i.e. set  alpha = rho cdot alpha), and test the condition  again. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B<:Box{N, T}}","page":"Library Reference","title":"GAIO.bounded_point_to_key","text":"bounded_point_to_key(P::BoxPartition, point)\n\nFind the cartesian index of the nearest box within a  BoxPartition to a point. Conicides with point_to_key  if the point lies in the partition. Default behavior  is to set NaN = Inf if NaNs are present in point. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.box_dimension-Tuple{Any}","page":"Library Reference","title":"GAIO.box_dimension","text":"box_dimension(boxsets) -> D\n\nFor an iterator boxsets of (successively finer)  BoxSets, compute the box dimension D. \n\nExample\n\n# F is some BoxMap, S is some BoxSet\nbox_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.center-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.center","text":"center(center, radius)\n\nReturn the center of a box as an iterable.  Default function for image_points in SampledBoxMaps. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.center-Tuple{Box}","page":"Library Reference","title":"GAIO.center","text":"center(b::Box)\n\nReturn the center of a box. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.chain_recurrent_set","text":"chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the chain recurrent set over the box set B.  B should be a (coarse) covering of the relative attractor,  e.g. B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P<:AbstractBoxPartition","page":"Library Reference","title":"GAIO.cover","text":"BoxSet constructors:\nset of all boxes in partition / box set P:\njulia   B = cover(P, :)\ncover the point x, or points x = [x_1, x_2, x_3] # etc ... using boxes from P\njulia   B = cover(P, x)    \na covering of S using boxes from P\njulia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)\n\nReturn a subset of the partition or box set P based on the second argument. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P<:BoxPartition{N, T, I}}","page":"Library Reference","title":"GAIO.cover_boxes","text":"cover_boxes(partition::BoxPartition, boxes)\n\nReturn a covering of an iterator of Boxes using Boxes from partition.  Only covers the part of boxes which lies within partition.domain.  This is returned by cover(partition, boxes). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}","page":"Library Reference","title":"GAIO.cover_manifold","text":"cover_manifold(f, B::BoxSet; steps=12)\n\nUse interval arithmetic to compute a covering of  an implicitly defined manifold M of the form \n\nf(M) equiv 0\n\nfor some function f  mathbbR^N to mathbbR. \n\nThe starting BoxSet B should (coarsely) cover  the manifold. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.cover_roots","text":"cover_roots(g, Dg, B::BoxSet; steps=12) -> BoxSet\n\nCompute a covering of the roots of g within the  partition P. Generally, B should be  a box set containing the whole partition P, ie  B = cover(P, :), and should contain a root of g. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}","page":"Library Reference","title":"GAIO.depth","text":"depth(tree::TreePartition)\n\nReturn the depth of the tree structure. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.expon","page":"Library Reference","title":"GAIO.expon","text":"expon(h, k=1, ϵ=0.2, δ=0.1)\n\nReturn a rough estimate of how many Newton steps  should be taken, given a step size h. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}","page":"Library Reference","title":"GAIO.find_at_depth","text":"find_at_depth(tree, depth)\n\nReturn all node indices at a specified depth. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P<:AbstractBoxPartition{E}}}} where {N, T, E<:Box{N, T}}","page":"Library Reference","title":"GAIO.finite_time_lyapunov_exponents","text":"finite_time_lyapunov_exponents(f, Df, μ::BoxFun; n=8) -> σ\n\nCompute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff's ergodic theorem. Computes \n\nsigma_j = frac1n int log R_jj( Df^n (x) )  dμ (x) quad j = 1 ldots d\n\nwith respect to an ergodic invariant measure mu. \n\n[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R<:Box{N, V}, Q, S}","page":"Library Reference","title":"GAIO.finite_time_lyapunov_exponents","text":"finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -> BoxFun\n\nCompute the Finite Time Lyapunov Exponent for  every box in boxset, where F represents a time-T  integration of some continuous dynamical system.  It is assumed that all boxes in boxset have radii  of some fixed order ϵ. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.fixqr!-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.fixqr!","text":"fixqr!(Q, R)\n\nAdjust a QR-decomposition such that the  R-factor has positive diagonal entries. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q<:(TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}))}","page":"Library Reference","title":"GAIO.hidden_keys","text":"hidden_keys(tree)\n\nReturn all keys within the tree, including  keys not corresponding to leaf nodes. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.index_to_key-Tuple{AbstractArray, Any}","page":"Library Reference","title":"GAIO.index_to_key","text":"index_to_key(iterable, i)\n\nReturn the object held in the ith position of iterable.  Used to enumerate BoxSets as  left B_1 B_2 ldots B_n right in  TransferOperator, BoxGraph. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.key_to_box","text":"key_to_box(P::BoxPartition, key)\n\nReturn the box associated with the index  within a BoxPartition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.key_to_index-Tuple{AbstractArray, Any}","page":"Library Reference","title":"GAIO.key_to_index","text":"key_to_index(iterable, key)\n\nFind the index in 1..length(iterable) which holds key,  or return nothing. Used to enumerate BoxSets as  left B_1 B_2 ldots B_n right in  TransferOperator, BoxGraph. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.leaves","text":"leaves(tree, initial_node_idx=1)\n\nReturn the node indices of all leaves.  Begins search at initial_node_idx, i.e. only returns node indices of nodes below  initial_node_idx within the tree. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.linreg-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.linreg","text":"linreg(xs, ys)\n\nSimple one-dimensional lunear regression used to  approximate box dimension. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.maximal_forward_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.maximal_forward_invariant_set","text":"maximal_forward_invariant_set(F::BoxMap, B::BoxSet; steps=12)\n\nCompute the maximal forward invariant set contained in B.  B should be a (coarse) covering of a forward invariant set,  e.g. B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.maximal_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.maximal_invariant_set","text":"maximal_invariant_set(F::BoxMap, B::BoxSet; steps=12)\n\nCompute the maximal invariant set contained in B.  B should be a (coarse) covering of an invariant set,  e.g. B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.nth_iterate_jacobian-NTuple{4, Any}","page":"Library Reference","title":"GAIO.nth_iterate_jacobian","text":"nth_iterate_jacobian(f, Df, x, n; return_QR=false) -> Z[, R]\n\nCompute the Jacobian of the n-times iterated function  f ∘ f ∘ ... ∘ f at x using a QR iteration based on [1].  Requires an approximation Df of the jacobian of f, e.g.  Df(x) = ForwardDiff.jacobian(f, x).  Optionally, return the QR decomposition. \n\n[1] Dieci, L., Russell, R. D., Van Vleck, E. S.: \"On the  Computation of Lyapunov Exponents for Continuous Dynamical  Systems,\" submitted to SIAM J. Numer. Ana. (1993).\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.plotboxes!-Tuple","page":"Library Reference","title":"GAIO.plotboxes!","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :red Color used for the boxes.\n\ncolormap = :default Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box. Only works if using Makie for plotting. \n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.plotboxes-Tuple","page":"Library Reference","title":"GAIO.plotboxes","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :red Color used for the boxes.\n\ncolormap = :default Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box. Only works if using Makie for plotting. \n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}","page":"Library Reference","title":"GAIO.point_to_box","text":"point_to_box(P::AbstractBoxPartition, point)\n\nFind the box within a BoxPartition containing a point. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.point_to_key","text":"point_to_key(P::BoxPartition, point)\n\nFind the index for the box within a BoxPartition  contatining a point, or nothing if the point does  not lie in the domain. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}","page":"Library Reference","title":"GAIO.preimage","text":"preimage(F::BoxMap, B::BoxSet, Q::BoxSet) -> BoxSet\n\nCompute the (restricted to Q) preimage of B under F, i.e.\n\nF^-1 (B) cap Q  \n\nNote that the larger Q is, the more calculation time required. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.preimage-Tuple{BoxMap, BoxSet}","page":"Library Reference","title":"GAIO.preimage","text":"preimage(F::BoxMap, B::BoxSet) -> BoxSet\n\nEfficiently compute \n\nF^-1 (B) cap B  \n\nSignificantly faster than calling preimage(F, B, B). \n\nwarning: This is not the entire preimage in the mathematical sense!\npreimage(F, B) computes the RESTRICTED preimage F^-1 (B) cap B, NOT the full preimage  F^-1 (B). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.radius-Tuple{Box}","page":"Library Reference","title":"GAIO.radius","text":"radius(b::Box)\n\nReturn the radius of a box. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.relative_attractor","text":"relative_attractor(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the attractor relative to B. B should be  a (coarse) covering of the relative attractor, e.g.  B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Tuple{Any, Any, Any}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(center, radius, points)\n\nReturn an iterable which calls rescale(center, radius, point) for each point in points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Tuple{Any}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(points)\n\nReturn a function \n\n(center, radius) -> rescale(center, radius, points)\n\nUsed in domain_points for BoxMap, PointDiscretizedMap. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(box, point::Union{<:StaticVector{N,T}, <:NTuple{N,T}})\nrescale(center, radius, point::Union{<:StaticVector{N,T}, <:NTuple{N,T}})\n\nScale a point within the unit box -1 1^N  to lie within box = Box(center, radius). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rk4-Tuple{Any, Any, Any}","page":"Library Reference","title":"GAIO.rk4","text":"rk4(f, x, τ)\n\nCompute one step with step size τ of the classic  fourth order Runge-Kutta method. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rk4_flow_map","page":"Library Reference","title":"GAIO.rk4_flow_map","text":"rk4_flow_map(f, x, step_size=0.01, steps=20)\n\nPerform steps steps of the classic Runge-Kutta fourth order method, with step size step_size. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.sample_adaptive","text":"sample_adaptive(f, center::SVector, radius::SVector)\n\nCreate a grid of test points using the adaptive technique  described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U","page":"Library Reference","title":"GAIO.seba","text":"seba(V::Matrix{<:Real}, Rinit=nothing, maxiter=5000) -> S, R\n\nConstruct a sparse approximation of the basis V, as described in  [1]. Returns matrices S, R such that\n\nfrac12  V - SR _F^2 + mu  S _11\n\nis minimized, where mu in mathbbR,  cdot _F is the Frobenuius-norm,  and  cdot _11 is the element sum norm, and R  is orthogonal. See [1] for further information on the argument  Rinit, as well as a description of the algorithm. \n\n[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D<:OrderedCollections.OrderedDict, U<:BoxFun{B, K, W, Q, D}}","page":"Library Reference","title":"GAIO.seba","text":"seba(V::Vector{<:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -> S, A\n\nConstruct a sparse eigenbasis approximation of V, as described in  [1]. Returns an Array of BoxFuns corresponding to the eigenbasis,  as well as a maximum-likelihood BoxFun that maps a box to the  element of S which has the largest value over the support. \n\nThe keyword which is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are\n\npartition_unity, partition_disjoint, partition_likelihood\n\nwhich are all exported functions. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}","page":"Library Reference","title":"GAIO.subdivide!","text":"subdivide!(tree::TreePartition, key::keytype(tree)) -> TreePartition\nsubdivide!(tree::TreePartition, depth::Integer) -> TreePartition\n\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, key) -> BoxSet\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, depth) -> BoxSet\n\nSubdivide a TreePartition at key. Dimension along which  the node is subdivided depends on the depth of the node. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P<:TreePartition, S}","page":"Library Reference","title":"GAIO.subdivide","text":"subdivide(B::BoxSet{<:Any,<:Any,<:TreePartition}) -> BoxSet\n\nBisect every box in boxset along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}","page":"Library Reference","title":"GAIO.symmetric_image","text":"symmetric_image(F::BoxMap, B::BoxSet) -> BoxSet\n\nEfficiently compute \n\nF (B) cap B cap F^-1 (B)  \n\nInternally performs the following computation  (though more efficiently) \n\n# create a measure with support over B\nμ = BoxFun(B)\n\n# compute transfer weights (restricted to B)\nT = TransferOperator(F, B, B)\n\nC⁺ = BoxSet(T*μ)    # support of pushforward measure\nC⁻ = BoxSet(T'μ)    # support of pullback measure\n\nC = C⁺ ∩ C⁻\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.unstable_set-Tuple{BoxMap, BoxSet}","page":"Library Reference","title":"GAIO.unstable_set","text":"unstable_set(F::BoxMap, B::BoxSet) -> BoxSet\n\nCompute the unstable set for a box set B. Generally, B should be  a small box surrounding a fixed point of F. The partition must  be fine enough, since no subdivision occurs in this algorithm. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}","page":"Library Reference","title":"GAIO.vertices","text":"vertices(box)\n\nReturn an iterator over the vertices of a box = Box(center, radius). \n\n\n\n\n\n","category":"method"},{"location":"algorithms/chain_recurrent_set/#Chain-Recurrent-Set","page":"Chain Reccurent Set","title":"Chain Recurrent Set","text":"","category":"section"},{"location":"algorithms/chain_recurrent_set/#Mathematical-Background","page":"Chain Reccurent Set","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"The chain recurrent set over Q R_Q is defined as the set of all x_0 in Q such that for every epsilon  0 there exists a set ","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"left x_0 x_1 x_2 ldots x_n-1 right subset Q quad textwith quad  f(x_i  textmod  n) - x_i+1  textmod  n   epsilon  textfor all  i","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"The chain recurrent set describes \"arbitrarily small perturbations\" of periodic orbits. This definition is useful since our box coverings our finite and hence inherently slightly uncertain. ","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"The idea for the algorithm is to construct a directed graph G whose vertices are the box set B, and for which edges are drawn from B_1 to B_2 if f(B_1) cap B_2 neq emptyset. This is referred to the transfer graph. We can now ask for a subset of the vertices, for which each vertex is part of a directed cycle. This set is equivalent to the strongly connected subset of G. We therefore perform two steps: ","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"subdivision step The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \ngraph construction step Generate the graph G. This is done by generating the transition matrix over B (see the next algorithm) and noting the nonzero elements. This is the (transposed) adjacency matrix for the graph G. \nselection step Find the strongly connected subset of G. Discard all vertices (boxes) which are not part of a strongly connected component. ","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"If we repeadetly refine the strongly connected box set through k subdivision steps, then the algorithm converges to the chain recurrent set as k to infty in the Hausdorff metric. ","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"chain_recurrent_set","category":"page"},{"location":"algorithms/chain_recurrent_set/#GAIO.chain_recurrent_set","page":"Chain Reccurent Set","title":"GAIO.chain_recurrent_set","text":"chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the chain recurrent set over the box set B.  B should be a (coarse) covering of the relative attractor,  e.g. B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/chain_recurrent_set/#Example","page":"Chain Reccurent Set","title":"Example","text":"","category":"section"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"using GAIO\n\n# the Henon map\nconst a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x)\n\ncenter, radius = (0, 0), (3, 3)\nP = BoxPartition(Box(center, radius))\nF = BoxMap(f, P)\nS = cover(P, :)\nA = chain_recurrent_set(F, S, steps = 22)\n\nusing Plots: plot\n#using WGLMakie: plot    # same result, just interactive\n\np = plot(A);\n\nusing Plots: savefig # hide\nsavefig(\"henon_chain_rec.svg\"); nothing # hide","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"(Image: Chain Recurrent Set)","category":"page"},{"location":"algorithms/chain_recurrent_set/#Example-2","page":"Chain Reccurent Set","title":"Example","text":"","category":"section"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"using GAIO\n\n# Van der Pol system\nconst ϵ = 1.5\nv((x,y)) = (y, ϵ*y*(1-x^2) - x)\n\n# time-0.2 flow map\nf(x) = rk4_flow_map(v, x)\n\nc, r = (0., 0.), (3.5, 3.5)\nQ = Box(c, r)\nP = BoxPartition(Q)\nS = cover(P, :)\n\nF = BoxMap(f, Q)\nC = chain_recurrent_set(F, S, steps=18)\n\nusing Plots\nplot(C)\n\nsavefig(\"chain_recurrent_set.svg\"); nothing # hide","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"(Image: Chain recurrent set)","category":"page"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"We find an unstable manifold surroundng a fixed point as well as a stable periodic orbit. ","category":"page"},{"location":"algorithms/chain_recurrent_set/#Implementation","page":"Chain Reccurent Set","title":"Implementation","text":"","category":"section"},{"location":"algorithms/chain_recurrent_set/","page":"Chain Reccurent Set","title":"Chain Reccurent Set","text":"function chain_recurrent_set(F::BoxMap, B₀::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    # B₀ is a set of `N`-dimensional boxes\n    B = B₀\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)    # cycle through dimesions for subdivision\n        P = TransferOperator(F, B, B)    # construct transfer matrix\n        G = Graph(P)                     # view it as a graph\n        B = union_strongly_connected_components(G)  # collect the strongly connected components\n    end\n    return B\nend","category":"page"},{"location":"cuda/#Using-the-GPU-(Nvidia)","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"","category":"section"},{"location":"cuda/#Tutorial","page":"Using the GPU (Nvidia)","title":"Tutorial","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"using GAIO","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"This example demonstrates how to get a vast speedup in your code using nvidia CUDA. The speedup factor increases exponentially with the complexity of the map.","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"Consider the point map f:","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"const σ, ρ, β = 10.0f0, 28.0f0, 0.4f0\nfunction v(x)\n    # Some map, here we use the Lorenz equation\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\n# set f as 100 steps of the classic 4th order RK method\nf(x) = rk4_flow_map(v, x, 0.002f0, 100)","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"tip: Single vs Double Precision Arithmetic\nFor best results, ensure that your functions only use 32-bit operations, as GPUs are not efficient with 64-bit.GAIO can convert your BoxPartition to 32-bit automatically when you use GPU acceleration, but preferred are still explicit 32-bit literals likecenter, radius = (0f0,0f0,25f0), (30f0,30f0,30f0)instead of center, radius = (0,0,25), (30,30,30). ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"All we need to do is pass :gpu as the second argument to one of the box map constructors, eg. BoxMap(:montecarlo, ...), BoxMap(:grid, ...). ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"center, radius = (0f0,0f0,25f0), (30f0,30f0,30f0)\nQ = Box(center, radius)\nP = BoxPartition(Q, (128,128,128))\nF = BoxMap(:montecarlo, :simd, f, Q)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\nS = cover(P, x)\n@time W = unstable_set(F, S)","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"Using CUDA, one can achieve a more than 100-fold increase in performance. However, the performance increase is dependent on the complexity of the map f. For \"simple\" maps (eg. f from above with 20 steps), the GPU accelerated version will actually perform worse because computation time is dominated by the time required to transfer data across the (comparatively slow) PCIe bus. The GPU accelerated version only beats the CPU accelerated version if f is set to use more than 40 steps. Hence it is highly recommended to use the GPU if the map f is not dominated by memory transfer speed, but not recommended otherwise. For more detail, see [1]. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"(Image: performance metrics)","category":"page"},{"location":"cuda/#I-get-InvalidIRError-due-to-unsupported-dynamic-function-invocation","page":"Using the GPU (Nvidia)","title":"I get InvalidIRError due to unsupported dynamic function invocation","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"CUDA.jl generally give somewhat cryptic error messages. An unsupported dynamic function invocation can be caused by a simple error in the code. Hence, first try algorithms with f WITHOUT using the GPU, and ensure that no errors occur. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"If you still recieve dynamic function invocations, there likely is an operation somewhere in f which is not supported in CUDA.jl. A deliberately unsupported function can be for example matrix factorization, matrix-matrix multiplication, etc. because this is typically a performance trap if done on a single GPU thread. One option for linear algebra based functions which cause unsupported dynamic function invocations is to use StaticArrays. StaticArrays implements specialized methods for many low-dimensional linear algebra routines, allowing one to escape the standard methods which may cause unsupported dynamic function invocations. However, this is not a solution for all such problems, so a read through the CUDA.jl documentation, opening an issue on the GAIO.jl repo, or posting a question on the GPU category of julia Discourse for help may be necessary. ","category":"page"},{"location":"cuda/#References","page":"Using the GPU (Nvidia)","title":"References","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. ","category":"page"},{"location":"algorithms/cyclic/#Cyclic-Sets","page":"Cyclic Sets","title":"Cyclic Sets","text":"","category":"section"},{"location":"algorithms/cyclic/#Mathematical-Background","page":"Cyclic Sets","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"We can extend the idea of almost invariant sets to sets which are cyclic in nature. We wish to find sets A_0 ldots A_r-1 such that ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"A_k  textmod  r approx f^-1 ( A_k+1  textmod  r )  ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"or in the context of the transfer operator, signed measures mu_0 ldots mu_r-1 with ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"f_mu_k  textmod  r approx mu_k+1  textmod  r ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"and supports on A_0 ldots A_r-1, respectively. ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"We can approximate a solution to this problem again as an eigenproblem, finding eigenmeasures nu_0 ldots nu_r-1 corresponding to the r-th roots of unity omega_r^k = e^2 pi k  r k = 0 ldots r-1. We have a theorem from [1]:","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"Suppose there exist sets A_0 ldots A_r-1 subset Q with A_k  textmod  r approx f^-1 ( A_k+1  textmod  r ). Then the rth power","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"(f_)^r = underbracef_ circ ldots circ f__r texttimes","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"has eigenvalue 1 with multiplicity at least r. Further, there are r corresponding probability measures mu_0 ldots mu_r-1 with supports on A_0 ldots A_r-1, respectively. These mu_k can be constructed from the eigenmeasures nu_k of f_ corresponding to the eigenvalues omega_r^k as follows","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"mu_pi(l) = frac1r sum_k = 0^r-1 omega_r^k cdot l nu_k","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"where pi is some permutation of the indices left 0 ldots r right. ","category":"page"},{"location":"algorithms/cyclic/#Example","page":"Cyclic Sets","title":"Example","text":"","category":"section"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"Let us consider the map f  mathbbC to mathbbC given by ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"f(z) = e^-frac2 pi i3 left( (z^2 + alpha) z + frac12 barz^2 right)  ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"with alpha = -17. To realize this in GAIO.jl, we will view mathbbC cong mathbbR^2. ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"using GAIO\n\nconst α = -1.7\nf(z) = exp(-2*pi*im/3) * ( (abs(z)^2 + α)*z + conj(z)^2 / 2 )\nfr((x, y)) = reim( f(x + y*im) )\n\nc, r = (0, 0), (1.5, 1.5)\nQ = Box(c, r)\nP = BoxPartition(Q, (128,128))\nF = BoxMap(fr, Q)\n\nS = cover(P, (0,0))\nW = unstable_set(F, S)","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"If we consider the chain recurrent set we notice that there seem to be some discrete \"blobs\". We may wonder how they interact. ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"C = chain_recurrent_set(F, W, steps=2)","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"using Plots\n\np = plot(C)\n\nsavefig(p, \"chain.svg\"); nothing # hide","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"(Image: Chain Recurrent Set)","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"T = TransferOperator(F, W, W)\n\n# eigenvalues of Largest Magnitude (LM)\nλ, ev = eigs(T; nev=32, which=:LM)\n\nλ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"p = scatter(λ)\n\nsavefig(p, \"evs.svg\"); nothing # hide","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"(Image: Eigenvalues)","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"We see that the 6th roots of unity clearly seem to be part of the spectrum. We therefore can conclude that there is an approximate 6-cycle, and can extract the sets corresponding to the cycle. ","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"# by inspection we see that λ[1:6] are ω₆ᵏ, k = 0, ..., 5\nω = λ[1:6]\nν = ev[1:6]\n\n# perform the sum described in the theorem\nμ = [sum( 1/6 .* ω.^l .* ν ) for l in 0:5]\n\n# grab the positive real components\nμ = ( x -> (xr = real(x)) > 0 ? xr : zero(xr) ) .∘ μ\n\n# threshhold to extract support of each μᵢ\nτ = eps()\nA = [BoxSet(P, Set(key for key in keys(μᵢ) if μᵢ[key] > τ)) for μᵢ in μ]","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"p = plot();\nfor (Ai, color) in zip(A, [:red, :green, :blue, :yellow, :pink, :cyan])\n    global p;\n    p = plot!(p, Ai, color=color, fillalpha=0.6);\nend\n\nsavefig(p, \"supps.svg\"); nothing # hide","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"(Image: Cyclic Sets)","category":"page"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"Note that we can also approximate the cyclic sets from the measures μ using sparse eigenbasis approximation (SEBA) as described in the corresponding section of the documentation. ","category":"page"},{"location":"algorithms/cyclic/#References","page":"Cyclic Sets","title":"References","text":"","category":"section"},{"location":"algorithms/cyclic/","page":"Cyclic Sets","title":"Cyclic Sets","text":"[1] Michael Dellnitz and Oliver Junge. “On the Approximation of Complicated Dynamical Behavior”. In: SIAM Journal on Numerical Analysis 2.36 (1999).","category":"page"},{"location":"algorithms/maximal_invariant_set/#Maximal-Invariant-Set","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"","category":"section"},{"location":"algorithms/maximal_invariant_set/#Mathematical-Background","page":"Maximal Invariant Set","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"We say that a set A is forward invariant under the dynamics of f if ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"f (A) subset A  ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"Analogously we can define a backward invariant set A as a set which satisfies","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"f^-1 (A) subset A  ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"Finally, a set which is both forward- and backward invariant, i.e. satisfying","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"f (A) = f^-1 (A) = A","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"is called invariant. ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"A natural question to ask is \"given a dynamical system, what is the maximal (in the sense of inclusion) set which is invariant?\" The answer is given by the set textInv (Q) defined as follows. ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"Let mathcalO(x) = left ldots f^-1(x) x f(x) ldots right denote the full orbit of a point x in the domain Q. Then the set ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"textInv (Q) = left x in Q  mathcalO (x) subset Q right","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"is the set of all orbits contained entirely in Q. This is precisely the maximal invariant set. ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"The idea of the algorithm [1] is to cover the desired set with boxes and recursively tighten the covering by refining appropriately selected boxes. The algorithm requires a BoxMap F as well as a BoxSet B, and performs two steps:","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved as B. \nselection step: B is mapped forward under F. All boxes which do not satisfy the invariance condition F (B) = B = F^-1 (B) are discarded, i.e. only the box set C = F(B) ∩ B ∩ F⁻¹(B) is kept. This set can be computed by considering the transfer graph G restricted to B (as described in Chain Recurrent Set). C is precisely the set of vertices of G which have both an incoming and outgoing edge. ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"This algorithm can be analogously performed to find the maximal forward invariant set by replacing the selection step with selecting C = B ∩ F⁻¹(B), or the maximal backward invariant set by selecting C = F(B) ∩ B. The astute documentation reader might notice that the latter is precisely the algorithm for the relative attractor. ","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"maximal_invariant_set\nmaximal_forward_invariant_set\npreimage\nsymmetric_image","category":"page"},{"location":"algorithms/maximal_invariant_set/#GAIO.maximal_invariant_set","page":"Maximal Invariant Set","title":"GAIO.maximal_invariant_set","text":"maximal_invariant_set(F::BoxMap, B::BoxSet; steps=12)\n\nCompute the maximal invariant set contained in B.  B should be a (coarse) covering of an invariant set,  e.g. B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/maximal_invariant_set/#GAIO.maximal_forward_invariant_set","page":"Maximal Invariant Set","title":"GAIO.maximal_forward_invariant_set","text":"maximal_forward_invariant_set(F::BoxMap, B::BoxSet; steps=12)\n\nCompute the maximal forward invariant set contained in B.  B should be a (coarse) covering of a forward invariant set,  e.g. B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/maximal_invariant_set/#GAIO.preimage","page":"Maximal Invariant Set","title":"GAIO.preimage","text":"preimage(F::BoxMap, B::BoxSet, Q::BoxSet) -> BoxSet\n\nCompute the (restricted to Q) preimage of B under F, i.e.\n\nF^-1 (B) cap Q  \n\nNote that the larger Q is, the more calculation time required. \n\n\n\n\n\npreimage(F::BoxMap, B::BoxSet) -> BoxSet\n\nEfficiently compute \n\nF^-1 (B) cap B  \n\nSignificantly faster than calling preimage(F, B, B). \n\nwarning: This is not the entire preimage in the mathematical sense!\npreimage(F, B) computes the RESTRICTED preimage F^-1 (B) cap B, NOT the full preimage  F^-1 (B). \n\n\n\n\n\n","category":"function"},{"location":"algorithms/maximal_invariant_set/#GAIO.symmetric_image","page":"Maximal Invariant Set","title":"GAIO.symmetric_image","text":"symmetric_image(F::BoxMap, B::BoxSet) -> BoxSet\n\nEfficiently compute \n\nF (B) cap B cap F^-1 (B)  \n\nInternally performs the following computation  (though more efficiently) \n\n# create a measure with support over B\nμ = BoxFun(B)\n\n# compute transfer weights (restricted to B)\nT = TransferOperator(F, B, B)\n\nC⁺ = BoxSet(T*μ)    # support of pushforward measure\nC⁻ = BoxSet(T'μ)    # support of pullback measure\n\nC = C⁺ ∩ C⁻\n\n\n\n\n\n","category":"function"},{"location":"algorithms/maximal_invariant_set/#Example","page":"Maximal Invariant Set","title":"Example","text":"","category":"section"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"using GAIO\n\n# the Henon map\nconst a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x)\n\ncenter, radius = (0, 0), (3, 3)\nP = BoxPartition(Box(center, radius))\nF = BoxMap(f, P)\nS = cover(P, :)\nA = maximal_invariant_set(F, S, steps = 22)\n\nusing Plots: plot\n#using WGLMakie: plot    # same result, just interactive\n\np = plot(A);\n\nusing Plots: savefig # hide\nsavefig(\"max_inv_set.svg\"); nothing # hide","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"(Image: Maximal Invariant Set)","category":"page"},{"location":"algorithms/maximal_invariant_set/#implementation","page":"Maximal Invariant Set","title":"implementation","text":"","category":"section"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"GAIO.jl makes subdivision-based algorithms as the one above very easy to implement. As demonstration, this is the code used for maximal_invariant_set:","category":"page"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"function maximal_invariant_set(F::BoxMap, B₀::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    # B₀ is a set of `N`-dimensional boxes\n    B = B₀\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)   # cycle through dimesions for subdivision\n        B = symmetric_image(F, B, B)    # F(B) ∩ B ∩ F⁻¹(B)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/maximal_invariant_set/#References","page":"Maximal Invariant Set","title":"References","text":"","category":"section"},{"location":"algorithms/maximal_invariant_set/","page":"Maximal Invariant Set","title":"Maximal Invariant Set","text":"[1] Michael Dellnitz and Adreas Hohmann. “The Computation of Unstable Manifolds Using Subdivision”. In: Nonlinear Systems and Chaos. Ed. by Haim Brezis. Vol. 19. Progress in Nonlinear Differential Equations and their Applications. 1996, pp. 449–459. doi: https://doi.org/10.1007/978-3-0348-7518-9.","category":"page"},{"location":"boxmaps/boxmaps_general/#An-Overview-of-BoxMap-Types","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"","category":"section"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"There are multiple techniques one could use to discretize point maps into maps over boxes. In General Usage the discretization BoxMap was already briefly introduced. ","category":"page"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"BoxMap","category":"page"},{"location":"boxmaps/boxmaps_general/#GAIO.BoxMap","page":"An Overview of BoxMap Types","title":"GAIO.BoxMap","text":"BoxMap(map, domain; no_of_points=ntuple(_->4, N)) -> SampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a SampledBoxMap defined  on Boxes. \n\nBy default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated BoxMaps, uses a grid of test points by default. \n\n\n\n\n\n","category":"type"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"We now introduce a set of BoxMap subtypes for different discretization algorithms. The types fit into a heirarchy described in the diagram below. ","category":"page"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"(Image: Type Hierarchy)","category":"page"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"We will work from the \"bottom up\", starting with specific types that are of practical use, and then generalizing these approaches for the reader who wishes to know more. ","category":"page"},{"location":"boxmaps/boxmaps_general/#Example","page":"An Overview of BoxMap Types","title":"Example","text":"","category":"section"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"In the following, we will use a simple but expanding map to demonstrate various BoxMap discretizations","category":"page"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 8.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(\n    cover(P, :), \n    linewidth=0.5, fillcolor=nothing, lab=\"\", \n    leg=:outerbottom\n)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(\n    p, B, \n    linewidth=4, \n    fillcolor=RGBA(0.,0.,1.,0.2), \n    linecolor=RGBA(0.,0.,1.,0.4), \n    lab=\"Box\"\n)\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(\n    p, \n    boundary[:, 1], boundary[:, 2], \n    linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), \n    color=RGBA(0.,0.,1.,0.4), \n    lab=\"True image under f\"\n)\n\nsavefig(\"box_image.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/boxmaps_general/","page":"An Overview of BoxMap Types","title":"An Overview of BoxMap Types","text":"(Image: Example map)","category":"page"},{"location":"algorithms/entropy/#Entropy","page":"Entropy","title":"Entropy","text":"","category":"section"},{"location":"algorithms/entropy/","page":"Entropy","title":"Entropy","text":"(TODO)","category":"page"},{"location":"boxmaps/new_types/#Creating-you-own-BoxMap-type","page":"Creating you own BoxMap type","title":"Creating you own BoxMap type","text":"","category":"section"},{"location":"boxmaps/new_types/","page":"Creating you own BoxMap type","title":"Creating you own BoxMap type","text":"Subtypes of the abstract type BoxMap must have four restrictions:","category":"page"},{"location":"boxmaps/new_types/","page":"Creating you own BoxMap type","title":"Creating you own BoxMap type","text":"There must be a domain field within the type, i.e.\nstruct MyBoxMap{N,T}\n    domain::Box{N,T}\n    # other things ...\nend\nThere must be a method map_boxes(g::MyBoxMap, source::BoxSet) which computes the setwise image of source under g and returns a BoxSet. \nThere must be a method construct_transfers(g::BoxMap, domain::BoxSet, codomain::BoxSet) which computes a dictionary-of-keys sparse matrix mat with mat[(hit_key, source_key)] = weight for the TransferOperator, where hit_key ∈ codomain.set and source_key ∈ domain.set. \nThere must be a method construct_transfers(g::MyBoxMap, source::BoxSet) which computes a dictionary-of-keys sparse matrix mat with mat[(hit_key, source_key)] = weight for the TransferOperator, as well as a BoxSet called image which is the setwise image of source (i.e. the return value of map_boxes). These are both returned by construct_transfers(g::MyBoxMap, source::BoxSet). ","category":"page"},{"location":"boxmaps/sampled/#SampledBoxMap","page":"SampledBoxMap","title":"SampledBoxMap","text":"","category":"section"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"We can even further generalize the concept of MonteCarloBoxMap, GridBoxMap, PointDiscretizedBoxMap as follows: we define two functions domain_points(c, r) and image_points(c, r) for any Box(c, r). ","category":"page"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"for each box Box(c, r) a set of test points within the box is initialized using domain_points(C, r) and mapped forward by the point map. \nFor each of the pointwise images fc, an optional set of \"perturbations\" can be applied. These perturbations are generated with image_points(fc, r). The boxes which are hit by these perturbations are recorded. ","category":"page"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"SampledBoxMap\nCPUSampledBoxMap\nGPUSampledBoxMap","category":"page"},{"location":"boxmaps/sampled/#GAIO.SampledBoxMap","page":"SampledBoxMap","title":"GAIO.SampledBoxMap","text":"BoxMap(:sampled, map, domain::Box, domain_points, image_points)\n\nType representing a discretization of a map using sample points. \n\nFields:\n\nmap:              map that defines the dynamical system.\ndomain:           domain of the map, B.\ndomain_points:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature domain_points(center, radius) and return                      an iterator of points within Box(center, radius). \nimage_points:     the spread of test points for comparison in intersection algorithms.                     Must have the signature domain_points(center, radius) and return                      an iterator of points within Box(center, radius). \n\n.\n\n\n\n\n\n","category":"type"},{"location":"boxmaps/sampled/#GAIO.CPUSampledBoxMap","page":"SampledBoxMap","title":"GAIO.CPUSampledBoxMap","text":"BoxMap(:cpu, map, domain; n_points) -> CPUSampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a CPUSampledBoxMap defined  on Boxes. \n\nUses the CPU's SIMD acceleration capabilities. \n\nBy default uses a grid of sample points. \n\nBoxMap(:sampled, :cpu, boxmap, idx_base, temp_vec, temp_points)\n\nType representing a discretization of a map using  sample points which are explicitly vectorized. This  type performs roughly 2x as many floating point  operations per second as standard SampledBoxMaps. \n\nFields:\n\nboxmap:         SampledBoxMap with one restriction:                   boxmap.domain_points(c, r) must                    return an iterable with eltype                    SVector{N, SIMD.Vec{S,T}} where N                   is the dimension, S is the cpu's                    SIMD operation capacity, e.g. 4,                    and T is the individual element type,                    e.g. Float64. \nidx_base:       SIMD.Vec{S,Int} which is used to                    transform a                    Vector{SVector{N, SIMD.Vec{S,T}}}                   into a                    Vector{SVector{N,T}}. \ntemp_points:    Raw data Vector{SVector{N,T}}                    which holds the S temporary pointwise                    images of a SVector{N, SIMD.Vec{S,T}}                   under the point map. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"boxmaps/sampled/#GAIO.GPUSampledBoxMap","page":"SampledBoxMap","title":"GAIO.GPUSampledBoxMap","text":"BoxMap(:gpu, map, domain; n_points) -> GPUSampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a GPUSampledBoxMap defined  on Boxes. \n\nUses the GPU's acceleration capabilities. \n\nBy default uses a grid of sample points. \n\nBoxMap(:sampled, :gpu, boxmap)\n\nType representing a dicretization of a map using  sample points, which are mapped on the gpu. This  type performs orders of magnitude faster than  standard SampledBoxMaps. \n\nwarning: `image_points` with `GPUSampledBoxMap`\nGPUSampledBoxMap makes NO use of the image_points  field in SampledBoxMaps. \n\nFields:\n\nboxmap:     SampledBoxMap with one restriction:                boxmap.image_points will not be used. \n\nRequires a CUDA-capable gpu. \n\n\n\n\n\n","category":"type"},{"location":"boxmaps/sampled/#Example","page":"SampledBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"using StaticArrays\n\n# we will recreate the AdaptiveBoxMap using SampledBoxMap\ndomain_points(center, radius) = sample_adaptive(f, center, radius)\n\n# vertices of a box\nvertex_test_points = SVector{2,Float64}[\n    (1,  1),\n    (1, -1),\n    (-1, 1),\n    (-1, -1)\n]\nimage_points(center, radius) = (radius .* p .+ center for p in vertex_test_points)\n\nF = BoxMap(:sampled, f, domain, domain_points, image_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"Recreation of AdaptiveBoxMap using SampledBoxMap\"\n)\n\nsavefig(\"sampled.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"(Image: Sampled BoxMap)","category":"page"},{"location":"boxmaps/sampled/#Example-(continued)","page":"SampledBoxMap","title":"Example (continued)","text":"","category":"section"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linecolor=:black, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"using StaticArrays # hide\n\n# we will now extend AdaptiveBoxMap to use a set of \"fallback\" test points\nfallback_points = SVector{2,Float64}[ 2 .* rand(2) .- 1 for _ in 1:30 ];\n\nfunction domain_points(center, radius)\n    try\n        sample_adaptive(f, center, radius)\n    catch exception\n        (center .+ radius .* point for point in fallback_points)\n    end\nend\n\n# vertices of a box\nvertex_test_points = SVector{2,Float64}[(1,  1), (1, -1), (-1, 1), (-1, -1)] # hide\nimage_points(center, radius) = (radius .* p .+ center for p in vertex_test_points)\n\nF = BoxMap(:sampled, f, domain, domain_points, image_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"Recreation of AdaptiveBoxMap using SampledBoxMap\"\n)\n\nsavefig(\"sampled2.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/sampled/","page":"SampledBoxMap","title":"SampledBoxMap","text":"(Image: Sampled BoxMap)","category":"page"},{"location":"boxmaps/interval/#IntervalBoxMap","page":"IntervalBoxMap","title":"IntervalBoxMap","text":"","category":"section"},{"location":"boxmaps/interval/","page":"IntervalBoxMap","title":"IntervalBoxMap","text":"All of the above techniques provide a fast, efficient way to cover setwise images of boxes, but are not necessarily guaranteed to provide an complete covering. To avoid this as well as other numerical inaccuracies inherent in floating point arithmetic, one can use interval arithmetic to guarantee a rigorous outer covering of box images. Interval arithmetic is a technique from validated numerics which performs calculations while simultaneously recording the error of such calculations. A more detailed discussion and julia-implementation of interval arithmetic can be found in IntervalArithmetic.jl. ","category":"page"},{"location":"boxmaps/interval/","page":"IntervalBoxMap","title":"IntervalBoxMap","text":"IntervalBoxMap","category":"page"},{"location":"boxmaps/interval/#GAIO.IntervalBoxMap","page":"IntervalBoxMap","title":"GAIO.IntervalBoxMap","text":"BoxMap(:interval, map, domain::Box{N}; n_subintervals::NTuple{N} = ntuple(_->4, N)) -> IntervalBoxMap\nBoxMap(:interval, map, domain::Box{N}; n_subintervals::Function) -> IntervalBoxMap\n\nType representing a discretization of a map using  interval arithmetic to construct rigorous outer coverings  of map images. n_subintervals describes how many times  a given box will be subdivided before mapping.  n_subintervals is a Function which  has the signature n_subintervals(center, radius) and  returns a tuple. If a tuple is passed directly for  n_subintervals, then this is converted to a constant Function (_, _) -> n_subintervals\n\nFields:\n\nmap:              Map that defines the dynamical system.\ndomain:           Domain of the map, B.\nn_subintervals:   Function with the signature                      n_subintervals(center, radius) which                      returns a tuple describing how many                      times a box is subdivided in each                      dimension before mapping. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"boxmaps/interval/#Example","page":"IntervalBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/interval/","page":"IntervalBoxMap","title":"IntervalBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/interval/","page":"IntervalBoxMap","title":"IntervalBoxMap","text":"n_subintervals = (4, 4)\nF = BoxMap(:interval, f, domain, n_subintervals = n_subintervals)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.5,0.,0.5), \n    lab=\"interval arithmetic with $(join(n_subintervals, \"x\")) subinterval grid\"\n)\n\nsavefig(\"interval.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/interval/","page":"IntervalBoxMap","title":"IntervalBoxMap","text":"(Image: Interval Arithmetic BoxMap)","category":"page"},{"location":"algorithms/almost_invariant/#Almost-Invariant-(metastable)-Sets","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"","category":"section"},{"location":"algorithms/almost_invariant/#Mathematical-Background","page":"Almost Invariant (metastable) Sets","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"In applied dynamical systems research we often wish to determine regions of phase space which \"resist mixing\". These regions can provide valuable information on the system, e.g. oceanic eddies are good transporters of water that is warmer/cooler/saltier than surrounding water [1]. ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"In the context of autonomous dynamics these sets which mitigate transport between their interior and the surrounding phase space are referred to as almost invariant or metastable. Mathematically, we wish to find sets A subset Q of the domain Q which satisfy A approx f^-1 (A) or in the context of mu-measure satisfy ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"p(A) = fracmu (A cap f^-1 (A))mu (A) approx 1  ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"Recalling the section on Transfer Operator and Box Measures, this can be solved by considering the eigenproblem f_mu approx mu. Specifically, we wish to ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"find a BoxFun μ corresponding to an eigenvalue λ ≈ 1,\nsplit the partition P into Boxsets where A^+ = left C in P  mu (C) geq tau right and A^- = left C in P  mu (C)  tau right for some threshhold tau (typically tau = 0). ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"Then we have that the transition probability p(A^pm) approx 1. ","category":"page"},{"location":"algorithms/almost_invariant/#Example","page":"Almost Invariant (metastable) Sets","title":"Example","text":"","category":"section"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"using GAIO\n\n# Chua's circuit\nconst a, b, m0, m1 = 16.0, 33.0, -0.2, 0.01\nv((x,y,z)) = (a*(y-m0*x-m1/3.0*x^3), x-y+z, -b*y)\n\n# time-0.25 flow map\nf(x) = rk4_flow_map(v, x, 0.05, 5)\n\ncenter, radius = (0,0,0), (12,3,20)\nQ = Box(center, radius)\nP = BoxPartition(Q, (256,256,256))\nF = BoxMap(:grid, f, Q)\n\n# computing the attractor by covering the 2d unstable manifold\n# of two equilibria\nx = [sqrt(-3*m0/m1), 0.0, -sqrt(-3*m0/m1)]     # equilibrium\nS = cover(P, [x, -x])\n\nW = unstable_set(F, S)\nT = TransferOperator(F, W, W)\n\n# we give Arpack some help converging to the eigenvalues,\n# see the Arpack docs for explanations of keywords\ntol, maxiter, v0 = eps()^(1/4), 1000, ones(size(T, 2))\nλ, ev = eigs(T; nev=6, which=:LR, maxiter=maxiter, tol=tol, v0=v0)\n\nλ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"We see that the first eigenvalue is approaching 1. This is the invariant measure. There is also an eigenvalue near, but not exactly 1. Let us examine this eigenmeasure a but more closely. ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"μ = (x -> sign(x) * log(abs(x))) ∘ real ∘ ev[2]","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"using GLMakie\n\nfig = Figure();\nax = Axis3(fig[1,1], aspect=(1,1.2,1), azimuth=-3pi/10)\nms = plot!(ax, μ, colormap=(:jet, 0.2))\nColorbar(fig[1,2], ms)\n\nsave(\"2nd_eig.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"(Image: Second Leading Eigenvector)","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"There are clearly two \"sections\" corresponding to the two \"scrolls\" of the attractor. We can separate these sections as follows. ","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"τ = 0\nB1 = BoxSet(P, Set(key for key in keys(μ) if μ[key] ≤ τ))\nB2 = BoxSet(P, Set(key for key in keys(μ) if μ[key] > τ))","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"fig = Figure(resolution=(1200,600));\nax1 = Axis3(fig[1,1], aspect=(1,1.2,1), azimuth=-3pi/10)\nms1 = plot!(ax1, B1, color=(:blue, 0.4))\nax2 = Axis3(fig[1,2], aspect=(1,1.2,1), azimuth=-3pi/10)\nms2 = plot!(ax2, B2, color=(:red, 0.4))\n\nsave(\"almost_inv.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"(Image: Almost Invariant Sets)","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"fig = Figure(resolution=(1200,600)); # hide\nax1 = Axis3(fig[1,1], aspect=(1,1.2,1), azimuth=-3pi/10, viewmode=:fit) # hide\nms1 = plot!(ax1, B1, color=(:blue, 0.4)) # hide\nax2 = Axis3(fig[1,2], aspect=(1,1.2,1), azimuth=-3pi/10, viewmode=:fit) # hide\nms2 = plot!(ax2, B2, color=(:red, 0.4)) # hide\nrecord(fig, \"almost_inv_rotating.gif\", 1:240) do frame\n    v = sin(2pi * frame / 240)\n    ax1.elevation[] = pi/20 - pi * v / 20\n    ax2.elevation[] = pi/20 - pi * v / 20\n    ax1.azimuth[] = 3pi * v / 4\n    ax2.azimuth[] = 3pi * v / 4\nend","category":"page"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"(Image: Almost Invariant Sets Animation)","category":"page"},{"location":"algorithms/almost_invariant/#References","page":"Almost Invariant (metastable) Sets","title":"References","text":"","category":"section"},{"location":"algorithms/almost_invariant/","page":"Almost Invariant (metastable) Sets","title":"Almost Invariant (metastable) Sets","text":"[1] Froyland, G., Padberg-Gehle, K. (2014). Almost-Invariant and Finite-Time Coherent Sets: Directionality, Duration, and Diffusion. In: Bahsoun, W., Bose, C., Froyland, G. (eds) Ergodic Theory, Open Dynamics, and Coherent Structures. Springer Proceedings in Mathematics & Statistics, vol 70. Springer, New York, NY. https://doi.org/10.1007/978-1-4939-0419-8_9","category":"page"},{"location":"boxmaps/boxmaps_simd/#CPUSampledBoxMap","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"","category":"section"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"Naturally, if an increase in accuracy is desired in a SampledBoxMap, a larger set of test points may be chosen. This leads to a dilemma: the more accurate we wish our approximation to be, the more we need to map very similar test points forward, causing a considerable slow down for complicated dynamical systems. However, the process of mapping each test point forward is completely independent on other test points. This means we do not need to perform each calculation sequentially; we can parallelize. ","category":"page"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"If the point map only uses \"basic\" instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple function calls can be made at the same time, increasing performance by roughly 2x. ","category":"page"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"(Image: performance metrics)","category":"page"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"For more details, see the maximizing performance section. ","category":"page"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"GridBoxMap(c::Val{:simd}, map, domain::Box{N,T}; no_of_points) where {N,T}\nMonteCarloBoxMap(c::Val{:simd}, map, domain::Box{N,T}; no_of_points) where {N,T}","category":"page"},{"location":"boxmaps/boxmaps_simd/#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}","page":"CPUSampledBoxMap","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, :simd, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu's SIMD capacity. \n\n\n\n\n\n","category":"method"},{"location":"boxmaps/boxmaps_simd/#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}","page":"CPUSampledBoxMap","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, :simd, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses n_points  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu's SIMD capacity. \n\n\n\n\n\n","category":"method"},{"location":"boxmaps/boxmaps_simd/#Example","page":"CPUSampledBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"n_points = 256\nF = BoxMap(:montecarlo, :simd, f, domain, n_points = n_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"$n_points MonteCarlo test points\"\n)\n\nsavefig(\"simd.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/boxmaps_simd/","page":"CPUSampledBoxMap","title":"CPUSampledBoxMap","text":"(Image: MonteCarlo BoxMap)","category":"page"},{"location":"algorithms/transfer_operator/#Transfer-Operator-and-Box-Measures","page":"Ulam's method and Invariant Measures","title":"Transfer Operator and Box Measures","text":"","category":"section"},{"location":"algorithms/transfer_operator/#Mathematical-Background","page":"Ulam's method and Invariant Measures","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"The following description is given in [1].","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"The transfer operator f_ w.r.t. f is defined for measures μ through the equation","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"(f_mu) (A) = mu (f^-1(A)) quad textfor any   A   textmeasurable","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"This is a bounded linear operator on the space of finite signed measures.  We will use an approximation for f_ which maintains the eigenvalues and cyclic behavior of f_ commonly known as Ulam's method. In particular we are interested in measures which satisfy f_mu = mu, called invariant under f. ","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"We enumerate the box set B =  b_1 b_2  b_n  with integer indices and parameterize an approximate invariant measure","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"    mu(C) = sum_j = 1^n h_j fracm(b_j cap C)m(b_j) quad\n    textfor nonnegative coefficients h_1 ldots h_n","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"where m is the Lebesgue measure. We enforce the condition f_mu = mu on the box set B:","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"    h_j = mu (b_j) overset= (f_mu) (b_j) = sum_k=1^n T_jk cdot h_k quad\n    Rightarrow quad textcoefficients T_jk = fracm(b_k cap f^-1 (b_j))m(b_k)  ","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"The resulting matrix elements T_jk gives the (conditional) probability that f maps a point from b_k to b_j.","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"The operator approximation T can be created in GAIO.jl by calling ","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"T = TransferOperator(F, B)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"where F is a BoxMap and B is a box set. In this case, the codomain is generated automatically. This is not always ideal, so the codomain can be specified as an argument","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"T = TransferOperator(F, B, R)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"where R is also a BoxSet. ","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"T acts as a matrix in every way, but the explicit transfer weights from T can be generated by calling ","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"M = Matrix(T)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"It is important to note that TranferOperator is only supported over the box set B, but if one lets a TranferOperator act on a BoxFun via multiplication (see the example below), then the support B is extended \"on the fly\" to include the support of the BoxFun.","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"TransferOperator\nBoxFun\nsum(::Any, ::BoxFun)\n∘(f, boxfun::BoxFun)","category":"page"},{"location":"algorithms/transfer_operator/#GAIO.TransferOperator","page":"Ulam's method and Invariant Measures","title":"GAIO.TransferOperator","text":"TransferOperator(map::BoxMap, domain::BoxSet)\nTransferOperator(map::BoxMap, domain::BoxSet, codomain::BoxSet)\n\nDiscretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with indices referring to  two BoxSets: domain and codomain. \n\nThere exists two constructors:\n\nonly provide a boxmap and a domain. In this case,  the codomain is generated as the image of domain under  the boxmap. \njulia> P = BoxPartition( Box((0,0), (1,0)), (10,10) )\n  10 x 10 - element BoxPartition\n\njulia> domain = BoxSet( P, Set((1,2), (2,3), (3,4)) )\n  3 - element Boxset over 10 x 10 - element BoxPartition\n\njulia> T = TransferOperator(boxmap, domain)\n  TransferOperator over [...]\nprovide domain and codomain. In this case,  the size of the transition matrix is given. \njulia> codomain = domain\n  3 - element Boxset over 10 x 10 - element BoxPartition\n\njulia> T = TransferOperator(boxmap, domain, codomain)\n  TransferOperator over [...]\n\nFields:\n\nmat:            SparseMatrixCSC containing transfer weights. The index                    T.mat[i,j] represents the transfer weight FROM the j'th                   box in codomain TO the i'th box in domain. \nboxmap:         SampledBoxMap map which dictates the transfer weights. \ndomain:         BoxSet which contains keys for the already calculated transfers.                    Effectively, these are column pointers, i.e. the                    jth column of T.mat contains transfer weights FROM                    box Bj, where Bj is the jth box of domain. \ncodomain:       BoxSet which contains keys for the already calculated transfers.                    Effectively, these are row pointers, i.e. the                    ith row of T.mat contains transfer weights TO                    box Bi, where Bi is the ith box of codomain. \n\n        domain -->\ncodomain  .   .   .   .   .\n    |     .   .   .   .   .\n    |     .   .   .   .   .\n    v     .   .  mat  .   .\n          .   .   .   .   .\n          .   .   .   .   .\n          .   .   .   .   .\n          .   .   .   .   .\n\nIt is important to note that TranferOperator is only supported over the  box set domain, but if one lets a TranferOperator act on a BoxFun, e.g.  by multiplication, then the domain is extended \"on the fly\" to  include the support of the BoxFun.\n\nMethods Implemented: \n\n:(==), axes, size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...\n\nImplementation detail:\n\nThe reader may have noticed that the matrix representation  depends on the order of boxes in support. For this reason  an OrderedSet is used. BoxSets using regular Sets  will be copied and converted to OrderedSets. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/transfer_operator/#GAIO.BoxFun","page":"Ulam's method and Invariant Measures","title":"GAIO.BoxFun","text":"BoxFun(partition, vals)\n\nDiscretization of a measure over the domain partition.domain, as a piecewise constant function over the boxes of partition. \n\nImplemented as a sparse vector over the indices of partition. \n\nConstructors:\n\nBoxFun with constant weight 1 of Type T (default Float64) \n\nsupported over a BoxSet B:\n\nμ = BoxFun(B, T)\n\nBoxFun with specified weights per key\n\nP = B.partition\nweights = Dict( key => 1 for key in keys(B) )\nBoxFun(P, weights)\n\nBoxFun with vector of weights supportted over a BoxSet B: \n\nweights = rand(length(B))\nμ = BoxFun(B, weights)\n\n(Note that since Boxsets do not have a deterministic iteration  order by default, this may have unintented results. This  constructor should therefore only be used with  BoxSet{<:Any, <:Any, <:OrderedSet} types)\n\nFields:\n\npartition: An AbstractBoxPartition whose indices are used \n\nfor vals\n\nvals: A dictionary whose keys are the box indices from \n\npartition, and whose values represent the values of the function. \n\nMethods implemented:\n\nlength, sum, iterate, values, isapprox, ∘, LinearAlgebra.norm, LinearAlgebra.normalize!\n\n\n\n\n\n","category":"type"},{"location":"algorithms/transfer_operator/#Base.sum-Tuple{Any, BoxFun}","page":"Ulam's method and Invariant Measures","title":"Base.sum","text":"sum(f, μ::BoxFun)\nsum(f, μ::BoxFun, B::BoxSet)\nμ(B) = sum(x->1, μ, B)\n\nIntegrate a function f using μ as a density, that is, if boxfun is the discretization of a measure mu over the domain  Q, then approximate the value of \n\nint_Q f  dmu \n\nIf a BoxSet B is passed as the third argument, then the  integration is restricted to the boxes in B\n\nint_Q cap bigcup_b in B b f  dmu \n\nThe notation μ(B) is offered to compute  mu (bigcup_b in B b). \n\n\n\n\n\n","category":"method"},{"location":"algorithms/transfer_operator/#Base.:∘-Tuple{Any, BoxFun}","page":"Ulam's method and Invariant Measures","title":"Base.:∘","text":"∘(f, boxfun::BoxFun) -> BoxFun\n∘(boxfun::BoxFun, F::BoxMap) -> BoxFun\n\nPostcompose the function f with the boxfun, or precompose a BoxMap F with the boxfun  (by applying the Koopman operator). Note that  the support of BoxFun must be forward-invariant under F. \n\n\n\n\n\n","category":"method"},{"location":"algorithms/transfer_operator/#Example-:-Invariant-Measure-of-the-Lorenz-Attractor","page":"Ulam's method and Invariant Measures","title":"Example : Invariant Measure of the Lorenz Attractor","text":"","category":"section"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"using GAIO\n\n# the Lorenz system\nconst σ, ρ, β = 10.0, 28.0, 0.4\nv((x,y,z)) = (σ*(y-x), ρ*x-y-x*z, x*y-β*z)\nf(x) = rk4_flow_map(v, x)\n\ncenter, radius = (0,0,25), (30,30,30)\nP = BoxPartition(Box(center, radius), (256,256,256))\nF = BoxMap(f, P)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)         # equilibrium\nS = cover(P, x)\nW = unstable_set(F, S)\n\nT = TransferOperator(F, W, W)\nλ, ev = eigs(T)\n\nλ","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"μ = log ∘ abs ∘ ev[1]","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"using GLMakie: Figure, Axis3, plot!, Colorbar\nfig = Figure();\nax = Axis3(fig[1,1], azimuth=pi/10);\nms = plot!(ax, μ, colormap=:jet);\nColorbar(fig[1,2], ms);\n\nusing GLMakie: save # hide\nsave(\"transfer_operator.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"(Image: Invariant Measure of the Lorenz Attractor)","category":"page"},{"location":"algorithms/transfer_operator/#Example-2:-Showcase-of-BoxFun-Functionalities","page":"Ulam's method and Invariant Measures","title":"Example 2: Showcase of BoxFun Functionalities","text":"","category":"section"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"using GAIO\n\n# the box [-1, 1]²\ndomain = Box((0.0, 0.0), (1.0, 1.0))\npartition = BoxPartition(domain, (16,8))\n\n# left / right halves of the domain\nleft  = cover(partition, Box((-0.5, 0.0), (0.5, 1.0)))\nright = cover(partition, Box((0.5, 0.0), (0.5, 1.0)))\nfull  = cover(partition, :)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# create measures with constant weight 1 per box\nn = length(left)\nμ_left  = BoxFun(left, ones(n))\nμ_right = BoxFun(right, ones(n))\nμ_full  = BoxFun(full, ones(2n))","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# vector space operations are supported for measures\nμ_left + μ_right     ==  μ_full\nμ_full - μ_left      ==  μ_right\nμ_left - μ_full      == -μ_right\n2*μ_left + 2*μ_right ==  μ_full + μ_full\nμ_left/2 + μ_right/2 ==  μ_full/2","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# horizontal translation map\nf((x, y)) = (x+1, y)\n\n# BoxMap which uses one sample point in the center of each box\nF = BoxMap(:sampled, f, domain, center, center)\n\n# compute the transfer operator over the domain\nT = TransferOperator(F, full, full)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# Compute the pushforward / pullback measures by using the transfer operator\nT*μ_left  == μ_right\nT'μ_right == μ_left","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"μ_full(domain) == volume(domain)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# integration w.r.t. the measures\ng(x) = 2\nsum(g, μ_full) == 2*volume(domain)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# vector space operations\n(2*μ_full)(domain) == 2*volume(domain)","category":"page"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"# composition of measures with scalar functions\nμ_full2 = (x -> 2x) ∘ μ_full\nμ_full2(domain) == 2*volume(domain)","category":"page"},{"location":"algorithms/transfer_operator/#References","page":"Ulam's method and Invariant Measures","title":"References","text":"","category":"section"},{"location":"algorithms/transfer_operator/","page":"Ulam's method and Invariant Measures","title":"Ulam's method and Invariant Measures","text":"[1] Oliver Junge, Daniel Matthes, and Bernhard Schmitzer. Entropic transfer operators. 2022. arXiv: 2204.04901 [math.DS].","category":"page"},{"location":"algorithms/pareto_set/#Multi-Objective-Optimization","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"algorithms/pareto_set/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"(TODO)","category":"page"},{"location":"algorithms/relative_attractor/#Relative-Attractor","page":"Relative Attractor","title":"Relative Attractor","text":"","category":"section"},{"location":"algorithms/relative_attractor/#Mathematical-Background","page":"Relative Attractor","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"The set ","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"A_Q = bigcap_k geq 0 f^k(Q)","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"is called the global attractor relative to Q [1]. The relative global attractor can be seen as the set which is eventually approached by every orbit originating in Q. In particular, A_Q contains each backward invariant set in Q - it is the mximal backward invariant set.  The idea of the algorithm [1] is to cover the relative global attractor with boxes and recursively tighten the covering by refining appropriately selected boxes.","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"In each iteration, two steps happen:","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: All those boxes b in the new box set B whose image does not intersect the domain, i.e. f(b) cap left( bigcup_b in B b right) = emptyset, get discarded. Equivalently, we keep the set F(B) ∩ B. ","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"If we repeatedly refine the box set B through k subdivision steps, then as k to infty the collection of boxes B converges to the relative global attractor A_Q in the Hausdorff metric.","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"relative_attractor","category":"page"},{"location":"algorithms/relative_attractor/#GAIO.relative_attractor","page":"Relative Attractor","title":"GAIO.relative_attractor","text":"relative_attractor(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the attractor relative to B. B should be  a (coarse) covering of the relative attractor, e.g.  B = cover(P, :) for a partition P.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/relative_attractor/#Example","page":"Relative Attractor","title":"Example","text":"","category":"section"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"using GAIO\n\n# the Henon map\nconst a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x)\n\ncenter, radius = (0, 0), (3, 3)\nP = BoxPartition(Box(center, radius))\nF = BoxMap(f, P)\nS = cover(P, :)\nA = relative_attractor(F, S, steps = 22)\n\nusing Plots: plot\n#using WGLMakie: plot    # same result, just interactive\n\np = plot(A);\n\nusing Plots: savefig # hide\nsavefig(\"relative_attractor.svg\"); nothing # hide","category":"page"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"(Image: Relative attractor)","category":"page"},{"location":"algorithms/relative_attractor/#Implementation","page":"Relative Attractor","title":"Implementation","text":"","category":"section"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"function relative_attractor(F::BoxMap, B₀::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    # B₀ is a set of `N`-dimensional boxes\n    B = B₀\n    for k = 1:steps\n        B = subdivide(B, (k % N) + 1)   # cycle through dimesions for subdivision\n        B = B ∩ F(B)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/relative_attractor/#References","page":"Relative Attractor","title":"References","text":"","category":"section"},{"location":"algorithms/relative_attractor/","page":"Relative Attractor","title":"Relative Attractor","text":"[1] Michael Dellnitz and Adreas Hohmann. “The Computation of Unstable Manifolds Using Subdivision”. In: Nonlinear Systems and Chaos. Ed. by Haim Brezis. Vol. 19. Progress in Nonlinear Differential Equations and their Applications. 1996, pp. 449–459. doi: https://doi.org/10.1007/978-3-0348-7518-9.","category":"page"},{"location":"boxmaps/boxmaps_cuda/#GPUSampledBoxmap","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"","category":"section"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"If an Nvidia gpu is available, the above technique can be improved dramatically. The gpu uses a \"massively parallel programming\" paradigm, which fits perfectly to the problem of mapping many sample points independently. For more information, see the maximizing performance section.","category":"page"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"GridBoxMap(c::Val{:gpu}, map, domain::Box{N,T}; no_of_points) where {N,T}\nMonteCarloBoxMap(c::Val{:gpu}, map, domain::Box{N,T}; no_of_points) where {N,T}","category":"page"},{"location":"boxmaps/boxmaps_cuda/#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}","page":"GPUSampledBoxmap","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, :gpu, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"method"},{"location":"boxmaps/boxmaps_cuda/#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}","page":"GPUSampledBoxmap","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, :gpu, map, domain::Box{N}; n_points=16*N) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses n_points  Monte-Carlo test points. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"method"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"Using the gpu, a speed increase of up to 200x can be achieved. ","category":"page"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"(Image: performance metrics)","category":"page"},{"location":"boxmaps/boxmaps_cuda/#Example","page":"GPUSampledBoxmap","title":"Example","text":"","category":"section"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"n_points = 2048\nF = BoxMap(:montecarlo, :gpu, f, domain, n_points = n_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"$n_points MonteCarlo test points\"\n)","category":"page"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"n_points = 2048\nF = BoxMap(:montecarlo, :simd, f, domain, n_points = n_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"$n_points MonteCarlo test points\"\n)\n\nsavefig(\"cuda.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/boxmaps_cuda/","page":"GPUSampledBoxmap","title":"GPUSampledBoxmap","text":"(Image: MonteCarlo BoxMap)","category":"page"},{"location":"algorithms/seba/#Sparse-Eigenbasis-Approximation-(SEBA)","page":"Extracting Multiple Sets via SEBA","title":"Sparse Eigenbasis Approximation (SEBA)","text":"","category":"section"},{"location":"algorithms/seba/#Mathematical-Background","page":"Extracting Multiple Sets via SEBA","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"A common use pattern in GAIO.jl is to construct the transfer operator (or related operators), and then investigate the eigenfunctions for some specific structure. This may be e.g. partitioning the state space based on the result of the second leading eigenvector to find almost invariant sets. A common approach is to use k-means, though this may not be entirely sufficient. The method of Froyland et. al. [1] attempts to find a sparse basis that approximately spans the one produced by a set of eigenvalues. ","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"More specifically: denote some eigenvalues lambda_1 geq ldots geq lambda_r and corresponding eigenvectors v_1 ldots v_r in mathbbR^d (typically r ll p) of a data matrix. We write V = v_1 vert ldots vert v_r. In the context of GAIO.jl this matrix may be the discretized transfer operator. The eigenvectors span a basis mathcalV subset mathbbR^p. We wish to transform this basis into a basis of sparse vectors s_1 ldots s_r in mathbbR^p that span a subspace mathcalS approx mathcalV. Mathematically, this can be formulated as solving the optimization problem","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"undersetS Rmathrmargmin frac12  V - S R _F^2 + mu  S _11","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"where S in mathbbR^n times p has ell_2 norm in each column, R in mathbbR^r times r is orthogonal, and mu  0 is a penalty term.  cdot _F denotes the Frobenius norm and  cdot _11 the element sum norm. ","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"Solving this problem for S = s_1 vert ldots vert s_r is done by the SEBA algorithm [1], (which is based on sparse principal component analysis by rotation and truncation - SPCArt [2]). At this point, most of the work is finished. Indeed, one may be satisfied with the sparse basis alone. However, recall that the goal is to partition the state space into sets based on the eigenvalues. Hence the final step is to threshhold the sparse vectors to fix which indices are in or out of a feature, that is, find an appropriate tau and set S[S .≤ τ] .= 0 such that the least infomation is lost. For this, three heuristics are offered by GAIO.jl:","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"Maximum likelihood partition (without threshholding): For each feature (each row) i, set S_ij = 0 for all j except j_0 = undersetjmathrmargmin S_ij. \nHard partition: For each feature (each row) i, write the values s_i1 ldots s_ir of S_icdot in decreasing order. Choose the threshhold tau^dp = underset1 leq i leq pmathrmmax s_i2, i.e. the maximum over the second largest element of each row. Set S[S .≤ τ] .= 0. \nPartition of unity: For each feature (each row) i, write the values s_i1 ldots s_ir of S_icdot in decreasing order. Choose the threshhold tau^pu = underset1 leq i leq p  1 leq j leq rmathrmmax left s_ij vert sum_k=1^j s_ik  1 right, i.e. the minimum threshhold such that all rows sum to less than 1. Set S[S .≤ τ] .= 0. ","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"Note that the final heuristic does not return a strict partition of the features, but rather a partition of unity. ","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"By default when calling GAIO.jl's seba, hard partitioning is performed. ","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"seba","category":"page"},{"location":"algorithms/seba/#GAIO.seba","page":"Extracting Multiple Sets via SEBA","title":"GAIO.seba","text":"seba(V::Vector{<:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -> S, A\n\nConstruct a sparse eigenbasis approximation of V, as described in  [1]. Returns an Array of BoxFuns corresponding to the eigenbasis,  as well as a maximum-likelihood BoxFun that maps a box to the  element of S which has the largest value over the support. \n\nThe keyword which is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are\n\npartition_unity, partition_disjoint, partition_likelihood\n\nwhich are all exported functions. \n\n\n\n\n\nseba(V::Matrix{<:Real}, Rinit=nothing, maxiter=5000) -> S, R\n\nConstruct a sparse approximation of the basis V, as described in  [1]. Returns matrices S, R such that\n\nfrac12  V - SR _F^2 + mu  S _11\n\nis minimized, where mu in mathbbR,  cdot _F is the Frobenuius-norm,  and  cdot _11 is the element sum norm, and R  is orthogonal. See [1] for further information on the argument  Rinit, as well as a description of the algorithm. \n\n[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787\n\n\n\n\n\n","category":"function"},{"location":"algorithms/seba/#Example","page":"Extracting Multiple Sets via SEBA","title":"Example","text":"","category":"section"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"We will continue using the periodically driven double-gyre introduced in the section on Coherent Sets. See that code block for the definition of the map. ","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"using StaticArrays # hide\ntest_points = SVector{2,Float64}[               # hide\n (0.26421612450244525, -0.25171763065858643),   # hide\n (0.4570855415305548, -0.9944470807059835),     # hide\n (-0.7306293386393881, 0.06379824546718038),    # hide\n (-0.85365817202697, 0.003511957106970387),     # hide\n (0.8138787776391052, -0.7664619370413657),     # hide\n (-0.2656048895026608, 0.7623267304924846), # hide \n (0.3437809335388058, -0.04027514156212453),    # hide\n (0.8999366397342172, -0.9475337796543073),     # hide\n (-0.30562250022109194, 0.6385081180020975),    # hide\n (0.5856626450795162, 0.934459449090036),       # hide\n (-0.0570952388870527, -0.6124402435996972),    # hide\n (0.8835618643488619, 0.33877549491860126),     # hide\n (0.7842181008345479, -0.2865702451606791),     # hide\n (0.45789504382722646, -0.1981801086140511),    # hide\n (-0.3709621343679155, 0.6094401439758141),     # hide\n (-0.7824441817855012, -0.0038770520790678553), # hide\n (0.10746570024408109, -0.022132632765053062),  # hide\n (-0.01683850957330124, 0.8655654869678553),    # hide\n (-0.08440158133026743, -0.17554973990426515),  # hide\n (-0.9262043546704484, 0.5106870713714742),     # hide\n (-0.6038030997879464, 0.41831615567516445),    # hide\n (0.16940903178018019, -0.626636883009092),     # hide\n (0.520026360934053, 0.3865846340173611),       # hide\n (-0.5823409268978248, -0.5940812669648463),    # hide\n (-0.12895805044268127, -0.766415470911298),    # hide\n (-0.858084556900655, 0.7777874203199997),      # hide\n (-0.37851170163453807, -0.704391110155435),    # hide\n (-0.44135552456739613, -0.3992132574381311),   # hide\n (0.22286176973262561, 0.48927750394661396),    # hide\n (-0.4399148899674712, 0.3714369719228312),     # hide\n (-0.7224409142472934, 0.9945315869571947),     # hide\n (0.49288810186172594, -0.8347990196625026)     # hide\n] # hide\n\nusing GAIO\nusing Plots\n\nconst A, ϵ, ω = 0.25, 0.25, 2π\nfunction double_gyre(x, y, t)\n    f(x, t)  =  ϵ * sin(ω*t) * x^2 + (1 - 2ϵ * sin(ω*t)) * x\n    df(x, t) = 2ϵ * sin(ω*t) * x   + (1 - 2ϵ * sin(ω*t))\n\n    return (\n        -π * A * sin(π * f(x, t)) * cos(π * y),\n         π * A * cos(π * f(x, t)) * sin(π * y) * df(x, t),\n         1\n    )\nend\n\ndouble_gyre((x, y, t)) = double_gyre(x, y, t)\n\n# create a point map ℝ² → ℝ² that \n# integrates the vector field \n# with fixed start time t₀, step size τ \n# until a fixed end time t₁ is reached\nfunction Φ((x₀, y₀), t₀, τ, t₁)\n    z = (x₀, y₀, t₀)\n    for _ in t₀ : τ : t₁-τ\n        z = rk4(double_gyre, z, τ)\n    end\n    (x₁, y₁, t₁) = z\n    return (x₁, y₁)\nend","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"using GAIO\n\nt₀, τ, t₁ = 0, 0.1, 2\nΦₜ₀ᵗ¹(z) = Φ(z, t₀, τ, t₁)\n\ndomain = Box((1.0, 0.5), (1.0, 0.5))\nP = BoxPartition(domain, (256, 128))\nS = cover(P, :)\n\nF = BoxMap(:montecarlo, Φₜ₀ᵗ¹, domain)\nF = BoxMap(:pointdiscretized, Φₜ₀ᵗ¹, domain, test_points) # hide\n\nT = TransferOperator(F, S, S)\n\n# we give Arpack some help converging to the eigenvalues,\n# see the Arpack docs for explanations of keywords\ntol, maxiter, v0 = eps()^(1/4), 1000, ones(size(T, 2))\nλ, ev = eigs(T; nev=2, which=:LR, maxiter=maxiter, tol=tol, v0=v0)\nμ = real ∘ ev[2]","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"using Plots\n\np = plot(μ);\n\nsavefig(\"second_eigvec.svg\"); nothing # hide","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"(Image: Second egienvector of the transfer operator)","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"We notice there are two \"blobs\" defining the second eigenmeasure. These correspond to the almost invariant sets; there are two \"vortices\" where mass flows in a circular pattern and doesn't mix with the rest of the domain. We wish to isolate these blobs using seba","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"re_ev = real .∘ ev  # seba expects real numbers, ev is complex\n\nev_seba, feature_vec = seba(re_ev, which=partition_unity)\nμ1, μ2 = ev_seba[1], ev_seba[2]\n\nS1 = BoxSet(P, Set(key for key in keys(μ1) if μ1[key] > 0.01))\nS2 = BoxSet(P, Set(key for key in keys(μ2) if μ2[key] > 0.01))\n\nsetdiff!(S1, S2) # hide\nsetdiff!(S2, S1) # hide\n\np = plot(S1, xlims=(0,2), ylims=(0,1), color=:red);\np = plot!(p, S2, color=:blue);\n\nsavefig(\"seba.svg\"); nothing # hide","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"(Image: Almost invraiant sets isolated by SEBA)","category":"page"},{"location":"algorithms/seba/#References","page":"Extracting Multiple Sets via SEBA","title":"References","text":"","category":"section"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou. Sparse eigenbasis approximation: multiple feature extraction across spatiotemporal scales with application to coherent set identification. Communications in Nonlinear Science and Numerical Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787","category":"page"},{"location":"algorithms/seba/","page":"Extracting Multiple Sets via SEBA","title":"Extracting Multiple Sets via SEBA","text":"[2] Z. Hu, G. Pan, Y. Wang, and Z. Wu. Sparse principal component analysis via rotation and truncation. IEEE Transactions on Neural Networks and Learning Systems, 27(4):875–890, 2016.","category":"page"},{"location":"simd/#Using-the-CPU","page":"Using the CPU","title":"Using the CPU","text":"","category":"section"},{"location":"simd/#Tutorial","page":"Using the CPU","title":"Tutorial","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"This example demonstrates how to get a ~2x speedup in your code using your CPU's SIMD capabilities. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Consider the point map f:","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"using GAIO\n\nconst σ, ρ, β = 10.0, 28.0, 0.4\nfunction v(x)\n    # Some map, here we use the Lorenz equation\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\n# set f as 20 steps of the classic 4th order RK method\nf(x) = rk4_flow_map(v, x, 0.01, 20)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Internally, GAIO calls this function on many test points within the various boxes. This means many function calls have to be made. Notably, all of these function calls are independent of one another, meaning that they can be performed in parallel. If your function only uses \"basic\" instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple funnction calls can be made at the same time, increasing performance. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"tip: Which instructions are supported?\nGAIO.jl uses SIMD.jl to explicitly vectorize operations. To see precisely which instructions are supported, refer to the documentation for SIMD.jl. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"All we need to do is pass :simd as the second argument to one of the box map constructors, eg. BoxMap(:montecarlo, ...), BoxMap(:grid, ...). ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"center, radius = (0,0,25), (30,30,30)\nQ = Box(center, radius)\nP = BoxPartition(Q, (128,128,128))\nF = BoxMap(:montecarlo, :simd, f, Q)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\nS = cover(P, x)\n@time W = unstable_set(F, S)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Using SIMD vectorization, one can roughly double the effective floating point operations per second. For more detail, see [1]. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"(Image: performance metrics)","category":"page"},{"location":"simd/#I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})","page":"Using the CPU","title":"I get MethodError: No method matching f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"If your code returns a MethodError with reference to SIMD.Vec somewhere, this most likely means that your pointmap f uses operations not explicitly supported by SIMD.jl. In this case, one you may need to rewrite sections of f to use only supported operations. For example, consider a \"scaled\" Lorenz flow map ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"function v(x_in)\n    \n    x = x_in ./ sqrt(norm(x_in))\n\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\nf(x) = rk4_flow_map(v, x)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"This code will return a MethodError due to LinearAlgebra.norm. For the L^2 norm, this can be manually rewritten as follows: ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"function v(x_in)\n    \n    sqnorm = sum(y -> y*y, x_in)\n    sqnorm = sqrt(sqrt(sqnorm))\n\n    x = (\n        x_in[1] / sqnorm,\n        x_in[2] / sqnorm,\n        x_in[3] / sqnorm\n    )\n\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\nf(x) = rk4_flow_map(v, x)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Generally, most \"simple\" functions can be rewritten (if needed) to support SIMD.jl. However, more complicated functions can make rewriting unnecessarily difficult. ","category":"page"},{"location":"simd/#References","page":"Using the CPU","title":"References","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. ","category":"page"},{"location":"algorithms/box_dimension/#Box-Dimension","page":"Fractal Dimension","title":"Box Dimension","text":"","category":"section"},{"location":"algorithms/box_dimension/#Mathematical-Background","page":"Fractal Dimension","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"The box dimension, or Minkowski-Bouligand dimension, is a measure of fractal dimension for sets. Denote by N = N(epsilon) the number of boxes with side length epsilon required to cover a set A. The box dimension is defined as ","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"D = undersetepsilon to 0mathrmliminf fraclog N(epsilon)log (1epsilon) ","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"If the above limit exists, then we can equivalently write the asymptotic equation N(epsilon) sim K e^-D for some K. Thus, writing d(epsilon) = log N(epsilon)  log (1epsilon) we have ","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"d(epsilon) - D sim fraclog Klog (1epsilon)","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"The method used to compute D follows that of [1]: it is difficult to make d(epsilon) - D small by shrinking epsilon. However, for small epsilon the relationship between d(epsilon) and 1  log (1epsilon) will be approximately linear. Hence we extrapolate the value of d(epsilon) for epsilon to 0 by linear least-squares regression on d(epsilon) vs 1  log (1epsilon). ","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"Using this method we have everything we need to compute the box dimension for general objects. All that is required is a sequence of successively finer box sets which cover the object. ","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"box_dimension","category":"page"},{"location":"algorithms/box_dimension/#GAIO.box_dimension","page":"Fractal Dimension","title":"GAIO.box_dimension","text":"box_dimension(boxsets) -> D\n\nFor an iterator boxsets of (successively finer)  BoxSets, compute the box dimension D. \n\nExample\n\n# F is some BoxMap, S is some BoxSet\nbox_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )\n\n\n\n\n\n","category":"function"},{"location":"algorithms/box_dimension/#Example","page":"Fractal Dimension","title":"Example","text":"","category":"section"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"using GAIO\n\n# the Henon map\nconst a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x)\n\ncenter, radius = (0, 0), (3, 3)\nQ = Box(center, radius)\nP = BoxPartition(Q)\nF = BoxMap(f, P)\nS = cover(P, :)\n\nbox_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"This method is simple, however it is not the most efficient since in each iteration we have to recalculate the relative attractor to a new depth, even though we already calculated this. A slightly more complicated, but much more efficient method to do this is","category":"page"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"# continuation of the example above\n\nP = TreePartition(Q)\nS = cover(P, :)\n\nBase.@kwdef mutable struct SubdivisionIterator{B<:BoxSet}\n    boxset::B\n    step::Int = 1\n    maxsteps::Int = 20\nend\n\n# Every time we iterate SubdivisionIterator, \n# perform one step of the relative_attractor algorithm\nfunction Base.iterate(s::SubdivisionIterator, state...)\n    s.step == s.maxsteps && return nothing\n    s.boxset = relative_attractor(F, s.boxset, steps=1)\n    s.step += 1\n    return (s.boxset, s.step)\nend\n\ns = SubdivisionIterator(boxset = S)\nbox_dimension(s)","category":"page"},{"location":"algorithms/box_dimension/#References","page":"Fractal Dimension","title":"References","text":"","category":"section"},{"location":"algorithms/box_dimension/","page":"Fractal Dimension","title":"Fractal Dimension","text":"[1] David A. Russell, James D. Hanson, and Edward Ott. “Dimension of Strange Attractors”. In: Phys. Rev. Lett. 45 (14 Oct. 1980), pp. 1175–1178. doi: 10.1103/PhysRevLett.45.1175. url: https://link.aps.org/doi/10.1103/PhysRevLett.45.1175","category":"page"},{"location":"data_structures/#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Pages = [\"data_structures.md\"]","category":"page"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Box\nvolume(box::Box)","category":"page"},{"location":"data_structures/#GAIO.Box","page":"Data Structures","title":"GAIO.Box","text":"Box{N,T}(center, radius)\nBox(center, radius)\n\nA generalized box in dimension N with element type T.  Mathematically, this is a set\n\ncenter_1 - radius_1 center_1 + radius_1)  times  ldots  times  center_N - radius_N center_N + radius_N)\n\nFields:\n\ncenter:   vector where the box's center is located\nradius:   vector of radii, length of the box in each dimension\n\nMethods implemented:\n\n:(==), in #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.volume-Tuple{Box}","page":"Data Structures","title":"GAIO.volume","text":"volume(box::Box)\n\nCompute the volume of a box. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxPartition\npoint_to_key\nbounded_point_to_key\nkey_to_box\npoint_to_box\nsubdivide(P::BoxPartition{N,T,I}, dim) where {N,T,I}","category":"page"},{"location":"data_structures/#GAIO.BoxPartition","page":"Data Structures","title":"GAIO.BoxPartition","text":"BoxPartition(domain::Box{N}, dims::NTuple{N,<:Integer} = ntuple(_->1, N))\n\nData structure to partition a domain into a  dims[1] x dims[2] x ... dims[N] equidistant box grid. \n\nFields:\n\ndomain:         box defining the entire domain\nleft:           leftmost / bottom edge of the domain\nscale:          1 / diameter of each box in the new partition (componentwise)\ndims:           tuple, number of boxes in each dimension\n\nMethods implemented:\n\n:(==), ndims, size, length, keys, keytype #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.point_to_key","page":"Data Structures","title":"GAIO.point_to_key","text":"point_to_key(P::BoxPartition, point)\n\nFind the index for the box within a BoxPartition  contatining a point, or nothing if the point does  not lie in the domain. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.bounded_point_to_key","page":"Data Structures","title":"GAIO.bounded_point_to_key","text":"bounded_point_to_key(P::BoxPartition, point)\n\nFind the cartesian index of the nearest box within a  BoxPartition to a point. Conicides with point_to_key  if the point lies in the partition. Default behavior  is to set NaN = Inf if NaNs are present in point. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.key_to_box","page":"Data Structures","title":"GAIO.key_to_box","text":"key_to_box(P::BoxPartition, key)\n\nReturn the box associated with the index  within a BoxPartition. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.point_to_box","page":"Data Structures","title":"GAIO.point_to_box","text":"point_to_box(P::AbstractBoxPartition, point)\n\nFind the box within a BoxPartition containing a point. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Data Structures","title":"GAIO.subdivide","text":"subdivide(P::BoxPartition, dim) -> BoxPartition\nsubdivide(B::BoxSet, dim) -> BoxSet\n\nBisect every box in the BoxPartition or BoxSet  along the axis dim, giving rise to a new partition  of the domain, with double the amount of boxes. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"TreePartition\nsubdivide!","category":"page"},{"location":"data_structures/#GAIO.TreePartition","page":"Data Structures","title":"GAIO.TreePartition","text":"TreePartition(domain::Box)\n\nBinary tree structure to partition domain into (variably sized) boxes. \n\nFields:\n\ndomain: Box denoting the full domain.\nnodes:  vector of Nodes. Each node holds two indices pointing to            other nodes in the vector, or 0 if the node is a leaf. \n\nMethods implemented:\n\ncopy, keytype, keys, subdivide #, etc...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.subdivide!","page":"Data Structures","title":"GAIO.subdivide!","text":"subdivide!(tree::TreePartition, key::keytype(tree)) -> TreePartition\nsubdivide!(tree::TreePartition, depth::Integer) -> TreePartition\n\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, key) -> BoxSet\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, depth) -> BoxSet\n\nSubdivide a TreePartition at key. Dimension along which  the node is subdivided depends on the depth of the node. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxSet","category":"page"},{"location":"data_structures/#GAIO.BoxSet","page":"Data Structures","title":"GAIO.BoxSet","text":"BoxSet(partition, indices::AbstractSet)\n\nInternal data structure to hold boxes within a partition. \n\nConstructors:\n\nset of all boxes in partition / box set P:\n\nB = cover(P, :)    \n\ncover the point x, or points x = [x_1, x_2, x_3] # etc ... using boxes from P\n\nB = cover(P, x)\n\na covering of S using boxes from P\n\nS = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... \nB = cover(P, S)\n\nFields:\n\npartition:  the partition that the set is defined over\nset:        set of partition-keys corresponding to the boxes in the set\n\nMost set operations such as \n\nunion, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...\n\nare supported. \n\n\n\n\n\n","category":"type"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxGraph","category":"page"},{"location":"data_structures/#GAIO.BoxGraph","page":"Data Structures","title":"GAIO.BoxGraph","text":"Graph(gstar::TransferOperator) -> BoxGraph\nGraph(g::BoxMap, boxset::BoxSet) = Graph(TransferOperator(g, boxset, boxset))\n\nDirected Graph representation of a TransferOperator. The  boxes in a BoxSet are enumerated as in TransferOperator.  This means if the domain, codomain are taken from a  TranferOperator, then the graph vertices are numbered  1 .. length(domain ∪ codomain). \n\nA directed edge exists from the i'th box b_i to the j'th  box b_j if the BoxMap g has b_j ∩ g⁻¹(b_i) ≠ ∅.  Equivalently, \n\nhas_edge(g::BoxGraph, i, j) = !iszero( Matrix(g.gstar)[j,i] )\n\nGraphs.jl operations like \n\nvertices, edges, weights, inneighbors, outneighbors, # etc...\n\nare supported. Algorithms in Graphs.jl  should work \"out of the box\", but will return whatever Graphs.jl  returns by default. To convert a (integer) vertex index from the  graph into a box index from the partition, one can call \n\nBoxSet(boxgraph, graph_index_or_indices)\n\nIf you would like to see specific behavior  implemented, please open an issue! \n\nImplementation details, not important for use:\n\nWe want to turn a matrix representation \n\n        domain -->\ncodomain  .   .   .   .   .\n    |     .   .   .   .   .\n    |     .   .   .   .   .\n    v     .   .  mat  .   .\n          .   .   .   .   .\n          .   .   .   .   .\n\ninto a graph representation \n\n  domain ∪ codomain\n  .---------.   .\n / \\       /   /\n.   .-----.---.\n\n!! efficiently !!\n\nJulia's Graphs package only allows integer-indexed vertices so we need to enumerate domain ∪ codomain.  To do this, we enumerate the domain, then skip  the boxes in the codomain which are already in the  domain, then continue enumerating the rest of the  codomain. \n\nWe therefore permute the row indices of the weight  matrix so that the skipped elements of the codomain come first. \n\n\n\n\n\n","category":"type"},{"location":"algorithms/coherent/#Coherent-Sets","page":"Coherent Sets","title":"Coherent Sets","text":"","category":"section"},{"location":"algorithms/coherent/#Mathematical-Background","page":"Coherent Sets","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"The following approach is decribed in [1]. ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"Recalling the section on Almost Invariant (metastable) Sets, we wish to understand sets which resist mixing over time. In the constext of autonomous dynamics, these are almost invariant sets. However, in the context of nonautonomous dynamics these are often referred to as coherent sets. To distinguish the maps for different times t we will write f_t to denote the dynamics at time t. ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"If the sets A_t and A_t+tau satisfy A_t approx f_t^-1 (A_t+tau) then the set of points currently in A_t will be transported to A_t+tau with little mixing, i.e. ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"fracm( A_t cap f_t^-1 (A_t+tau) )m(A_t) approx 1 ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"As in the previous sections, we will summarize this as an eigenproblem. We would like to translate this problem to one of the form ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"(f_t)_mu_t approx mu_t+tau","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"for some measures mu_t mu_t+tau with supports on A_t A_t+tau, respectively. However, in general we cannot expect A_t = A_t+tau and hence cannot expect mu_t = mu_t+tau either. Therefore, the above equation is not an eigenproblem. ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"Instead, our heuristic will be to push forward mu_t using (f_t)_ to obtain something close to mu_t+tau, and then pull back with the adjoint operator (f_t)_^* to return something close to mu_t. (Analogously we could pull back mu_t+tau with (f_t)_^* and then push forward with (f_t)_.) ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"This leaves a new eigenproblem of the form (f_t)_^*  (f_t)_ (or (f_t)_  (f_t)_^*). These eigenvalues are precisely the right (or left) singular vectors of the operator (f_t)_. ","category":"page"},{"location":"algorithms/coherent/#Example","page":"Coherent Sets","title":"Example","text":"","category":"section"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"We will consider the periodically driven double-gyre map","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"using StaticArrays # hide\ntest_points = SVector{2,Float64}[               # hide\n (0.26421612450244525, -0.25171763065858643),   # hide\n (0.4570855415305548, -0.9944470807059835),     # hide\n (-0.7306293386393881, 0.06379824546718038),    # hide\n (-0.85365817202697, 0.003511957106970387),     # hide\n (0.8138787776391052, -0.7664619370413657),     # hide\n (-0.2656048895026608, 0.7623267304924846), # hide \n (0.3437809335388058, -0.04027514156212453),    # hide\n (0.8999366397342172, -0.9475337796543073),     # hide\n (-0.30562250022109194, 0.6385081180020975),    # hide\n (0.5856626450795162, 0.934459449090036),       # hide\n (-0.0570952388870527, -0.6124402435996972),    # hide\n (0.8835618643488619, 0.33877549491860126),     # hide\n (0.7842181008345479, -0.2865702451606791),     # hide\n (0.45789504382722646, -0.1981801086140511),    # hide\n (-0.3709621343679155, 0.6094401439758141),     # hide\n (-0.7824441817855012, -0.0038770520790678553), # hide\n (0.10746570024408109, -0.022132632765053062),  # hide\n (-0.01683850957330124, 0.8655654869678553),    # hide\n (-0.08440158133026743, -0.17554973990426515),  # hide\n (-0.9262043546704484, 0.5106870713714742),     # hide\n (-0.6038030997879464, 0.41831615567516445),    # hide\n (0.16940903178018019, -0.626636883009092),     # hide\n (0.520026360934053, 0.3865846340173611),       # hide\n (-0.5823409268978248, -0.5940812669648463),    # hide\n (-0.12895805044268127, -0.766415470911298),    # hide\n (-0.858084556900655, 0.7777874203199997),      # hide\n (-0.37851170163453807, -0.704391110155435),    # hide\n (-0.44135552456739613, -0.3992132574381311),   # hide\n (0.22286176973262561, 0.48927750394661396),    # hide\n (-0.4399148899674712, 0.3714369719228312),     # hide\n (-0.7224409142472934, 0.9945315869571947),     # hide\n (0.49288810186172594, -0.8347990196625026)     # hide\n] # hide\n","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"using GAIO\n\nconst A, ϵ, ω = 0.25, 0.25, 2π\nfunction double_gyre(x, y, t)\n    f(x, t)  =  ϵ * sin(ω*t) * x^2 + (1 - 2ϵ * sin(ω*t)) * x\n    df(x, t) = 2ϵ * sin(ω*t) * x   + (1 - 2ϵ * sin(ω*t))\n\n    return (\n        -π * A * sin(π * f(x, t)) * cos(π * y),\n         π * A * cos(π * f(x, t)) * sin(π * y) * df(x, t),\n         1\n    )\nend\n\ndouble_gyre((x, y, t)) = double_gyre(x, y, t)\n\n# create a point map ℝ² → ℝ² that \n# integrates the vector field \n# with fixed start time t₀, step size τ \n# until a fixed end time t₁ is reached\nfunction Φ((x₀, y₀), t₀, τ, t₁)\n    z = (x₀, y₀, t₀)\n    for _ in t₀ : τ : t₁-τ\n        z = rk4(double_gyre, z, τ)\n    end\n    (x₁, y₁, t₁) = z\n    return (x₁, y₁)\nend","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"t₀, τ, t₁ = 0, 0.1, 1\nΦₜ₀ᵗ¹(z) = Φ(z, t₀, τ, t₁)\n\ndomain = Box((1.0, 0.5), (1.0, 0.5))\nP = BoxPartition(domain, (256, 128))\nS = cover(P, :)\n\nF = BoxMap(:montecarlo, Φₜ₀ᵗ¹, domain)\nF = BoxMap(:pointdiscretized, Φₜ₀ᵗ¹, domain, test_points) # hide\n\nT = TransferOperator(F, S, S)\n\n# we give Arpack some help converging to the singular values,\n# see the Arpack docs for explanations of keywords\ntol, maxiter, v0 = eps()^(1/2), 1000, ones(size(T, 2))\nU, σ, V = svds(T; nsv=32, maxiter=maxiter, tol=tol, v0=v0)\n\nσ","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"μ = U[2]","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"using Plots\n\np = plot(μ);\n\nsavefig(p, \"sv1.svg\"); nothing # hide","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"(Image: First left singular measure)","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"A1 = BoxSet(P, Set(key for key in keys(μ) if μ[key] ≥ 0))\nA2 = BoxSet(P, Set(key for key in keys(μ) if μ[key] < 0))\n\np = plot(A1, color=:red);\np = plot!(A2, color=:blue, linecolor=:blue);\n\nsavefig(p, \"coherent.svg\"); nothing # hide","category":"page"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"(Image: Coherent Sets)","category":"page"},{"location":"algorithms/coherent/#References","page":"Coherent Sets","title":"References","text":"","category":"section"},{"location":"algorithms/coherent/","page":"Coherent Sets","title":"Coherent Sets","text":"[1] Froyland, G., Padberg-Gehle, K. (2014). Almost-Invariant and Finite-Time Coherent Sets: Directionality, Duration, and Diffusion. In: Bahsoun, W., Bose, C., Froyland, G. (eds) Ergodic Theory, Open Dynamics, and Coherent Structures. Springer Proceedings in Mathematics & Statistics, vol 70. Springer, New York, NY. https://doi.org/10.1007/978-1-4939-0419-8_9","category":"page"},{"location":"algorithms/ftle/#Finite-Time-Lyapunov-Exponents","page":"Lyapunov Exponents / FTLEs","title":"Finite Time Lyapunov Exponents","text":"","category":"section"},{"location":"algorithms/ftle/#Mathematical-Background","page":"Lyapunov Exponents / FTLEs","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"We change focus now to a continuous dynamical system, e.g. an ODE dotu = g(t u) with solution Phi^tt_0 (x). Since Phi^tt_0 (x) is continuously dependent on the initial condition x, there exists an tildex near x with sup_t in t_0  t_0 + T  Phi^tt_0 (tildex) - Phi^tt_0 (x)   epsilon for any fixed epsilon  0 and T small enough. We wish to characterize this expansion term. We write Phi = Phi^t_0+Tt_0 and y = x + delta x_0 where delta x_0 in mathbbR^d is infinitesimal. Then if g is mathcalC^1 w.r.t. x,","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"delta x (t_0 + T) = Phi (y) - Phi (x)\n= D_x Phi (x) cdot delta x_0 + mathcalO( delta x_0 ^2)","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"Hence we can write ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":" delta x (t_0 + T) _2 =  D_x Phi (x) cdot delta x_0 _2 leq  D_x Phi (x) _2 cdot  delta x_0 _2","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"or equivalently","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"frac  delta x (t_0 + T) _2   delta x_0 _2  leq  D_x Phi (x) _2","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"where equality holds if delta x_0 is the eigenvector corresponding to the largest eigenvalue of ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"Delta = left( D_x Phi (x) right)^T left( D_x Phi (x) right)  ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"Hence if we define ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"sigma (x) = sigma^t_0 + T t_0 (x) = frac1T ln left( sqrtlambda_textmax (Delta) right) = frac1T ln left( sup_delta x_0 frac  delta x (t_0 + T) _2   delta x_0 _2  right)","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"then ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":" delta x (t_0 + T) _2 leq e^T cdot sigma (x) cdot  delta x_0 _2  ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"From this we see why sigma (x) is called the maximal finite-time lyapunov exponent (FTLE). ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"The definition of sigma (x) leads to a natural ansatz for approximating the FTLE: compute frac1T ln left( sup_delta x_0 frac  delta x (t_0 + T) _2   delta x_0 _2  right) for each of a set of test points  delta x_0  of fixed order epsilon  0 and set sigma (x) to be the maximum over this set of test points. ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"An extension of this technique can be made for ergodic systems, as shown in [1]: ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"when calculating the maximal Lyapunov exponent for a discrete dynamical system x_n+1 = f(x_k) defined as ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"lambda (x v) = lim_n to infty frac1n log  Df^n (x) cdot v ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"a known technique is to use a QR iteration. Let A = Q(A) R(A) be the unique QR-decomposition of a nonsingular matrix A into an orthogonal matrix Q(A) and an upper-triangular matrix R(A). Then from  Av  =  R(A) v  we have ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"lim_n to infty frac1n log  Df^n(x) v  = lim_n to infty frac1n log  R(Df^n(x))v  ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"Further, the Lyapunov exponents of the system lambda_1 ldots lambda_d (which are costant over the phase space for an ergodic system) can be found via","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"lambda_j = lim_n to infty frac1n log R_jj(Df^n(x))","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"the j-th diagonal element of R, for j = 1 ldots d. ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"Using an extension of the Birkhoff ergodic theorem it can be proven that this method is equivalent to computing","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"lambda_j = lim_n to infty int log R_jj(Df^n(x))  dmu","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"where mu is a measure which is ergodic and invariant under f. ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"finite_time_lyapunov_exponents","category":"page"},{"location":"algorithms/ftle/#GAIO.finite_time_lyapunov_exponents","page":"Lyapunov Exponents / FTLEs","title":"GAIO.finite_time_lyapunov_exponents","text":"finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -> BoxFun\n\nCompute the Finite Time Lyapunov Exponent for  every box in boxset, where F represents a time-T  integration of some continuous dynamical system.  It is assumed that all boxes in boxset have radii  of some fixed order ϵ. \n\n\n\n\n\nfinite_time_lyapunov_exponents(f, Df, μ::BoxFun; n=8) -> σ\n\nCompute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff's ergodic theorem. Computes \n\nsigma_j = frac1n int log R_jj( Df^n (x) )  dμ (x) quad j = 1 ldots d\n\nwith respect to an ergodic invariant measure mu. \n\n[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4\n\n\n\n\n\n","category":"function"},{"location":"algorithms/ftle/#Example","page":"Lyapunov Exponents / FTLEs","title":"Example","text":"","category":"section"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"We will continue using the periodically driven double-gyre introduced in the section on Coherent Sets. See that code block for the definition of the map. ","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"using StaticArrays # hide\ntest_points = SVector{2,Float64}[               # hide\n (0.26421612450244525, -0.25171763065858643),   # hide\n (0.4570855415305548, -0.9944470807059835),     # hide\n (-0.7306293386393881, 0.06379824546718038),    # hide\n (-0.85365817202697, 0.003511957106970387),     # hide\n (0.8138787776391052, -0.7664619370413657),     # hide\n (-0.2656048895026608, 0.7623267304924846), # hide \n (0.3437809335388058, -0.04027514156212453),    # hide\n (0.8999366397342172, -0.9475337796543073),     # hide\n (-0.30562250022109194, 0.6385081180020975),    # hide\n (0.5856626450795162, 0.934459449090036),       # hide\n (-0.0570952388870527, -0.6124402435996972),    # hide\n (0.8835618643488619, 0.33877549491860126),     # hide\n (0.7842181008345479, -0.2865702451606791),     # hide\n (0.45789504382722646, -0.1981801086140511),    # hide\n (-0.3709621343679155, 0.6094401439758141),     # hide\n (-0.7824441817855012, -0.0038770520790678553), # hide\n (0.10746570024408109, -0.022132632765053062),  # hide\n (-0.01683850957330124, 0.8655654869678553),    # hide\n (-0.08440158133026743, -0.17554973990426515),  # hide\n (-0.9262043546704484, 0.5106870713714742),     # hide\n (-0.6038030997879464, 0.41831615567516445),    # hide\n (0.16940903178018019, -0.626636883009092),     # hide\n (0.520026360934053, 0.3865846340173611),       # hide\n (-0.5823409268978248, -0.5940812669648463),    # hide\n (-0.12895805044268127, -0.766415470911298),    # hide\n (-0.858084556900655, 0.7777874203199997),      # hide\n (-0.37851170163453807, -0.704391110155435),    # hide\n (-0.44135552456739613, -0.3992132574381311),   # hide\n (0.22286176973262561, 0.48927750394661396),    # hide\n (-0.4399148899674712, 0.3714369719228312),     # hide\n (-0.7224409142472934, 0.9945315869571947),     # hide\n (0.49288810186172594, -0.8347990196625026)     # hide\n] # hide\n\nusing GAIO\nusing Plots\n\nconst A, ϵ, ω = 0.25, 0.25, 2π\nfunction double_gyre(x, y, t)\n    f(x, t)  =  ϵ * sin(ω*t) * x^2 + (1 - 2ϵ * sin(ω*t)) * x\n    df(x, t) = 2ϵ * sin(ω*t) * x   + (1 - 2ϵ * sin(ω*t))\n\n    return (\n        -π * A * sin(π * f(x, t)) * cos(π * y),\n         π * A * cos(π * f(x, t)) * sin(π * y) * df(x, t),\n         1\n    )\nend\n\ndouble_gyre((x, y, t)) = double_gyre(x, y, t)\n\n# create a point map ℝ² → ℝ² that \n# integrates the vector field \n# with fixed start time t₀, step size τ \n# until a fixed end time t₁ is reached\nfunction Φ((x₀, y₀), t₀, τ, t₁)\n    z = (x₀, y₀, t₀)\n    for _ in t₀ : τ : t₁-τ\n        z = rk4(double_gyre, z, τ)\n    end\n    (x₁, y₁, t₁) = z\n    return (x₁, y₁)\nend","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"using GAIO\n\nt₀, τ, t₁ = 0, 0.1, 2\nΦₜ₀ᵗ¹(z) = Φ(z, t₀, τ, t₁)\n\ndomain = Box((1.0, 0.5), (1.0, 0.5))\nP = BoxPartition(domain, (256, 128))\nS = cover(P, :)\nF = BoxMap(:montecarlo, Φₜ₀ᵗ¹, domain)\n\nF = BoxMap(:pointdiscretized, Φₜ₀ᵗ¹, domain, test_points) # hide\n\nTspan = t₁ - t₀\nγ = finite_time_lyapunov_exponents(F, S; T=Tspan)","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"using Plots\n\np = plot(γ, clims=(0,2));\n\nsavefig(\"ftle1.svg\"); nothing # hide","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"(Image: FTLE field at time 0)","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"Since this map is time-dependent, the FTLE field will change over time as well. We can use the wonderful @animate macro from Plots.jl to see this change","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"anim = @animate for t in t₀:τ:t₁\n    t₂ = t + Tspan\n    Φₜᵗ²(z) = Φ(z, t, τ, t₂)\n\n    F = BoxMap(:montecarlo, Φₜᵗ², domain)\n    F = BoxMap(:pointdiscretized, Φₜᵗ², domain, test_points) # hide\n    γ = finite_time_lyapunov_exponents(F, S; T=Tspan)\n    plot(γ, clims=(0,2))\nend;\ngif(anim, \"ftle_field.gif\", fps=Tspan÷(2τ));","category":"page"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"(Image: FTLE field)","category":"page"},{"location":"algorithms/ftle/#Example-2:-An-Ergodic-System","page":"Lyapunov Exponents / FTLEs","title":"Example 2: An Ergodic System","text":"","category":"section"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"using GAIO\nusing Plots\nusing StaticArrays\n\n# the Henon map\na, b = 1.4, 0.3\nf((x,y)) = SA{Float64}[ 1 - a*x^2 + y, b*x ]\nDf((x,y)) = SA{Float64}[-2*a*x    1.;\n                         b        0.]\n\ncenter, radius = (0, 0), (3, 3)\nP = BoxPartition(Box(center, radius))\nF = BoxMap(f, P)\nS = cover(P, :)\nA = relative_attractor(F, S, steps = 20)\n\nT = TransferOperator(F, A, A)\n(λ, ev) = eigs(T)\nμ = real ∘ ev[1]\n\nσ16 = finite_time_lyapunov_exponents(f, Df, μ, n=16)\nσ8  = finite_time_lyapunov_exponents(f, Df, μ, n=8)\n\nσ = 2*σ16 - σ8","category":"page"},{"location":"algorithms/ftle/#References","page":"Lyapunov Exponents / FTLEs","title":"References","text":"","category":"section"},{"location":"algorithms/ftle/","page":"Lyapunov Exponents / FTLEs","title":"Lyapunov Exponents / FTLEs","text":"[1] Beyn, WJ., Lust, A. A hybrid method for computing Lyapunov exponents. Numer. Math. 113, 357–375 (2009). https://doi.org/10.1007/s00211-009-0236-4","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Consider the Hénon map [1]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"f(xy) = (1-ax^2+y bx) quad ab in mathbbR","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Iterating some random intial point exhibits a strange attractor (a=1.4 and b=0.3)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"(Image: Hénon attractor)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This map is chaotic [2,3], it has sensitive dependence on initial conditions. That is, small perturbations (as unavoidable on a computer) during the computation grow exponentially during the iteration.  Thus, apart from a few iterates at the beginning, the computed trajectory does not (necessarily) follow a true trajectory. One might therefore question how reliable this figure is.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Instead of trying to approximate the attractor by a long forward trajectory, we will capture it by computing a collection of boxes (i.e. cubes) covering the attractor. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Start by loading the GAIO package","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using GAIO","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A Box is descibed by its center and its radius","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"box_center, box_radius = (0,0), (3,3)\nQ = Box(box_center, box_radius)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This box will serve as the domain for our computation.  The box covering which we will compute is a subset of a partition of Q into smaller boxes. The command","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"P = BoxPartition(Q, (4,4)) ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a partition of Q into a grid of 4 x 4 equally sized smaller boxes. Note that this command does not explicitly construct the partition (as a set of subsets covering the domain Q) but rather serves as a sigma-algebra for constructing sets of boxes later. For example, the commands","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"test_points = [\n    (1, 1),\n    (2, 1)\n];\nB = cover(P, test_points)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a BoxSet containing boxes from the partition P which cover each of test_points. Similarly, ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"B = cover(P, :)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a BoxSet containing all boxes from the partition P (i.e. a set containing 16 boxes).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In order to deal with the Hénon map as a map over box sets, we have to turn it into a BoxMap on the domain Q","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x) \nF = BoxMap(f, Q) ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We can now compute a covering of the attractor in Q, starting with the full box set B, by applying 15 steps of the subdivison algorithm described in [4]:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A = relative_attractor(F, B, steps = 19)  ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Plots\np = plot(A)\nsavefig(\"henon.svg\"); nothing # hide","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"(Image: box covering of the Hénon attractor)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In addition to covering the attractor, this box collection also covers an unstable fixed point near (-1,-0.3) and its unstabe manifold (cf. [4]).","category":"page"},{"location":"getting_started/#References","page":"Getting started","title":"References","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[1] Hénon, Michel. \"A two-dimensional mapping with a strange attractor\". Communications in Mathematical Physics 50.1 (1976): 69–77.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[2] Benedicks, Michael, and Lennart Carleson. \"The dynamics of the Hénon map.\" Annals of Mathematics 133.1 (1991): 73-169.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[3] Zgliczynski, Piotr. \"Computer assisted proof of chaos in the Rössler equations and in the Hénon map.\" Nonlinearity 10.1 (1997): 243. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[4] Dellnitz, Michael, and Andreas Hohmann. \"A subdivision algorithm for the computation of unstable manifolds and global attractors.\" Numerische Mathematik 75.3 (1997): 293-317.","category":"page"},{"location":"algorithms/unstable_manifold/#Unstable-Set","page":"Stable and Unstable Manifold","title":"Unstable Set","text":"","category":"section"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"In the following we are presenting the algorithm to cover invariant manifolds within some domain Q, which has to contain a fixed point.","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"note: Note\nFor simplicity, we will explain the algorithm for the case of the unstable manifold. However one can compute the stable manifold as well by considering the boxmap describing the inverse map f^-1 as input argument for the algorithm.","category":"page"},{"location":"algorithms/unstable_manifold/#Mathematical-Background","page":"Stable and Unstable Manifold","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"The unstable manifold is defined as","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"W^U(x_0) = x lim_k to - infty f^k(x) = x_0 ","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"where x_0 is a fixed point of f.","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"The idea behind the algorithm [1] to compute the unstable manifold can be explained in two steps. Before starting we need to identify a hyperbolic fixed point and the region Q, which we are going to compute the manifold in. The region Q needs to be already partitioned into small boxes.","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"initialization step Since a fixed point is always part of the unstable manifold, we need to identify a small region/box containing this fixed point. This box may be known a-priori, or one can use the relative_attractor around a small region where one suspects a fixed point to exist. \ncontinuation step The small box containing the fixed point is then mapped forward by F and the boxes that are hit under the image are added to the box collection. Then those newly included boxes are mapped forward and the procedure is repeated until no new boxes are added. ","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"warning: Note on Convergence\nOne might not be able to compute the parts of the unstable manifold whose preimage lies outside the domain Q. Thus, it is important to choose Q large enough.","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"unstable_set","category":"page"},{"location":"algorithms/unstable_manifold/#GAIO.unstable_set","page":"Stable and Unstable Manifold","title":"GAIO.unstable_set","text":"unstable_set(F::BoxMap, B::BoxSet) -> BoxSet\n\nCompute the unstable set for a box set B. Generally, B should be  a small box surrounding a fixed point of F. The partition must  be fine enough, since no subdivision occurs in this algorithm. \n\n\n\n\n\n","category":"function"},{"location":"algorithms/unstable_manifold/#Example","page":"Stable and Unstable Manifold","title":"Example","text":"","category":"section"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"using GAIO\n\n# the Lorenz system\nconst σ, ρ, β = 10.0, 28.0, 0.4\nv((x,y,z)) = (σ*(y-x), ρ*x-y-x*z, x*y-β*z)\n\n# time-0.2 flow map\nf(x) = rk4_flow_map(v, x)\n\ncenter, radius = (0,0,25), (30,30,30)\nQ = Box(center, radius)\nP = BoxPartition(Q, (256,256,256))\nF = BoxMap(:adaptive, f, Q)\n\n# equilibrium\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\nS = cover(P, x)\n\nW = unstable_set(F, S)","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"using GLMakie\n\nfig, ax, ms = plot(W);\n\nusing GLMakie: save # hide\nsave(\"unstable_manifold.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"(Image: Unstable manifold)","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"We can animate this plot using the record function from Makie.jl","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"fig = Figure();\nax = Axis3(fig[1,1], viewmode=:fit)\nms = plot!(ax, W, color=(:red, 0.6))\n\nrecord(fig, \"unstable.gif\", 1:240) do frame\n    v = sin(2pi * frame / 240)\n    ax.elevation[] = pi/8 - pi * v / 10\n    ax.azimuth[] = pi * v / 2\nend;","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"(Image: Unstable Manifold Gif)","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"fig, ax, ms = plot(W);\n\nusing GLMakie: save # hide\nsave(\"unstable_manifold.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"# integrate in reverse time: \n# 5 steps of rk4 method with step size -0.01\nf(x) = rk4_flow_map(v, x, -0.01, 5)\n\ncenter, radius = (0,0,25), (120,180,160)\nQ = Box(center, radius)\nP = BoxPartition(Q, (256,256,256))\nF = BoxMap(:grid, f, Q, n_points=(8,8,8))\n\n# Equillibrium (0,0,0) lies at the bottom corner of one box.\n# Cover a small neighborhood of (0,0,0) instead\nx = Box( (0,0,0), 0.01 .* (1,1,1) )\nS = cover(P, x)\n\nW2 = unstable_set(F, S)","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"fig = Figure();\nax = Axis3(fig[1,1], azimuth=0.62*pi)\nms = plot!(ax, W2)\n\nsave(\"stable_manifold.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"(Image: Stable manifold)","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"fig = Figure(); # hide\nax = Axis3(fig[1,1], azimuth=0.62*pi, viewmode=:fit) # hide\nms = plot!(ax, W2, color=(:red, 0.6)) # hide\n\nrecord(fig, \"stable.gif\", 1:240) do frame\n    v = sin(2pi * frame / 240)\n    ax.elevation[] = pi/10 - pi * v / 20\n    ax.azimuth[] = -pi / 5 + 2pi * v / 5\nend;","category":"page"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"(Image: Stable Manifold Gif)","category":"page"},{"location":"algorithms/unstable_manifold/#Implementation","page":"Stable and Unstable Manifold","title":"Implementation","text":"","category":"section"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"function unstable_set(F::BoxMap, B::BoxSet)\n    B₀ = B\n    B₁ = B\n    while !isempty(B₁)\n        B₁ = F(B₁)          # map the current interation forward\n        setdiff!(B₁, B₀)    # remove boxes we've already seen\n        union!(B₀, B₁)      # add the new boxes to the collection\n    end\n    return B₀\nend","category":"page"},{"location":"algorithms/unstable_manifold/#References","page":"Stable and Unstable Manifold","title":"References","text":"","category":"section"},{"location":"algorithms/unstable_manifold/","page":"Stable and Unstable Manifold","title":"Stable and Unstable Manifold","text":"[1] Michael Dellnitz and Adreas Hohmann. “The Computation of Unstable Manifolds Using Subdivision”. In: Nonlinear Systems and Chaos. Ed. by Haim Brezis. Vol. 19. Progress in Nonlinear Differential Equations and their Applications. 1996, pp. 449–459. doi: https://doi.org/10.1007/978-3-0348-7518-9.","category":"page"},{"location":"examples/#Examples","page":"Other Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#How-to-Use","page":"Other Examples","title":"How to Use","text":"","category":"section"},{"location":"examples/","page":"Other Examples","title":"Other Examples","text":"To see examples of how to use GAIO.jl explore the examples folder. This contains a Project.toml file that can be used to download all the necessary dependencies for the examples. ","category":"page"},{"location":"examples/","page":"Other Examples","title":"Other Examples","text":"To try the examples, one can choose between two options:","category":"page"},{"location":"examples/","page":"Other Examples","title":"Other Examples","text":"(recommended) simply download an example file and see what packages are used, add them in the package manager\nclone the GAIO.jl GitHub repository. Navigate to the repository folder /path/to/GAIO.jl/examples in the julia REPL using pwd and cd. Finally, call the following in the julia REPL","category":"page"},{"location":"examples/","page":"Other Examples","title":"Other Examples","text":"pkg> activate .\njulia> pwd()\n\"/path/to/GAIO.jl\"\n\njulia> cd(\"./examples\")\n\n(GAIO) pkg> activate .\n  Activating project at `/path/to/GAIO.jl/examples`\n\n(examples) pkg> dev ../\n   Resolving package versions...\n  No Changes to `/path/to/GAIO.jl/examples/Project.toml`\n  No Changes to `/path/to/GAIO.jl/examples/Manifest.toml`\n\n(examples) pkg> instantiate\n  69 dependencies successfully precompiled in 74 seconds","category":"page"},{"location":"examples/#Example-Files","page":"Other Examples","title":"Example Files","text":"","category":"section"},{"location":"examples/","page":"Other Examples","title":"Other Examples","text":"Relative attractor of the Hénon map\nUnstable manifold of the Lorenz system\nChain recurrent of a knotted flow\nInvariant measure of the transfer operator for the logistic map\nInvariant measure of the transfer operator for the Hénon map over the relative attractor\nInvariant measure of the transfer operator for the Lorenz map over the unstable manifold\nAlmost invariant sets in Chua's circuit\nRoot covering of a cubic map\nDoubling performance using SIMD operations\nVastly improving performance using Nvidia CUDA","category":"page"},{"location":"boxmaps/grid/#GridBoxMap","page":"GridBoxMap","title":"GridBoxMap","text":"","category":"section"},{"location":"boxmaps/grid/","page":"GridBoxMap","title":"GridBoxMap","text":"Another naive but still useful approach is to place the test points on an equidistant grid within a box. This approach removes an element of randomness from the Monte-Carlo approach. ","category":"page"},{"location":"boxmaps/grid/","page":"GridBoxMap","title":"GridBoxMap","text":"GridBoxMap","category":"page"},{"location":"boxmaps/grid/#GAIO.GridBoxMap","page":"GridBoxMap","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\n\n\n\n\nBoxMap(:grid, :simd, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu's SIMD capacity. \n\n\n\n\n\nBoxMap(:grid, :gpu, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"function"},{"location":"boxmaps/grid/#Example","page":"GridBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/grid/","page":"GridBoxMap","title":"GridBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/grid/","page":"GridBoxMap","title":"GridBoxMap","text":"n_points = (8, 8)\nF = BoxMap(:grid, f, domain, n_points = n_points)\np = plot!(\n    p, F(B), \n    color=RGBA(0.,1.,0.,0.5), \n    lab=\"$(join(n_points, \"x\")) grid of test points\"\n)\n\nsavefig(\"grid.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/grid/","page":"GridBoxMap","title":"GridBoxMap","text":"(Image: Grid BoxMap)","category":"page"},{"location":"general/#Usage","page":"General usage","title":"Usage","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The base of the numerical set oriented methods of this framework are BoxSet (the discretization of a set of boxes) and BoxMap (the discretization of a map). Thus, in the following, we will have a closer look at the two and other useful things to know when using GAIO.jl. ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To create a Box given its center point c = (c_1, c_2, ..., c_d) as well as its \"radius\" in every axis direction r = (r_1, r_2, ..., c_d), simply type ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"using GAIO\nc, r = (0.5, 0.5), (0.5, 0.5)\nQ = Box(c, r)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This creates a set Q = c_1 - r_1 c_1 + r_1) times ldots times c_d - r_d c_d + r_d). Conversely, one can get back the vectors c and r by calling","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"c, r = Q","category":"page"},{"location":"general/#BoxPartition","page":"General usage","title":"BoxPartition","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"Most algorithms in GAIO.jl revolve around a partition of the domain Q into small boxes. To create an n_1 times ldots times n_d - element equidistant grid of boxes, we can pass the tuple n = (n_1 ldots n_d) into the function BoxPartition","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"n = (4, 2)\nP = BoxPartition(Q, n)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"BoxPartitions use a cartesian indexing structure to be memory-efficient. These indices are accessed and used through the API:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"x = (0.2, 0.1)\nkey = point_to_key(P, x)    # x is some point in the domain Q\nbox = key_to_box(P, key)    # cover the point x with a box from P\nbox = point_to_box(P, x)    # performs both above functions","category":"page"},{"location":"general/#TreePartition","page":"General usage","title":"TreePartition","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"For partitions of Q into variably sized boxes, one can use TreePartition:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"P2 = TreePartition(Q)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"A TreePartition uses a binary tree structure to store a partition of the domain. Every Box of a TreePartition can be split using the command ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"subdivide!(P2)\nsubdivide!(P2)\nsubdivide!(P2)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"The axis direction along which to subdivide cycles through with the depth, i.e. subdividing at depth 1 splits along dimension 1, subdividing at depth d+1 splits along dimension 1 again. ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"The TreePartition created above is equivalent to a 4x2 BoxPartition. One can retrieve this using ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"P3 = BoxPartition(P2)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"TreePartitions use indices of the type (depth, cartesian_index) where cartesian_index is the equivalent index of a BoxPartition with the same size as a TreePartition subdivided depth times. In other words,","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"key_to_box( P, (1, 1) ) == key_to_box( P2, (4, (1, 1)) )\nkey_to_box( P, (4, 2) ) == key_to_box( P2, (4, (4, 2)) )","category":"page"},{"location":"general/#BoxSet","page":"General usage","title":"BoxSet","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The core idea behind GAIO.jl is to approximate a subset of the domain via a collection of small boxes. To construct BoxSets, there are two main options: getting all boxes in the partition, or locating a box surrounding a point x in Q","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"B = cover(P, x)    # one box surrounding the point x\nB = cover(P, :)    # set of all boxes in P","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"One can also create a Boxset from an iterable of Boxes. This will cover every element of the iterable with boxes from P:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"x1 = (0.2, 0.1)\nbox1 = point_to_box(P, x1)\nx2 = (0.3, 0.6)\nbox2 = point_to_box(P, x2)\nB = cover(P, [box1, box2])","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"BoxSet is a highly memory-efficient way of storing boxes. However, should you want to access the boxes or their internal data, this can be done via iteration:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"for box in B\n    center, radius = box\n    # do something\nend\n\n# get an array of boxes\narr_of_boxes = collect(B)\n\n# get an array of box centers\narr_of_centers = collect(box.center for box in B)\n\n# get an array of box radii\narr_of_radii = collect(box.radius for box in B)\n\n# (memory-efficiently) create a matrix where each center is a column\nmat_of_centers = reinterpret(reshape, eltype(arr_of_centers[1]), arr_of_centers)","category":"page"},{"location":"general/#BoxMap","page":"General usage","title":"BoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"A BoxMap is a function which maps boxes to boxes. Given a pointmap f : ℝᵈ → ℝᵈ which accepts an SVector from StaticArrays.jl (or just an NTuple) and returns the same, ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"function f(u)   # the Baker transformation\n    x, y = u\n    if x < 0.5\n        (2x, y/2)\n    else\n        (2x - 1, y/2 + 1/2)\n    end\nend","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"initialize the corresponding BoxMap F by","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"F = BoxMap(f, Q)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This will generate a BoxMap which attempts to calculate setwise images of f. There are many types of BoxMap discretizations available, see the section on BoxMaps for more information. ","category":"page"},{"location":"general/#Using-BoxMap","page":"General usage","title":"Using BoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"Now, one can map a BoxSet via the BoxMap F by simply calling F as a function ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"C = F(B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"where the output C is also a BoxSet.","category":"page"},{"location":"general/#TransferOperator","page":"General usage","title":"TransferOperator","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The Perron-Frobenius operator (or transfer operator) [2] is discretized in GAIO.jl using the TransferOperator type. To initialize a TransferOperator that acts on a subdomain of Q, type","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"B = cover(P, :)\nT = TransferOperator(F, B)   # T operates on the domain covered by the box set B","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"In this case, the codomain is generated automatically. This is not always ideal (e.g. in eigenvalue calculations), so the codomain can be specified as the third argument","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"T = TransferOperator(F, B, B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To convert this to the underlying transfer matrix described in [3], one can simply type ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Matrix(T)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To find an approximate invariant measure over B use the eigs function from Arpack.jl. All keyword arguments from Arpack.eigs are supported. ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"# for the Baker trafo, the Lebesque measure \n# - i.e. the constant-weight measure - is invariant\nλ, ev = eigs(T);\nλ\nev\nμ = ev[1]   # ev is an array of measures, grab the first one","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This can also be done with the adjoint Koopman operator T'. ","category":"page"},{"location":"general/#BoxFun","page":"General usage","title":"BoxFun","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The return type of the second output of eigs(T) is a discretization of a measure over the domain. Specifically, it is a piecewise constant function defined on boxes in B, which is called a BoxFun. One can let T act on a BoxFun simply through multiplication","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"ν = T*μ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Of course, the same holds for the the Koopman operator as well. ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"ν = T'μ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Since a measure mu is a function defined over measurable sets, composite measures g circ mu are well-defined for functions g  mathbbR to mathbbR (or g  mathbbC to mathbbC). This is supported in GAIO.jl for BoxFuns","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"η = exp ∘ μ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"For multiple BoxFuns, e.g. as the result of calling eigs(T), the concatenation operator ∘ can be applied to each one using julia's broadcasting functionality","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"real_ev = real .∘ ev","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Similarly, finite signed measures can be given a vector space structure. This is also supported in GAIO.jl","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"ν + μ\n2ν - μ/2","category":"page"},{"location":"general/#BoxGraph","page":"General usage","title":"BoxGraph","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"One could equivalently view the transfer operator as a weighted directed graph. That is, a transfer matrix in GAIO.jl is the (transposed) weighted adjacency matrix for a graph. This graph can be constructed using","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"G = Graph(T)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"The return type is a BoxGraph. Boxgraph is hooked into the Graphs.jl interface, which means all algorithms or etc. from Graphs.jl should work \"out of the box\". To construct a BoxSet from some index / indices of vertices in a BoxGraph, call","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"BoxSet(G, vertex_index_or_indices)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"See the docstring for BoxGraph for details on how to translate between GAIO.jl and Graphs.jl. ","category":"page"},{"location":"general/#Plotting","page":"General usage","title":"Plotting","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"GAIO.jl offers both Plots or Makie for plotting. To plot a BoxSet or a BoxFun, simply choose either Plots or a Makie backend, eg. GLMakie, and call plot on a BoxSet or BoxFun","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"using GLMakie: plot\n\nplot(B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Plotting works with all the functionality of either package. This means you can set box plots as subplots, add colorbars, etc., using the Plots or Makie interface. For an example, see examples/invariant_measure_2d.jl. ","category":"page"},{"location":"general/#References","page":"General usage","title":"References","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"[2] Andrzej Lasota and Michael C. Mackey. Chaos, Fractals, and Noise. Stochastic Aspects of Dynamics. Springer New York, NY, 1994. doi: https://doi.org/10.1007/978-1-4612-4286-4.","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"[3] Michael Dellnitz, Oliver Junge, and Gary Froyland. “The Algorithms Behind GAIO - Set Oriented Numerical Methods for Dynamical Systems”. In: Ergodic Theory, Analysis, and Efficient Simulations of Dynamical Systems. Ed. by Bernold Fiedler. Springer Berlin, 2001, pp. 145–174. doi: https://doi.org/10.1007/3-540-35593-6.","category":"page"},{"location":"boxmaps/montecarlo/#MonteCarloBoxMap","page":"MonteCarloBoxMap","title":"MonteCarloBoxMap","text":"","category":"section"},{"location":"boxmaps/montecarlo/","page":"MonteCarloBoxMap","title":"MonteCarloBoxMap","text":"The simplest technique for discretization is a Monte-Carlo approach: choose a random set of points (sampled according to a uniform distribution) within a box and record which boxes are hit by the point map. ","category":"page"},{"location":"boxmaps/montecarlo/","page":"MonteCarloBoxMap","title":"MonteCarloBoxMap","text":"MonteCarloBoxMap","category":"page"},{"location":"boxmaps/montecarlo/#GAIO.MonteCarloBoxMap","page":"MonteCarloBoxMap","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses n_points  Monte-Carlo test points. \n\n\n\n\n\nBoxMap(:montecarlo, :simd, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses n_points  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu's SIMD capacity. \n\n\n\n\n\nBoxMap(:montecarlo, :gpu, map, domain::Box{N}; n_points=16*N) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses n_points  Monte-Carlo test points. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"function"},{"location":"boxmaps/montecarlo/#Example","page":"MonteCarloBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/montecarlo/","page":"MonteCarloBoxMap","title":"MonteCarloBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/montecarlo/","page":"MonteCarloBoxMap","title":"MonteCarloBoxMap","text":"n_points = 128\nF = BoxMap(:montecarlo, f, domain, n_points = n_points)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,0.,0.5), \n    lab=\"$n_points MonteCarlo test points\"\n)\n\nsavefig(\"montecarlo.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/montecarlo/","page":"MonteCarloBoxMap","title":"MonteCarloBoxMap","text":"(Image: MonteCarlo BoxMap)","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"GAIO.jl offers plotting recipes for both Plots.jl and Makie.jl. This means that one can use all the surrounding functionality of Plots.jl or makie.jl, e.g. creating multiple subplots, animations, colorbars, etc. simply by loading either Plots.jl or Makie.jl. ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"note: Why offer both Plots and Makie recipes?\nMakie.jl offers much more funcitonality and performance in interactive plots, but suffers much more greatly from the well known time to fist plot problem. Hence GAIO.jl offers Plots.jl recipes for fast, 2-dimensional, non-interactive plotting, and Makie.jl recipes for interactive, 2- and 3-dimensional, or publication-quality visualizations. To see a difference in the plotting capability, see the Hénon map example. ","category":"page"},{"location":"plotting/#Using-Plots","page":"Plotting","title":"Using Plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To make a plot, one needs to simply load the package. Add Plots using the package manager","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"pkg> add Plots","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Load Plots with","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plots","category":"page"},{"location":"plotting/#Using-Makie","page":"Plotting","title":"Using Makie","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To see a plot, one needs to load one of the Makie backends (see makie documentation about backends). We will use GLMakie, which uses OpenGL. Add GLMakie using the package manager","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"pkg> add GLMakie","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Load the GLMakie backend and some plotting tools with","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using GLMakie: plot #, Axis3, Colorbar, etc...","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"warning: A note on Namespaces\nMakie and GAIO.jl both export the type Box. For this reason, it is recommended NOT to use using GLMakieand instead only load the function names one needs from Makie. ","category":"page"},{"location":"plotting/#Common-Interface","page":"Plotting","title":"Common Interface","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To plot a BoxSet or BoxFun b, simply call ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(b)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The mutating function plot! is also available. All of Plots.jl's or Makie.jl's keyword arguments, such as color, colormap, etc. can be used. In addition, the keyword argument projection is used to project to a lower dimensional space if the dimension of the space d is greater than 2 for Plots.jl or greater than 3 for Makie.jl. By default, the function used is x -> x[1:2] for Plots.jl and x -> x[1:3] for Makie.jl. For an example using a custom projection function, eg. to plot the unstable set of the dadras system:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using GAIO\nusing GLMakie: plot\n\n# the Dadras system\nconst a, b, c = 8.0, 40.0, 14.9\nv((x,y,z,w)) = (a*x-y*z+w, x*z-b*y, x*y-c*z+x*w, -y)\nf(x) = rk4_flow_map(v, x, 0.01, 5)\n\ncen, rad = (0,0,0,0), (250,150,200,25)\nP = BoxPartition(Box(cen, rad), (128,128,128,128))\nF = BoxMap(f, P.domain)\n\nx = zeros(4)        # equilibrium\nW = unstable_set(F, P[x])\n\nA = [0 1 0 0;\n     0 0 1 0;\n     0 0 0 1]\n\nplot(W, projection = x -> A*x)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"GAIO.plotboxes","category":"page"},{"location":"plotting/#GAIO.plotboxes","page":"Plotting","title":"GAIO.plotboxes","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :red Color used for the boxes.\n\ncolormap = :default Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box. Only works if using Makie for plotting. \n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"function"},{"location":"#GAIO.jl","page":"Home","title":"GAIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GAIO\nDocTestSetup = quote\n  using GAIO\nend","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GAIO (Global Analysis of Invariant Objects) is a Julia package for set oriented computations.  Sets are represented by  collections of boxes. A box (or cube) is a higher dimensional interval, i.e. a set of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"a_1b_1)  ldots  a_nb_n) quad a_kb_k  ℝ","category":"page"},{"location":"","page":"Home","title":"Home","text":"GAIO.jl provides algorithms for  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"dynamical systems\ninvariant sets (maximal invariant set, chain recurrent set, (relative) attractor, (un-)stable manifold)\nalmost invariant and coherent sets\nfinite time Lyapunov exponents\nentropy and box dimension\nroot finding problems\nmulti-objective optimization problems\ncomputing implicitely defined manifolds","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package requires Julia 1.7 or later. In Julia's package manager, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gaioguys/GAIO.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"followed by","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GAIO","category":"page"},{"location":"","page":"Home","title":"Home","text":"at the Julia prompt in order to load the package.","category":"page"},{"location":"#Project-origin","page":"Home","title":"Project origin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package originated as a university seminar for master students in the summer 2020, with the aim to enhance  and convert the already existing Matlab GAIO package to Julia.","category":"page"},{"location":"algorithms/root_covering/#Root-Covering","page":"Root Covering","title":"Root Covering","text":"","category":"section"},{"location":"algorithms/root_covering/#Mathematical-Background","page":"Root Covering","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"Nonlinear optimization theory offers a multitude of algorithms to iteratively approximate roots of functions h  mathbbR^d to mathbbR^d, that is, algorithms f  mathbbR^d to mathbbR^d such that (under some conditions) f^k (x) to x_0 as k to infty with h(x_0) = mathbf0. We can consider these algorithms from the point of view of dynamics, and reframe the problem of finding a root of h to finding a fixed point of f. ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"Specifically, we will consider f to be a globalized Newton algorithm. One step of the (local) Newton algorithm follows the specification: solve the linear equation ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"Dh (x) d = - h(x)","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"and set ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"f(x) = x + d ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"where Dh (x) is the Jacobi matrix of h at x. ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"The local Newton algorithm is not guaranteed to converge to a global solution to h(x) = 0. To rectify this, the step size  d  and direction d   d  need to be modified. There are multiple heuristics to do this, and GAIO.jl uses the \"Armijo rule\": fix some sigma  1 and find the largest alpha leq 1 such that ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"h(x + alpha d) - h(x) leq alpha sigma  Dh (x)^T d","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"This is done by initializing alpha = 1 and testing the above condition. If it is not satisfied, scale alpha by some constant rho, ie set alpha = rho cdot alpha, and test the condition again. GAIO.jl uses sigma = 10^-4 and rho = 4  5. ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"Using this iterative solver, one can follow a technique very similar to the algorithm for the realtive attractor. ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: The box set B is mapped forward using one step of the adaptive newton algorithm. ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"If we repeadetly refine the box set B through k subdivision steps, then as k to infty the collection of boxes converges to the set of roots of h in the Hausdorff metric. ","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"cover_roots\nadaptive_newton_step\narmijo_rule","category":"page"},{"location":"algorithms/root_covering/#GAIO.cover_roots","page":"Root Covering","title":"GAIO.cover_roots","text":"cover_roots(g, Dg, B::BoxSet; steps=12) -> BoxSet\n\nCompute a covering of the roots of g within the  partition P. Generally, B should be  a box set containing the whole partition P, ie  B = cover(P, :), and should contain a root of g. \n\n\n\n\n\n","category":"function"},{"location":"algorithms/root_covering/#GAIO.adaptive_newton_step","page":"Root Covering","title":"GAIO.adaptive_newton_step","text":"adaptive_newton_step(g, g_jacobian, x, k=1)\n\nReturn one step of the adaptive Newton algorithm for the point x. \n\n\n\n\n\n","category":"function"},{"location":"algorithms/root_covering/#GAIO.armijo_rule","page":"Root Covering","title":"GAIO.armijo_rule","text":"armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)\n\nFind a step size multiplier alpha in (alpha_0 alpha_1  such that \n\ng(x + alpha d) - g(x) leq alpha sigma  Dg(x) cdot d\n\nThis is done by initializing alpha = 1 and testing the  above condition. If it is not satisfied, scale alpha  by some constant rho  1 (i.e. set  alpha = rho cdot alpha), and test the condition  again. \n\n\n\n\n\n","category":"function"},{"location":"algorithms/root_covering/#Example","page":"Root Covering","title":"Example","text":"","category":"section"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"using GAIO\nusing LinearAlgebra\n\n# domain (-40,40)^n, 3^n roots in domain\ng(x) = 100*x + x.^2 - x.^3 .- sum(x)\nfunction Dg(x)  # jacobian\n    n = length(x)\n    100*I(n) + 2*Diagonal(x) - 3*Diagonal(x.^2) + ones(n,n)\nend\n\ndim = 3\ncenter, radius = zeros(dim), 40*ones(dim)\nP = BoxPartition(Box(center, radius))\n\nS = cover(P, :)\nR = cover_roots(g, Dg, S, steps=dim*8)\n\n#using Plots: plot       # plot a 2D projection\nusing GLMakie: plot    # plot a 3D projection\n\nfig, ax, ms = plot(R);\n\nusing GLMakie: save # hide\nsave(\"roots.png\", fig); nothing # hide","category":"page"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"(Image: Root covering)","category":"page"},{"location":"algorithms/root_covering/#Implementation","page":"Root Covering","title":"Implementation","text":"","category":"section"},{"location":"algorithms/root_covering/","page":"Root Covering","title":"Root Covering","text":"function cover_roots(g, Dg, B₀::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    # B₀ is a set of `N`-dimensional boxes\n    B = B₀\n    domain = B.partition.domain\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)       # cycle through dimesions for subdivision\n        f(x) = adaptive_newton_step(g, Dg, x, k)\n        F = BoxMap(f, domain)          # define a BoxMap which performs one newton step\n        B = F(B)                       # map the set forward along the newton step\n    end\n    return B\nend","category":"page"},{"location":"boxmaps/adaptive/#AdaptiveBoxMap","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"","category":"section"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"The above approaches may not necessarily be effective for covering the setwise image of a box. For choosing test points more effectively, we can use some knowledge of the Lipschitz matrix for f in a box Box(c, r), that is, a matrix L in mathbbR^d times d such that ","category":"page"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":" f(y) - f(z)  leq L   y - z  quad textfor all  y z in textBox(c r)","category":"page"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"where the operations  cdot  and leq are to be understood elementwise. The function AdaptiveBoxMap attempts to approximate L before choosing an adaptive grid of test points in each box, as described in [1]. ","category":"page"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"AdaptiveBoxMap","category":"page"},{"location":"boxmaps/adaptive/#GAIO.AdaptiveBoxMap","page":"AdaptiveBoxMap","title":"GAIO.AdaptiveBoxMap","text":"BoxMap(:adaptive, f, domain::Box) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses sample_adaptive to  generate test points as described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"function"},{"location":"boxmaps/adaptive/#Example","page":"AdaptiveBoxMap","title":"Example","text":"","category":"section"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"using GAIO\nusing Plots\n\n# We choose a simple but expanding map\nconst α, β, γ, δ, ω = 2., 9.2, 10., 2., 10.\nf((x, y)) = (α + β*x + γ*y*(1-y), δ + ω*y)\n\nmidpoint = round.(Int, ( 1+(α+β+γ/4)/2, 1+(δ+ω)/2 ), RoundUp)\ndomain = Box(midpoint, midpoint)\n\nP = BoxPartition(domain, 2 .* midpoint)\np = plot(cover(P, :), linewidth=0.5, fillcolor=nothing, lab=\"\", leg=:outerbottom)\n\n# unit box\nB = cover(P, (0,0))\np = plot!(p, B, linewidth=4, fillcolor=RGBA(0.,0.,1.,0.2), linecolor=RGBA(0.,0.,1.,0.4), lab=\"Box\")\n\n# Plot the true image of B under f.\nz = zeros(100)\nboundary = [\n    0       0;\n    1       0;\n    z.+1    0.01:0.01:1;\n    0       1;\n    z       0.99:-0.01:0;\n]\nb = f.(eachrow(boundary))\nboundary .= [first.(b) last.(b)]\np = plot!(p, boundary[:, 1], boundary[:, 2], linewidth=4, fill=(0, RGBA(0.,0.,1.,0.2)), color=RGBA(0.,0.,1.,0.4), lab=\"True image under f\")","category":"page"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"F = BoxMap(:adaptive, f, domain)\np = plot!(\n    p, F(B), \n    color=RGBA(1.,0.,1.,0.5), \n    lab=\"adaptive test points\"\n)\n\nsavefig(\"adaptive.svg\"); nothing # hide","category":"page"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"(Image: Adaptive BoxMap)","category":"page"},{"location":"boxmaps/adaptive/#References","page":"AdaptiveBoxMap","title":"References","text":"","category":"section"},{"location":"boxmaps/adaptive/","page":"AdaptiveBoxMap","title":"AdaptiveBoxMap","text":"[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.","category":"page"}]
}
