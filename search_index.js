var documenterSearchIndex = {"docs":
[{"location":"library_reference/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"library_reference/","page":"Library Reference","title":"Library Reference","text":"Pages = [\"library_reference.md\"]","category":"page"},{"location":"library_reference/","page":"Library Reference","title":"Library Reference","text":"Modules = [GAIO]","category":"page"},{"location":"library_reference/#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}","page":"Library Reference","title":"GAIO.BoxMap","text":"BoxMap(map, domain; no_of_points=ntuple(_->4, N)) -> SampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a SampledBoxMap defined  on Boxes. \n\nBy default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated BoxMaps, uses a grid of test points by default. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1<:(TransferOperator{P, T, S} where S<:(BoxSet{P, P1} where P1<:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S<:BoxSet{B, Q, R}, P<:(TransferOperator{B, T, S})}","page":"Library Reference","title":"GAIO.BoxSet","text":"BoxSet(boxgraph, graph_index_or_indices) -> BoxSet\n\nConstruct a BoxSet from some  index / indices of vertices in a BoxGraph. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.Node","page":"Library Reference","title":"GAIO.Node","text":"Node structure used for TreePartitions\n\nFields:\n\nleft and right refer to indices w.r.t. \n\ntrp.nodes for a TreePartition trp. \n\n\n\n\n\n","category":"type"},{"location":"library_reference/#Arpack.eigs","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d,[v,],nconv,niter,nmult,resid)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#Arpack.eigs-2","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d,[v,],nconv,niter,nmult,resid)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#Arpack.eigs-3","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d,[v,],nconv,niter,nmult,resid)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}","page":"Library Reference","title":"Base.sum","text":"sum(f, μ::BoxFun)\nsum(f, μ::BoxFun, B::BoxSet)\nμ(B) = sum(x->1, μ, B)\n\nIntegrate a function f using μ as a density, that is, if boxfun is the discretization of a measure mu over the domain  Q, then approximate the value of \n\nint_Q f  dmu \n\nIf a BoxSet B is passed as the third argument, then the  integration is restricted to the boxes in B\n\nint_Q cap bigcup_b in B b f  dmu \n\nThe notation μ(B) is offered to compute  mu (bigcup_b in B b). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.AdaptiveBoxMap","text":"BoxMap(:adaptive, f, domain::Box) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses sample_adaptive to  generate test points as described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, :simd, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu's SIMD capacity. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses n_points  Monte-Carlo test points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}}} where {N, T}","page":"Library Reference","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, :simd, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses n_points  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu's SIMD capacity. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}","page":"Library Reference","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, map, domain, points) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses the iterator points as test points.  points must be an array or iterator of test points within the unit cube  [-1,1]^N. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, :gpu, map, domain, points) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses the Vector points as test points.  points must be a VECTOR of test points within the unit cube  [-1,1]^N. \n\nRequires a CUDA-capable gpu. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, :simd, map, domain, points) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses the iterator  points as test points. points must have eltype  SVector{N, SIMD.Vec{S,T}} and be within the unit  cube [-1,1]^N. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.adaptive_newton_step","page":"Library Reference","title":"GAIO.adaptive_newton_step","text":"adaptive_newton_step(g, g_jacobian, x, k=1)\n\nReturn one step of the adaptive Newton algorithm for the point x. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.approx_lipschitz","text":"approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -> Matrix\n\nCompute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies \n\n f(x) - f(y)  leq L  x - y  quad forall  xy in textBox(center radius)\n\ncomponentwise. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.armijo_rule","page":"Library Reference","title":"GAIO.armijo_rule","text":"armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)\n\nFind a step size multiplier alpha in (alpha_0 alpha_1  such that \n\ng(x + alpha d) - g(x) leq alpha sigma  Dg(x) cdot d\n\nThis is done by initializing alpha = 1 and testing the  above condition. If it is not satisfied, scale alpha  by some constant rho  1 (i.e. set  alpha = rho cdot alpha), and test the condition  again. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B<:Box{N, T}}","page":"Library Reference","title":"GAIO.bounded_point_to_key","text":"bounded_point_to_key(P::BoxPartition, point)\n\nFind the cartesian index of the nearest box within a  BoxPartition to a point. Conicides with point_to_key  if the point lies in the partition. Default behavior  is to set NaN = Inf if NaNs are present in point. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.box_dimension-Tuple{Any}","page":"Library Reference","title":"GAIO.box_dimension","text":"box_dimension(boxsets) -> D\n\nFor an iterator boxsets of (successively finer)  BoxSets, compute the box dimension D. \n\nExample\n\n# F is some BoxMap, S is some BoxSet\nbox_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.center-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.center","text":"center(center, radius)\n\nReturn the center of a box as an iterable.  Default function for image_points in SampledBoxMaps. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.center-Tuple{Box}","page":"Library Reference","title":"GAIO.center","text":"center(b::Box)\n\nReturn the center of a box. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.chain_recurrent_set","text":"chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the chain recurrent set over the box set B. Generally,  B should be a box set containing the whole partition P,  ie B = cover(P, :). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P<:AbstractBoxPartition","page":"Library Reference","title":"GAIO.cover","text":"BoxSet constructors:\nset of all boxes in partition / box set P:\njulia   B = cover(P, :)\ncover the point x, or points x = [x_1, x_2, x_3] # etc ... using boxes from P\njulia   B = cover(P, x)    \na covering of S using boxes from P\njulia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)\n\nReturn a subset of the partition or box set P based on the second argument. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P<:BoxPartition{N, T, I}}","page":"Library Reference","title":"GAIO.cover_boxes","text":"cover_boxes(partition::BoxPartition, boxes)\n\nReturn a covering of an iterator of Boxes using Boxes from partition.  Only covers the part of boxes which lies within partition.domain.  This is returned by cover(partition, boxes). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}","page":"Library Reference","title":"GAIO.cover_manifold","text":"cover_manifold(f, B::BoxSet; steps=12)\n\nUse interval arithmetic to compute a covering of  an implicitly defined manifold M of the form \n\nf(M) equiv 0\n\nfor some function f  mathbbR^N to mathbbR. \n\nThe starting BoxSet B should (coarsely) cover  the manifold. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.cover_roots","text":"cover_roots(g, Dg, B::BoxSet; steps=12) -> BoxSet\n\nCompute a covering of the roots of g within the  partition P. Generally, B should be  a box set containing the whole partition P, ie  B = cover(P, :), and should contain a root of g. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}","page":"Library Reference","title":"GAIO.depth","text":"depth(tree::TreePartition)\n\nReturn the depth of the tree structure. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.expon","page":"Library Reference","title":"GAIO.expon","text":"expon(h, k=1, ϵ=0.2, δ=0.1)\n\nReturn a rough estimate of how many Newton steps  should be taken, given a step size h. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}","page":"Library Reference","title":"GAIO.find_at_depth","text":"find_at_depth(tree, depth)\n\nReturn all node indices at a specified depth. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P<:AbstractBoxPartition{E}}}} where {N, T, E<:Box{N, T}}","page":"Library Reference","title":"GAIO.finite_time_lyapunov_exponents","text":"finite_time_lyapunov_exponents(f, Df, μ::BoxFun; n=8) -> σ\n\nCompute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff's ergodic theorem. Computes \n\nsigma_j = frac1n int log R_jj( Df^n (x) )  dμ (x) quad j = 1 ldots d\n\nwith respect to an ergodic invariant measure mu. \n\n[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R<:Box{N, V}, Q, S}","page":"Library Reference","title":"GAIO.finite_time_lyapunov_exponents","text":"finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -> BoxFun\n\nCompute the Finite Time Lyapunov Exponent for  every box in boxset, where F represents a time-T  integration of some continuous dynamical system.  It is assumed that all boxes in boxset have radii  of some fixed order ϵ. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.fixqr!-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.fixqr!","text":"fixqr!(Q, R)\n\nAdjust a QR-decomposition such that the  R-factor has positive diagonal entries. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q<:(TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}))}","page":"Library Reference","title":"GAIO.hidden_keys","text":"hidden_keys(tree)\n\nReturn all keys within the tree, including  keys not corresponding to leaf nodes. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.index_to_key-Tuple{AbstractArray, Any}","page":"Library Reference","title":"GAIO.index_to_key","text":"index_to_key(iterable, i)\n\nReturn the object held in the ith position of iterable.  Used to enumerate BoxSets as  left B_1 B_2 ldots B_n right in  TransferOperator, BoxGraph. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.key_to_box","text":"key_to_box(P::BoxPartition, key)\n\nReturn the box associated with the index  within a BoxPartition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.key_to_index-Tuple{AbstractArray, Any}","page":"Library Reference","title":"GAIO.key_to_index","text":"key_to_index(iterable, key)\n\nFind the index in 1..length(iterable) which holds key,  or return nothing. Used to enumerate BoxSets as  left B_1 B_2 ldots B_n right in  TransferOperator, BoxGraph. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.leaves","text":"leaves(tree, initial_node_idx=1)\n\nReturn the node indices of all leaves.  Begins search at initial_node_idx, i.e. only returns node indices of nodes below  initial_node_idx within the tree. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.linreg-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.linreg","text":"linreg(xs, ys)\n\nSimple one-dimensional lunear regression used to  approximate box dimension. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.nth_iterate_jacobian-NTuple{4, Any}","page":"Library Reference","title":"GAIO.nth_iterate_jacobian","text":"nth_iterate_jacobian(f, Df, x, n; return_QR=false) -> Z[, R]\n\nCompute the Jacobian of the n-times iterated function  f ∘ f ∘ ... ∘ f at x using a QR iteration based on [1].  Requires an approximation Df of the jacobian of f, e.g.  Df(x) = ForwardDiff.jacobian(f, x).  Optionally, return the QR decomposition. \n\n[1] Dieci, L., Russell, R. D., Van Vleck, E. S.: \"On the  Computation of Lyapunov Exponents for Continuous Dynamical  Systems,\" submitted to SIAM J. Numer. Ana. (1993).\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.plotboxes!-Tuple","page":"Library Reference","title":"GAIO.plotboxes!","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :red Color used for the boxes.\n\ncolormap = :default Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box. Only works if using Makie for plotting. \n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.plotboxes-Tuple","page":"Library Reference","title":"GAIO.plotboxes","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :red Color used for the boxes.\n\ncolormap = :default Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box. Only works if using Makie for plotting. \n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}","page":"Library Reference","title":"GAIO.point_to_box","text":"point_to_box(P::AbstractBoxPartition, point)\n\nFind the box within a BoxPartition containing a point. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.point_to_key","text":"point_to_key(P::BoxPartition, point)\n\nFind the index for the box within a BoxPartition  contatining a point, or nothing if the point does  not lie in the domain. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.radius-Tuple{Box}","page":"Library Reference","title":"GAIO.radius","text":"radius(b::Box)\n\nReturn the radius of a box. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.relative_attractor","text":"relative_attractor(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the attractor relative to B. Generally, B should be  a box set containing the whole partition P, ie B = cover(P, :).\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Tuple{Any, Any, Any}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(center, radius, points)\n\nReturn an iterable which calls rescale(center, radius, point) for each point in points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Tuple{Any}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(points)\n\nReturn a function \n\n(center, radius) -> rescale(center, radius, points)\n\nUsed in domain_points for BoxMap, PointDiscretizedMap. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(box, point::Union{<:StaticVector{N,T}, <:NTuple{N,T}})\nrescale(center, radius, point::Union{<:StaticVector{N,T}, <:NTuple{N,T}})\n\nScale a point within the unit box -1 1^N  to lie within box = Box(center, radius). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rk4-Tuple{Any, Any, Any}","page":"Library Reference","title":"GAIO.rk4","text":"rk4(f, x, τ)\n\nCompute one step with step size τ of the classic  fourth order Runge-Kutta method. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rk4_flow_map","page":"Library Reference","title":"GAIO.rk4_flow_map","text":"rk4_flow_map(f, x, step_size=0.01, steps=20)\n\nPerform steps steps of the classic Runge-Kutta fourth order method, with step size step_size. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.sample_adaptive","text":"sample_adaptive(f, center::SVector, radius::SVector)\n\nCreate a grid of test points using the adaptive technique  described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U","page":"Library Reference","title":"GAIO.seba","text":"seba(V::Matrix{<:Real}, Rinit=nothing, maxiter=5000) -> S, R\n\nConstruct a sparse approximation of the basis V, as described in  [1]. Returns matrices S, R such that\n\nfrac12  V - SR _F^2 + mu  S _11\n\nis minimized, where mu in mathbbR,  cdot _F is the Frobenuius-norm,  and  cdot _11 is the element sum norm, and R  is orthogonal. See [1] for further information on the argument  Rinit, as well as a description of the algorithm. \n\n[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D<:OrderedCollections.OrderedDict, U<:BoxFun{B, K, W, Q, D}}","page":"Library Reference","title":"GAIO.seba","text":"seba(V::Vector{<:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -> S, A\n\nConstruct a sparse eigenbasis approximation of V, as described in  [1]. Returns an Array of BoxFuns corresponding to the eigenbasis,  as well as a maximum-likelihood BoxFun that maps a box to the  element of S which has the largest value over the support. \n\nThe keyword which is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are\n\npartition_unity, partition_disjoint, partition_likelihood\n\nwhich are all exported functions. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V<:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}","page":"Library Reference","title":"GAIO.subdivide!","text":"subdivide!(tree::TreePartition, key::keytype(tree)) -> TreePartition\nsubdivide!(tree::TreePartition, depth::Integer) -> TreePartition\n\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, key) -> BoxSet\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, depth) -> BoxSet\n\nSubdivide a TreePartition at key. Dimension along which  the node is subdivided depends on the depth of the node. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P<:TreePartition, S}","page":"Library Reference","title":"GAIO.subdivide","text":"subdivide(B::BoxSet{<:Any,<:Any,<:TreePartition}) -> BoxSet\n\nBisect every box in boxset along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.unstable_set-Tuple{BoxMap, BoxSet}","page":"Library Reference","title":"GAIO.unstable_set","text":"unstable_set(F::BoxMap, B::BoxSet) -> BoxSet\n\nCompute the unstable set for a box set B. Generally, B should be  a small box surrounding a fixed point of F. The partition should  be fine enough, since no subdivision occurs in this algorithm. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArraysCore.StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}","page":"Library Reference","title":"GAIO.vertices","text":"vertices(box)\n\nReturn an iterator over the vertices of a box = Box(center, radius). \n\n\n\n\n\n","category":"method"},{"location":"cuda/#Using-the-GPU-(Nvidia)","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"","category":"section"},{"location":"cuda/#Tutorial","page":"Using the GPU (Nvidia)","title":"Tutorial","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"using GAIO","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"This example demonstrates how to get a vast speedup in your code using nvidia CUDA. The speedup factor increases exponentially with the complexity of the map.","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"Consider the point map f:","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"const σ, ρ, β = 10.0f0, 28.0f0, 0.4f0\nfunction v(x)\n    # Some map, here we use the Lorenz equation\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\n# set f as 100 steps of the classic 4th order RK method\nf(x) = rk4_flow_map(v, x, 0.002f0, 100)","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"tip: Single vs Double Precision Arithmetic\nFor best results, ensure that your functions only use 32-bit operations, as GPUs are not efficient with 64-bit.GAIO can convert your BoxPartition to 32-bit automatically when you use GPU acceleration, but preferred are still explicit 32-bit literals likecenter, radius = (0f0,0f0,25f0), (30f0,30f0,30f0)instead of center, radius = (0,0,25), (30,30,30). ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"danger: Using TreePartition\nTreePartition with GPU acceleratioin is not yet supported, since linear indexing of the tree structure is not yet implemented. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"All we need to do is pass :gpu as the final argument to one of the box map constructors, eg. BoxMap, PointDiscretizedMap, AdaptiveBoxMap. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"center, radius = (0f0,0f0,25f0), (30f0,30f0,30f0)\nP = BoxPartition(Box(center, radius), (128,128,128))\nF = BoxMap(f, P, :gpu)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\n@time W = unstable_set(F, P[x])","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"Using CUDA, one can achieve a more than 100-fold increase in performance. However, the performance increase is dependent on the complexity of the map f. For \"simple\" maps (eg. f from above with 20 steps), the GPU accelerated version will actually perform worse because computation time is dominated by the time required to transfer data across the (comparatively slow) PCIe bus. The GPU accelerated version only beats the CPU accelerated version if f is set to use more than 40 steps. Hence it is highly recommended to use the GPU if the map f is not dominated by memory transfer speed, but not recommended otherwise. For more detail, see [1]. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"(Image: performance metrics)","category":"page"},{"location":"cuda/#I-get-InvalidIRError-due-to-unsupported-dynamic-function-invocation","page":"Using the GPU (Nvidia)","title":"I get InvalidIRError due to unsupported dynamic function invocation","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"CUDA.jl generally give somewhat cryptic error messages. An unsupported dynamic function invocation can be caused by a simple error in the code. Hence, first try algorithms with f WITHOUT using the GPU, and ensure that no errors occur. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"If you still recieve dynamic function invocations, there likely is an operation somewhere in f which is not supported in CUDA.jl. A deliberately unsupported function can be for example matrix factorization, matrix-matrix multiplication, etc. because this is typically a performance trap if done on a single GPU thread. One option for linear algebra based functions which cause unsupported dynamic function invocations is to use StaticArrays. StaticArrays implements specialized methods for many low-dimensional linear algebra routines, allowing one to escape the standard methods which may cause unsupported dynamic function invocations. However, this is not a solution for all such problems, so a read through the CUDA.jl documentation, opening an issue on the GAIO.jl repo, or posting a question on the GPU category of julia Discourse for help may be necessary. ","category":"page"},{"location":"cuda/#References","page":"Using the GPU (Nvidia)","title":"References","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. ","category":"page"},{"location":"simd/#Using-the-CPU","page":"Using the CPU","title":"Using the CPU","text":"","category":"section"},{"location":"simd/#Tutorial","page":"Using the CPU","title":"Tutorial","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"This example demonstrates how to get a ~2x speedup in your code using your CPU's SIMD capabilities. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Consider the point map f:","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"using GAIO\n\nconst σ, ρ, β = 10.0, 28.0, 0.4\nfunction v(x)\n    # Some map, here we use the Lorenz equation\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\n# set f as 20 steps of the classic 4th order RK method\nf(x) = rk4_flow_map(v, x, 0.01, 20)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Internally, GAIO calls this function on many test points within the various boxes. This means many function calls have to be made. Notably, all of these function calls are independent of one another, meaning that they can be performed in parallel. If your function only uses \"basic\" instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple funnction calls can be made at the same time, increasing performance. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"tip: Which instructions are supported?\nGAIO.jl uses SIMD.jl to explicitly vectorize operations. To see precisely which instructions are supported, refer to the documentation for SIMD.jl. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"All we need to do is pass :cpu as the final argument to one of the box map constructors, eg. BoxMap, PointDiscretizedMap, AdaptiveBoxMap. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"center, radius = (0,0,25), (30,30,30)\nP = BoxPartition(Box(center, radius), (128,128,128))\nF = BoxMap(f, P, :cpu)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\n@time W = unstable_set(F, P[x])","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Using SIMD vectorization, one can roughly double the effective floating point operations per second. For more detail, see [1]. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"(Image: performance metrics)","category":"page"},{"location":"simd/#I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})","page":"Using the CPU","title":"I get MethodError: No method matching f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"If your code returns a MethodError with reference to SIMD.Vec somewhere, this most likely means that your pointmap f uses operations not explicitly supported by SIMD.jl. In this case, one you may need to rewrite sections of f to use only supported operations. For example, consider a \"scaled\" Lorenz flow map ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"function v(x_in)\n    \n    x = x_in ./ sqrt(norm(x_in))\n\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\nf(x) = rk4_flow_map(v, x)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"This code will return a MethodError due to LinearAlgebra.norm. For the L^2 norm, this can be manually rewritten as follows: ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"function v(x_in)\n    \n    sqnorm = sum(y -> y*y, x_in)\n    sqnorm = sqrt(sqrt(sqnorm))\n\n    x = (\n        x_in[1] / sqnorm,\n        x_in[2] / sqnorm,\n        x_in[3] / sqnorm\n    )\n\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\nf(x) = rk4_flow_map(v, x)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Generally, most \"simple\" functions can be rewritten (if needed) to support SIMD.jl. However, more complicated functions can make rewriting unnecessarily difficult. ","category":"page"},{"location":"simd/#References","page":"Using the CPU","title":"References","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. ","category":"page"},{"location":"algorithms/#Algorithms-and-Mathematical-Background","page":"Algorithms","title":"Algorithms and Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"note: Note\nIn the following, let Q subset mathbbR^d be compact. Further, f  mathbbR^d to mathbbR^d will always refer to the map describing the dynamics of a system, while F will be the corresponding BoxMap.","category":"page"},{"location":"algorithms/#Mapping-Boxes","page":"Algorithms","title":"Mapping Boxes","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The following algorithms all require a method to approximate the set-wise image f(b) of a box b. To do this, GAIO.jl splits the domain Q into a partition P of boxes, and uses test points within b. When a SampledBoxMap is initialized, we require a function to calculate test points that are mapped by f. This function is stored in the field F.domain_points. These test points are then mapped forward by f, and the boxes which are hit become the image set. More precisely, mapping a box set is done in two main steps within GAIO.jl: ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Test points within the box are generated (or retrieved) using F.domain_points(b.center, b.radius). These test points are mapped forward by the given function f.\nFor each mapped test point fp, an optional set of ”perturbations” are generated using F.image_points(fp, b.radius). For each of the perturbed points, the index of the box within the partition containing this point is calculated. This index gets added to the image set.","category":"page"},{"location":"algorithms/#Implementation","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"# wee need a small helper function because of \n# how julia dispatches on `union!`\n⊔(set1::AbstractSet, set2::AbstractSet) = union!(set1, set2)\n⊔(set1::AbstractSet, object) = union!(set1, (object,))\n\nfunction map_boxes(F::BoxMap, source::BoxSet{B,Q,S}) where {B,Q,S}\n    P = source.partition\n    @floop for box in source\n        c, r = box.center, box.radius\n        for p in F.domain_points(c, r)\n            fp = F.map(p)\n            hitbox = point_to_box(P, fp)\n            isnothing(hitbox) && continue\n            r = hitbox.radius\n            for ip in F.image_points(fp, r)\n                hit = point_to_key(P, ip)\n                isnothing(hit) && continue\n                @reduce(image = S() ⊔ hit)\n            end\n        end\n    end\n    return BoxSet(P, image)\nend ","category":"page"},{"location":"algorithms/#Relative-Global-Attractor","page":"Algorithms","title":"Relative Global Attractor","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-2","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The set ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"A_Q = bigcap_k geq 0 f^k(Q)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"is called the global attractor relative to Q. The relative global attractor can be seen as the set which is eventually approached by every orbit originating in Q. In particular, A_Q contains each invariant set in Q and therefore all the potentially interesting dynamics.  The idea of the algorithm is to cover the relative global attractor with boxes and recursively tighten the covering by refining appropriately selected boxes.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Mathematically, the algorithm to compute the global attractor relative to Q takes two input arguments: a compact set Q as well as a map f, which describes the dynamics. Now in each iteration, two steps happen:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: All those boxes b in the new box set B whose image does not intersect the domain, ie f(b) cap left( bigcup_b in B b right) neq emptyset, get discarded. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If we repeatedly refine the box set B through k subdivision steps, then as k to infty the collection of boxes B converges to the relative global attractor A_Q in the Hausdorff metric.","category":"page"},{"location":"algorithms/#Implementation-2","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function relative_attractor(F::BoxMap, B::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    for k = 1:steps\n        B = subdivide(B, (k % N) + 1)\n        B = B ∩ F(B)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The third input parameter steps describes the level of approximation. Since in each step of the algorithm the initial domain is divided in half, the final partition after steps many steps will contain n = 2^textdepth boxes, i.e. every box in the final covering is frac1n times the size of the initial box.  For this algorithm the box set should be the full partition of the set Q. ","category":"page"},{"location":"algorithms/#Unstable-Set","page":"Algorithms","title":"Unstable Set","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In the following we are presenting the algorithm to cover invariant manifolds within some domain Q, which has to contain a fixed point.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"note: Note\nFor simplicity, we will explain the algorithm for the case of the unstable manifold. However one can compute the stable manifold as well by considering the boxmap describing the inverse map f^-1 as input argument for the algorithm.","category":"page"},{"location":"algorithms/#Mathematical-Background-3","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The unstable manifold is defined as","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"W^U(x_0) = x lim_k to - infty f^k(x) = x_0 ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where x_0 is a fixed point of f.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The idea behind the algorithm to compute the unstable manifold can be explained in two steps. Before starting we need to identify a hyperbolic fixed point and the region Q, which we are going to compute the manifold in. The region Q needs to be already partitioned into small boxes.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"initialization step Since a fixed point is always part of the unstable manifold, we need to identify a small region/box containing this fixed point. This box may be known a-priori, or one can use the relative_attractor around a region where one suspects a fixed point to exist. \ncontinuation step The small box containing the fixed point is then mapped forward by F and the boxes that are hit under the image are added to the box collection. Then those newly included boxes are mapped forward and the procedure is repeated until no new boxes are added. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"warning: Note on Convergence\nOne might not be able to compute the parts of the unstable manifold whose preimage lies outside the domain Q. Thus, it is important to choose Q large enough.","category":"page"},{"location":"algorithms/#Implementation-3","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function unstable_set(F::BoxMap, B::BoxSet)\n    B₀ = B\n    B₁ = B\n    while !isempty(B₁)\n        B₁ = F(B₁)\n        setdiff!(B₁, B₀)\n        union!(B₀, B₁)\n    end\n    return B₀\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The input argument B includes two things:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The domain Q we are going to compute the unstable manifold in (Q can be implemented as a large Box) and the underlying partition of the domain. Unlike in the previous algorithm, the domain will not be subdivided along the algorithms course, but we need to pass a partition which is already subdivided to the depth d (and therefore the level of accuracy) we want our final boxcovering to have. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Note: This algorithm works with two mutable sets of boxes: B, which collects the boxes we aquire in each iteration and will eventually cover part of the unstable manifold, and B_new, which will be overwritten in each iteration and contains only the boxes which will be newly added to our collection.","category":"page"},{"location":"algorithms/#Chain-Recurrent-Set","page":"Algorithms","title":"Chain Recurrent Set","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-4","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The chain recurrent set over Q R_Q is defined as the set of all x_0 in Q such that for every epsilon  0 there exists a set ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"left x_0 x_1 x_2 ldots x_n-1 right subset Q quad textwith quad  f(x_i  textmod  n) - x_i+1  textmod  n   epsilon  textfor all  i","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The chain recurrent set describes \"arbitrarily small perturbations\" of periodic orbits. This definition is useful since our box coverings our finite and hence inherently slightly uncertain. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The idea for the algorithm is to construct a directed graph G whose vertices are the box set B, and for which edges are drawn from B_1 to B_2 if f(B_1) cap B_2 neq emptyset. We can now ask for a subset of the vertices, for which each vertex is part of a directed cycle. This set is equivalent to the strongly connected subset of G. We therefore perform two steps: ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"subdivision step The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \ngraph construction step Generate the graph G. This is done by generating the transition matrix over B (see the next algorithm) and noting the nonzero elements. This is the (transposed) adjacency matrix for the graph G. \nselection step Find the strongly connected subset of G. Discard all vertices (boxes) which are not part of a strongly connected component. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If we repeadetly refine the strongly connected box set through k subdivision steps, then the algorithm converges to the chain recurrent set as k to infty in the Hausdorff metric. ","category":"page"},{"location":"algorithms/#Implementation-4","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function chain_recurrent_set(F::BoxMap, B::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)\n        P = TransferOperator(F, B)\n        G = Graph(P)\n        B = strongly_connected_components(G)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/#Transfer-Operator","page":"Algorithms","title":"Transfer Operator","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-5","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The transition matrix is the discretization of the transfer operator P w.r.t. f. Formally, the transfer operator w.r.t. f is defined for measurable functions g implicitly through the integral equation","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"int_A Pg (x)  dmu (x) = int_f^-1(A) g(x)  dmu (x) quad textfor any   A   textmeasurable","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"We will use a Galerkin approximation for P which maintains the eigenvalues and cyclic behavior of P. To do this, we project to a subspace chi_B generated by the basis left chi_b vert b in B right  of indicator functions on the boxes of our box set. Further, we enumerate the box set B = {b_1, b_2, ..., b_n} with integer indices and define the transition matrix ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"    (P^n)_ij = fracmathcalLleft(b_j cap f^-1(b_i)right)mathcalL(b_j) quad i j = 1 ldots n","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where mathcalL is the lebesque measure. Finally, we define the approximate transfer operator Q_n P  chi_B to chi_B as the linear extension of ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"    (Q_n P) chi_b_i = sum_j = 1^n P_ij^n chi_b_j quad i = 1 ldots n","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The operator Q_n P can be created in GAIO.jl by calling ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"T = TransferOperator(F, B)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where F is a BoxMap and B is a box set. T acts as a matrix in every way, but the explicit transition matrix P^n_ij can be generated by calling ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"M = sparse(T)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"To realize this approximation, we need to calculate P^n_ij. For this there are two techniques discussed in [1]. The simpler of the two techniques is a Monte-Carlo approach. Namely, we choose a fixed number r of test points in one of the boxes b_j, and set P^n_ij as the fraction of test points which land in b_i. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"It is important to note that TranferOperator is only supported over the box set B, but if one lets a TranferOperator act on a BoxFun (see general), then the support B is extended \"on the fly\" to include the support of the BoxFun.","category":"page"},{"location":"algorithms/#Implementation-5","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"# helper function so we aren't doing type piracy on `mergewith!`\n⊔(d::AbstractDict...) = mergewith!(+, d...)\n\nfunction construct_transfers(\n        g::BoxMap, boxset::BoxSet{R,Q,S}\n    ) where {N,T,R<:Box{N,T},Q<:BoxPartition,S<:OrderedSet}\n\n    P = boxset.partition\n    D = Dict{Tuple{keytype(Q),keytype(Q)},T}    # \"dict-of-keys\" sparse matrix\n    @floop for key in boxset.set\n        box = key_to_box(P, key)\n        c, r = box.center, box.radius\n        domain_points = g.domain_points(c, r)\n        inv_n = 1. / length(domain_points)\n        for p in domain_points\n            c = g.map(p)\n            hitbox = point_to_box(P, c)\n            isnothing(hitbox) && continue\n            r = hitbox.radius\n            for ip in g.image_points(c, r)\n                hit = point_to_key(P, ip)\n                isnothing(hit) && continue\n                @reduce( mat = D() ⊔ D((hit,key) => inv_n) )\n\n                # if `boxset` is not invariant, then the image of some \n                # boxes will lie outside of `boxset`. These \"variant\" \n                # image boxes need to be recorded.\n                hit in boxset.set || @reduce( variant_keys = S() ⊔ hit )\n            end\n        end\n    end\n    return mat, variant_keys\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"A note on the enumeration of the box set:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The astute reader may have taken notice of the line \"enumerate the box set B = {b_1, b_2, ..., b_n}\". The base Set data structure does not guarantee a deterministic ordering, so we cannot just use the box set without any effort. Instead we use OrderedSet from OrderedCollections.jl. Internally an OrderedSet is just a regular array with a hash table built on top. In particular, the array is guaranteed to maintain the order of insertion. To access this internal array of partition-keys, one can call boxset.set.dict.keys. Using this knowledge we can convert between partition-keys and the index in the enumeration B = {b_1, b_2, ..., b_n} using the internal GAIO functions GAIO.getkeyindex(boxset, partition_key), GAIO.getindex_fromkeys(boxset, enumeration_index). ","category":"page"},{"location":"algorithms/#Root-Covering","page":"Algorithms","title":"Root Covering","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-6","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Nonlinear optimization theory offers a multitude of algorithms to iteratively approximate roots of functions h  mathbbR^d to mathbbR^d, that is, algorithms f  mathbbR^d to mathbbR^d such that (under some conditions) f^k (x) to x_0 as k to infty with h(x_0) = mathbf0. We can consider these algorithms from the point of view of dynamics, and reframe the problem of finding a root of h to finding a fixed point of f. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Specifically, we will consider f to be a globalized Newton algorithm. One step of the (local) Newton algorithm follows the specification: solve the linear equation ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Dh (x) d = - h(x)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"and set ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f(x) = x + d ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where Dh (x) is the Jacobi matrix of h at x. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The local Newton algorithm is not guaranteed to converge to a global solution to h(x) = 0. To rectify this, the step size  d  and direction d   d  need to be modified. There are multiple heuristics to do this, and GAIO.jl uses the \"Armijo rule\": fix some sigma  1 and find the largest alpha leq 1 such that ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"h(x + alpha d) - h(x) leq alpha sigma  Dh (x)^T d","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"This is done by initializing alpha = 1 and testing the above condition. If it is not satisfied, scale alpha by some constant rho, ie set alpha = rho cdot alpha, and test the condition again. GAIO.jl uses sigma = 10^-4 and rho = 4  5. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Using this iterative solver, one can follow a technique very similar to the algorithm for the realtive attractor. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: The box set B is mapped forward using one step of the adaptive newton algorithm. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If we repeadetly refine the box set B through k subdivision steps, then as k to infty the collection of boxes converges to the set of roots of h in the Hausdorff metric. ","category":"page"},{"location":"algorithms/#Implementation-6","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function cover_roots(h::Function, Dh::Function, B::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    domain = B.partition.domain\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)\n        f = x -> adaptive_newton_step(h, Dh, x, k)\n        F = BoxMap(f, domain)\n        B = F(B)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The arguments needed are the map h, some approximation of the Jacobian Dh, and a box set B containing some root of h. ","category":"page"},{"location":"algorithms/#Finite-Time-Lyapunov-Exponents","page":"Algorithms","title":"Finite Time Lyapunov Exponents","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-7","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"We change focus now to a continuous dynamical system, e.g. an ODE dotu = g(t u) with solution Phi^tt_0 (x). Since Phi^tt_0 (x) is continuously dependent on the initial condition x, there exists an tildex near x with sup_t in t_0  t_0 + T  Phi^tt_0 (tildex) - Phi^tt_0 (x)   epsilon for any fixed epsilon  0 and T small enough. We wish to characterize this expansion term. We write y = x + delta x_0 where delta x_0 in mathbbR^d is infinitesimal. Then if g is mathcalC^1 w.r.t. x,","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"delta x (t_0 + T) = Phi^t_0 + T t_0 (y) - Phi^t_0 + T t_0 (x)\n= D_x Phi^t_0 + T t_0 (x) cdot delta x_0 + mathcalO( delta x_0 ^2)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Hence we can write ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":" delta x (t_0 + T) _2 =  D_x Phi^t_0 + T t_0 (x) cdot delta x_0 _2 leq  D_x Phi^t_0 + T t_0 (x) _2 cdot  delta x_0 _2","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"or equivalently","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"frac  delta x (t_0 + T) _2   delta x_0 _2  leq  D_x Phi^t_0 + T t_0 (x) _2","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where equality holds if delta x_0 is the eigenvector corresponding to the largest eigenvalue of ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Delta = left( D_x Phi^t_0 + T t_0 (x) right)^T left( D_x Phi^t_0 + T t_0 (x) right)  ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Hence if we define ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"sigma^t_0 + T t_0 (x) = frac1T ln left( sqrtlambda_textmax (Delta) right) = frac1T ln left( sup_delta x_0 frac  delta x (t_0 + T) _2   delta x_0 _2  right)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"then ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":" delta x (t_0 + T) _2 leq e^T cdot sigma^t_0 + T t_0 (x) cdot  delta x_0 _2  ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"From this we see why sigma^t_0 + T t_0 (x) is called the maximal finite-time lyapunov exponent (FTLE). ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The definition of sigma^t_0 + T t_0 (x) leads to a natural ansatz for approximating the FTLE: compute frac1T ln left( sup_delta x_0 frac  delta x (t_0 + T) _2   delta x_0 _2  right) for each of a set of test points  delta x_0  of fixed order epsilon  0 and set sigma^t_0 + T t_0 (x) to be the maximum over this set of test points. ","category":"page"},{"location":"algorithms/#Implementation-7","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"We assume all boxes in the box set B have radii of order epsilon, that is, all test points of order epsilon. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function finite_time_lyapunov_exponents(F::BoxMap, B::BoxSet{R,Q,S}; T) where {N,V,R<:Box{N,V},Q,S}\n    P, D = B.partition, Dict{keytype(Q),Float}\n    @floop for key in B.set\n        box = key_to_box(P, key)\n        c, r = box.center, box.radius\n        fc = F.map(box.center)\n        ftle = -Inf\n        for p in F.domain_points(c, r)\n            ϵ = norm(c .- p)\n            fp = F.map(p)\n            ftle_pot = log( norm(fc .- fp) / ϵ ) / abs(T)\n            ftle = max(ftle, ftle_pot)\n        end\n        @reduce( vals = D() ⊔ (key => ftle) )\n    end\n    return BoxFun(B.partition, vals)\nend","category":"page"},{"location":"algorithms/#References","page":"Algorithms","title":"References","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"[1] Michael Dellnitz, Oliver Junge, and Gary Froyland. “The Algorithms Behind GAIO - Set Oriented Numerical Methods for Dynamical Systems”. In: Ergodic Theory,Analysis, and Efficient Simulations of Dynamical Systems. Ed. by Bernold Fiedler.Springer Berlin, 2001, pp. 145–174. doi: https://doi.org/10.1007/3-540-35593-6. ","category":"page"},{"location":"data_structures/#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Pages = [\"data_structures.md\"]","category":"page"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Box\nvolume(box::Box)","category":"page"},{"location":"data_structures/#GAIO.Box","page":"Data Structures","title":"GAIO.Box","text":"Box{N,T}(center, radius)\nBox(center, radius)\n\nA generalized box in dimension N with element type T.  Mathematically, this is a set\n\ncenter_1 - radius_1 center_1 + radius_1)  times  ldots  times  center_N - radius_N center_N + radius_N)\n\nFields:\n\ncenter:   vector where the box's center is located\nradius:   vector of radii, length of the box in each dimension\n\nMethods implemented:\n\n:(==), in #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.volume-Tuple{Box}","page":"Data Structures","title":"GAIO.volume","text":"volume(box::Box)\n\nCompute the volume of a box. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxPartition\npoint_to_key\nbounded_point_to_key\nkey_to_box\npoint_to_box\nsubdivide(P::BoxPartition{N,T,I}, dim) where {N,T,I}","category":"page"},{"location":"data_structures/#GAIO.BoxPartition","page":"Data Structures","title":"GAIO.BoxPartition","text":"BoxPartition(domain::Box{N}, dims::NTuple{N,<:Integer} = ntuple(_->1, N))\n\nData structure to partition a domain into a  dims[1] x dims[2] x ... dims[N] equidistant box grid. \n\nFields:\n\ndomain:         box defining the entire domain\nleft:           leftmost / bottom edge of the domain\nscale:          1 / diameter of each box in the new partition (componentwise)\ndims:           tuple, number of boxes in each dimension\n\nMethods implemented:\n\n:(==), ndims, size, length, keys, keytype #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.point_to_key","page":"Data Structures","title":"GAIO.point_to_key","text":"point_to_key(P::BoxPartition, point)\n\nFind the index for the box within a BoxPartition  contatining a point, or nothing if the point does  not lie in the domain. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.bounded_point_to_key","page":"Data Structures","title":"GAIO.bounded_point_to_key","text":"bounded_point_to_key(P::BoxPartition, point)\n\nFind the cartesian index of the nearest box within a  BoxPartition to a point. Conicides with point_to_key  if the point lies in the partition. Default behavior  is to set NaN = Inf if NaNs are present in point. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.key_to_box","page":"Data Structures","title":"GAIO.key_to_box","text":"key_to_box(P::BoxPartition, key)\n\nReturn the box associated with the index  within a BoxPartition. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.point_to_box","page":"Data Structures","title":"GAIO.point_to_box","text":"point_to_box(P::AbstractBoxPartition, point)\n\nFind the box within a BoxPartition containing a point. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Data Structures","title":"GAIO.subdivide","text":"subdivide(P::BoxPartition, dim) -> BoxPartition\nsubdivide(B::BoxSet, dim) -> BoxSet\n\nBisect every box in the BoxPartition or BoxSet  along the axis dim, giving rise to a new partition  of the domain, with double the amount of boxes. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"TreePartition\nsubdivide!","category":"page"},{"location":"data_structures/#GAIO.TreePartition","page":"Data Structures","title":"GAIO.TreePartition","text":"TreePartition(domain::Box)\n\nBinary tree structure to partition domain into (variably sized) boxes. \n\nFields:\n\ndomain: Box denoting the full domain.\nnodes:  vector of Nodes. Each node holds two indices pointing to            other nodes in the vector, or 0 if the node is a leaf. \n\nMethods implemented:\n\ncopy, keytype, keys, subdivide #, etc...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.subdivide!","page":"Data Structures","title":"GAIO.subdivide!","text":"subdivide!(tree::TreePartition, key::keytype(tree)) -> TreePartition\nsubdivide!(tree::TreePartition, depth::Integer) -> TreePartition\n\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, key) -> BoxSet\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, depth) -> BoxSet\n\nSubdivide a TreePartition at key. Dimension along which  the node is subdivided depends on the depth of the node. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxMap\nMonteCarloBoxMap\nGridBoxMap\nPointDiscretizedBoxMap\nAdaptiveBoxMap\nSampledBoxMap\nIntervalBoxMap\nCPUSampledBoxMap\nGPUSampledBoxMap","category":"page"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxSet","category":"page"},{"location":"data_structures/#GAIO.BoxSet","page":"Data Structures","title":"GAIO.BoxSet","text":"BoxSet(partition, indices::AbstractSet)\n\nInternal data structure to hold boxes within a partition. \n\nConstructors (all constructors work with box sets as well):\n\nset of all boxes in partition / box set P:\n\nB = cover(P, :)    \n\ncover the point x, or points x = [x_1, x_2, x_3] # etc ... using boxes from P\n\nB = cover(P, x)\n\na covering of S using boxes from P\n\nS = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... \nB = cover(P, S)\n\nFields:\n\npartition:  the partition that the set is defined over\nset:        set of partition-keys corresponding to the boxes in the set\n\nMost set operations such as \n\nunion, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...\n\nare supported. \n\n\n\n\n\n","category":"type"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"TransferOperator","category":"page"},{"location":"data_structures/#GAIO.TransferOperator","page":"Data Structures","title":"GAIO.TransferOperator","text":"TransferOperator(map::BoxMap, domain::BoxSet)\nTransferOperator(map::BoxMap, domain::BoxSet, codomain::BoxSet)\n\nDiscretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with indices referring to  two BoxSets: domain and codomain. \n\nThere exists two constructors:\n\nonly provide a boxmap and a domain. In this case,  the codomain is generated as the image of domain under  the boxmap. \njulia> P = BoxPartition( Box((0,0), (1,0)), (10,10) )\n  10 x 10 - element BoxPartition\n\njulia> domain = BoxSet( P, Set((1,2), (2,3), (3,4)) )\n  3 - element Boxset over 10 x 10 - element BoxPartition\n\njulia> T = TransferOperator(boxmap, domain)\n  TransferOperator over [...]\nprovide domain and codomain. In this case,  the size of the transition matrix is given. \njulia> codomain = domain\n  3 - element Boxset over 10 x 10 - element BoxPartition\n\njulia> T = TransferOperator(boxmap, domain, codomain)\n  TransferOperator over [...]\n\nFields:\n\nmat:            SparseMatrixCSC containing transfer weights. The index                    T.mat[i,j] represents the transfer weight FROM the j'th                   box in codomain TO the i'th box in domain. \nboxmap:         SampledBoxMap map which dictates the transfer weights. \ndomain:         BoxSet which contains keys for the already calculated transfers.                    Effectively, these are column pointers, i.e. the                    jth column of T.mat contains transfer weights FROM                    box Bj, where Bj is the jth box of domain. \ncodomain:       BoxSet which contains keys for the already calculated transfers.                    Effectively, these are row pointers, i.e. the                    ith row of T.mat contains transfer weights TO                    box Bi, where Bi is the ith box of codomain. \n\n        domain -->\ncodomain  .   .   .   .   .\n    |     .   .   .   .   .\n    |     .   .   .   .   .\n    v     .   .  mat  .   .\n          .   .   .   .   .\n          .   .   .   .   .\n          .   .   .   .   .\n          .   .   .   .   .\n\nIt is important to note that TranferOperator is only supported over the  box set domain, but if one lets a TranferOperator act on a BoxFun, e.g.  by multiplication, then the domain is extended \"on the fly\" to  include the support of the BoxFun.\n\nMethods Implemented: \n\n:(==), axes, size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...\n\nImplementation detail:\n\nThe reader may have noticed that the matrix representation  depends on the order of boxes in support. For this reason  an OrderedSet is used. BoxSets using regular Sets  will be copied and converted to OrderedSets. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxFun\nBase.sum(f, boxfun::BoxFun)\n∘(f, boxfun::BoxFun)","category":"page"},{"location":"data_structures/#GAIO.BoxFun","page":"Data Structures","title":"GAIO.BoxFun","text":"BoxFun(partition, vals)\n\nDiscretization of a measure over the domain partition.domain, as a piecewise constant function over the boxes of partition. \n\nImplemented as a sparse vector over the indices of partition. \n\nFields:\n\npartition: An AbstractBoxPartition whose indices are used \n\nfor vals\n\nvals: A dictionary whose keys are the box indices from \n\npartition, and whose values represent the values of the function. \n\nMethods implemented:\n\nlength, sum, iterate, values, isapprox, ∘, LinearAlgebra.norm, LinearAlgebra.normalize!\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#Base.sum-Tuple{Any, BoxFun}","page":"Data Structures","title":"Base.sum","text":"sum(f, μ::BoxFun)\nsum(f, μ::BoxFun, B::BoxSet)\nμ(B) = sum(x->1, μ, B)\n\nIntegrate a function f using μ as a density, that is, if boxfun is the discretization of a measure mu over the domain  Q, then approximate the value of \n\nint_Q f  dmu \n\nIf a BoxSet B is passed as the third argument, then the  integration is restricted to the boxes in B\n\nint_Q cap bigcup_b in B b f  dmu \n\nThe notation μ(B) is offered to compute  mu (bigcup_b in B b). \n\n\n\n\n\n","category":"method"},{"location":"data_structures/#Base.:∘-Tuple{Any, BoxFun}","page":"Data Structures","title":"Base.:∘","text":"∘(f, boxfun::BoxFun) -> BoxFun\n∘(boxfun::BoxFun, F::BoxMap) -> BoxFun\n\nPostcompose the function f with the boxfun, or precompose a BoxMap F with the boxfun  (by applying the Koopman operator). Note that  the support of BoxFun must be forward-invariant under F. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxGraph","category":"page"},{"location":"data_structures/#GAIO.BoxGraph","page":"Data Structures","title":"GAIO.BoxGraph","text":"Graph(gstar::TransferOperator) -> BoxGraph\nGraph(g::BoxMap, boxset::BoxSet) = Graph(TransferOperator(g, boxset, boxset))\n\nDirected Graph representation of a TransferOperator. The  boxes in a BoxSet are enumerated as in TransferOperator.  This means if the domain, codomain are taken from a  TranferOperator, then the graph vertices are numbered  1 .. length(domain ∪ codomain). \n\nA directed edge exists from the i'th box b_i to the j'th  box b_j if the BoxMap g has b_j ∩ g⁻¹(b_i) ≠ ∅.  Equivalently, \n\nhas_edge(g::BoxGraph, i, j) = !iszero( Matrix(g.gstar)[j,i] )\n\nGraphs.jl operations like \n\nvertices, edges, weights, inneighbors, outneighbors, # etc...\n\nare supported. Algorithms in Graphs.jl  should work \"out of the box\", but will return whatever Graphs.jl  returns by default. To convert a (integer) vertex index from the  graph into a box index from the partition, one can call \n\nBoxSet(boxgraph, graph_index_or_indices)\n\nIf you would like to see specific behavior  implemented, please open an issue! \n\nImplementation details, not important for use:\n\nWe want to turn a matrix representation \n\n        domain -->\ncodomain  .   .   .   .   .\n    |     .   .   .   .   .\n    |     .   .   .   .   .\n    v     .   .  mat  .   .\n          .   .   .   .   .\n          .   .   .   .   .\n\ninto a graph representation \n\n  domain ∪ codomain\n  .---------.   .\n / \\       /   /\n.   .-----.---.\n\n!! efficiently !!\n\nJulia's Graphs package only allows integer-indexed vertices so we need to enumerate domain ∪ codomain.  To do this, we enumerate the domain, then skip  the boxes in the codomain which are already in the  domain, then continue enumerating the rest of the  codomain. \n\nWe therefore permute the row indices of the weight  matrix so that the skipped elements of the codomain come first. \n\n\n\n\n\n","category":"type"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Consider the Hénon map [1]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"f(xy) = (1-ax^2+y bx) quad ab in mathbbR","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Iterating some random intial point exhibits a strange attractor (a=1.4 and b=0.3)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"(Image: Hénon attractor)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Since this map is chaotic [2,3], it has sensitive dependence on initial conditions.  That is, small perturbations (as unavoidable on a computer) during the computation grow exponentially during the iteration.  Thus, apart from a few iterates at the beginning, the computed trajectory does not (necessarily) follow a true trajectory. One might therefore question how reliable this figure is.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Instead of trying to approximate the attractor by a long forward trajectory, we will capture it by computing a collection of boxes (i.e. cubes) covering the attractor. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Start by loading the GAIO package","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using GAIO","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A Box is descibed by its center and its radius","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"box_center, box_radius = (0,0), (3,3)\nQ = Box(box_center, box_radius)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This box will serve as the domain for our computation.  The box covering which we will compute is a subset of a partition of Q into smaller boxes. The command","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"P = BoxPartition(Q, (4,4)) ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a partition of Q into a grid of 4 x 4 equally sized smaller boxes. From P, box sets can be constructed. For example, the command","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"B = P[:]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a BoxSet containing all boxes from the partition P (i.e. a set containing 16 boxes).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In order to deal with the Hénon map as a map on box sets, we have to turn it into a BoxMap on the given partition P","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x) \nF = BoxMap(f, P) ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We can now compute a covering of the attractor in Q, starting with the full box set B, by applying 15 steps of the subdivison algorithm described in [4]:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A = relative_attractor(F, B, steps = 15)  \nplot(A)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"(Image: box covering of the Hénon attractor)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In addition to covering the attractor, this box collection also covers an unstable fixed point near (-1,-0.3) and its unstabe manifold (cf. [4]).","category":"page"},{"location":"getting_started/#References","page":"Getting started","title":"References","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[1] Hénon, Michel. \"A two-dimensional mapping with a strange attractor\". Communications in Mathematical Physics 50.1 (1976): 69–77.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[2] Benedicks, Michael, and Lennart Carleson. \"The dynamics of the Hénon map.\" Annals of Mathematics 133.1 (1991): 73-169.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[3] Zgliczynski, Piotr. \"Computer assisted proof of chaos in the Rössler equations and in the Hénon map.\" Nonlinearity 10.1 (1997): 243. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[4] Dellnitz, Michael, and Andreas Hohmann. \"A subdivision algorithm for the computation of unstable manifolds and global attractors.\" Numerische Mathematik 75.3 (1997): 293-317.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#How-to-Use","page":"Examples","title":"How to Use","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To see examples of how to use GAIO.jl explore the examples folder. This contains a Project.toml file that can be used to download all the necessary dependencies for the examples. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To try the examples, one can choose between two options:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(recommended) simply download an example file and see what packages are used, add them in the package manager\nclone the GAIO.jl GitHub repository. Navigate to the repository folder /path/to/GAIO.jl/examples in the julia REPL using pwd and cd. Finally, call the following in the julia REPL","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"pkg> activate .\njulia> pwd()\n\"/path/to/GAIO.jl\"\n\njulia> cd(\"./examples\")\n\n(GAIO) pkg> activate .\n  Activating project at `/path/to/GAIO.jl/examples`\n\n(examples) pkg> dev ../\n   Resolving package versions...\n  No Changes to `/path/to/GAIO.jl/examples/Project.toml`\n  No Changes to `/path/to/GAIO.jl/examples/Manifest.toml`\n\n(examples) pkg> instantiate\n  69 dependencies successfully precompiled in 74 seconds","category":"page"},{"location":"examples/#Example-Files","page":"Examples","title":"Example Files","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Relative attractor of the Hénon map\nUnstable manifold of the Lorenz system\nChain recurrent of a knotted flow\nInvariant measure of the transfer operator for the logistic map\nInvariant measure of the transfer operator for the Hénon map over the relative attractor\nInvariant measure of the transfer operator for the Lorenz map over the unstable manifold\nAlmost invariant sets in Chua's circuit\nRoot covering of a cubic map\nDoubling performance using SIMD operations\nVastly improving performance using Nvidia CUDA","category":"page"},{"location":"general/#Usage","page":"General usage","title":"Usage","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The base of the numerical set oriented methods of this framework are BoxSet (the discretization of a set) and BoxMap (the discretization of a map), thus, in the following, we will have a closer look at the two and other useful things to know when using GAIO.jl. ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To create a Box given its center point c = (c_1, c_2, ..., c_d) as well as its \"radius\" in every axis direction r = (r_1, r_2, ..., c_d), simply type ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"using GAIO\n\nQ = Box(c, r)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This creates a set Q = c_1 - r_1 c_1 + r_1) times ldots times c_d - r_d c_d + r_d). Conversely, one can get back the vectors c and r by calling","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"c, r = Q","category":"page"},{"location":"general/#BoxPartition","page":"General usage","title":"BoxPartition","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"Most algorithms in GAIO.jl revolve around a partition of the domain Q into small boxes. To create an n_1 times ldots times n_d - element equidistant grid of boxes, we can pass the tuple n = (n_1 ldots n_d) into the function BoxPartition","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"P = BoxPartition(Q, n)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"BoxPartitions use a cartesian indexing structure to be memory-efficient. These indices are accessed and used through the API:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"key = point_to_key(P, x)    # x is some point in the domain Q\n\nbox = key_to_box(P, key)    # cover the point x with a box from P\n\nbox = point_to_box(P, x)    # performs both above functions","category":"page"},{"location":"general/#TreePartition","page":"General usage","title":"TreePartition","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"For partitions of Q into variably sized boxes, one can use TreePartition:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"P = TreePartition(Q)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"warning: Using `TreePartition`\nTreePartition is an area of active development, and an overhaul is potentially planned in the future. Please do not use TreePartition yet. ","category":"page"},{"location":"general/#BoxSet","page":"General usage","title":"BoxSet","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The core idea behind GAIO.jl is to approximate an subset of the domain via a collection of small boxes. To construct BoxSets, there are two main options: getting all boxes in the partition, or locating a box surrounding a point x in Q","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"B = P[:]    # set of all boxes in P\n\nB = P[x]    # one box surrounding the point x","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"One can also create a Boxset from an iterable of Boxes. This will cover every element of the iterable with boxes from P:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... \n\nB = P[S]","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"BoxSet is a highly memory-efficient way of storing boxes. However, should you want to access the boxes or their internal data, this can be done via iteration:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"for box in B\n    center, radius = box\n    # do something\nend\n\n# get an array of boxes\narr_of_boxes = collect(B)\n\n# get an array of box centers\narr_of_centers = collect(box.center for box in B)\n\n# get an array of box radii\narr_of_radii = collect(box.radius for box in B)\n\n# (memory-efficiently) create a matrix where each center is a column\nmat_of_centers = reinterpret(reshape, eltype(arr_of_centers[1]), arr_of_centers)","category":"page"},{"location":"general/#BoxMap","page":"General usage","title":"BoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"A BoxMap is a function which maps boxes to boxes. Given a pointmap f, initialize the corresponding BoxMap F by","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"F = BoxMap(f, P.domain)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This will generate a BoxMap which attempts to calculate setwise images of f. To specify the amount of test points used, use the no_of_points keyword argument:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"F = BoxMap(f, P.domain, no_of_points=300)","category":"page"},{"location":"general/#Using-BoxMap","page":"General usage","title":"Using BoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"Now, one can map a BoxSet via the BoxMap F by simply calling F as a function ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"C = F(B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"where the output C is also a BoxSet.","category":"page"},{"location":"general/#TransferOperator","page":"General usage","title":"TransferOperator","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The Perron-Frobenius operator (or transfer operator) [2] is discretized in GAIO.jl using the TransferOperator type. To initialize a TransferOperator that acts on a subdomain of Q, type","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"T = TransferOperator(F, B)   # T operates on the domain covered by the box set B","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To find an approximate invariant measure over B use the eigs function","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"λ, ev, num_converged_eigs = eigs(T)\n\nμ = ev[1]   # ev is an array of measures, grab the first one","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This can also be done with the adjoint Koopman operator T'. ","category":"page"},{"location":"general/#BoxFun","page":"General usage","title":"BoxFun","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The return type of eigs(T) is a stepwise constant function over the boxes in B, which is called a BoxFun. One can let T act on a BoxFun simply through multiplication","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"ν = T * μ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Of course, the same holds for the the Koopman operator as well. ","category":"page"},{"location":"general/#BoxGraph","page":"General usage","title":"BoxGraph","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"One could equivalently view the transfer operator as a weighted directed graph. That is, a transfer operator in GAIO.jl is the (transposed) weighted adjacency matrix for a graph. This graph can be constructed using","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"G = Graph(T)    # T is a transfer operator","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"The return type is a BoxGraph. Boxgraph is hooked into the Graphs.jl interface, which means all algorithms or etc. from Graphs.jl should work \"out of the box\". To construct a BoxSet from some index / indices of vertices in a BoxGraph, call","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"BoxSet(G, vertex_index_or_indices)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"See the docstring for BoxGraph for details on how to translate between GAIO.jl and Graphs.jl. ","category":"page"},{"location":"general/#Plotting","page":"General usage","title":"Plotting","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"GAIO.jl offers both Plots or Makie for plotting. To plot a BoxSet or a BoxFun, simply choose either Plots or a Makie backend, eg. GLMakie, and call plot on a BoxSet or BoxFun","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"using GLMakie: plot\n\nplot(B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Plotting works with all the functionality of either package. This means you can set box plots as subplots, add colorbars, etc., using the Plots or Makie interface. For an example, see examples/invariant_measure_2d.jl. ","category":"page"},{"location":"general/#References","page":"General usage","title":"References","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"[2] Andrzej Lasota and Michael C. Mackey. Chaos, Fractals, and Noise. Stochastic Aspects of Dynamics. Springer New York, NY, 1994. doi: https://doi.org/10.1007/978-1-4612-4286-4.","category":"page"},{"location":"boxmap/#BoxMap-types","page":"BoxMaps","title":"BoxMap types","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"There are multiple techniques one could use to discretize point maps into maps over boxes. In General Usage the discretization BoxMap was already briefly introduced. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"BoxMap","category":"page"},{"location":"boxmap/#GAIO.BoxMap","page":"BoxMaps","title":"GAIO.BoxMap","text":"BoxMap(map, domain; no_of_points=ntuple(_->4, N)) -> SampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a SampledBoxMap defined  on Boxes. \n\nBy default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated BoxMaps, uses a grid of test points by default. \n\n\n\n\n\n","category":"type"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"We now introduce a set of BoxMap subtypes for different discretization algorithms. The types fit into a heirarchy described in the diagram below. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"(Image: Type Hierarchy)","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"We will work from the \"bottom up\", starting with specific types that are of practical use, and then generalizing these approaches for the reader who wishes to know more. ","category":"page"},{"location":"boxmap/#MonteCarloBoxMap","page":"BoxMaps","title":"MonteCarloBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"The simplest technique for discretization is a Monte-Carlo approach: choose a random set of sample points within a box and record which boxes are hit by the point map. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"MonteCarloBoxMap","category":"page"},{"location":"boxmap/#GAIO.MonteCarloBoxMap","page":"BoxMaps","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses n_points  Monte-Carlo test points. \n\n\n\n\n\nBoxMap(:montecarlo, :simd, map, domain::Box{N}; n_points=16*N) -> SampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses n_points  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu's SIMD capacity. \n\n\n\n\n\nBoxMap(:montecarlo, :gpu, map, domain::Box{N}; n_points=16*N) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses n_points  Monte-Carlo test points. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"function"},{"location":"boxmap/#GridBoxMap","page":"BoxMaps","title":"GridBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"Another naive but still useful approach is to place the test points on an equidistant grid within a box. This approach removes an element of randomness from the Monte-Carlo approach. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"GridBoxMap","category":"page"},{"location":"boxmap/#GAIO.GridBoxMap","page":"BoxMaps","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\n\n\n\n\nBoxMap(:grid, :simd, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu's SIMD capacity. \n\n\n\n\n\nBoxMap(:grid, :gpu, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"function"},{"location":"boxmap/#AdaptiveBoxMap","page":"BoxMaps","title":"AdaptiveBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"The above approaches may not necessarily be effective for covering the setwise image of a box. For choosing test points more effectively, we can use some knowledge of the Lipschitz matrix for f in a box Box(c, r), that is, a matrix L in mathbbR^d times d such that ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":" f(y) - f(z)  leq L   y - z  quad textfor all  y z in textBox(c r)","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"where the operations  cdot  and leq are to be understood elementwise. The function AdaptiveBoxMap attempts to approximate L before choosing an adaptive grid of test points in each box, as described in [1]. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"AdaptiveBoxMap","category":"page"},{"location":"boxmap/#GAIO.AdaptiveBoxMap","page":"BoxMaps","title":"GAIO.AdaptiveBoxMap","text":"BoxMap(:adaptive, f, domain::Box) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses sample_adaptive to  generate test points as described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"function"},{"location":"boxmap/#IntervalBoxMap","page":"BoxMaps","title":"IntervalBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"All of the above techniques provide a fast, efficient way to cover setwise images of boxes, but are not necessarily guaranteed to provide an complete covering. To avoid this as well as other numerical inaccuracies inherent in floating point arithmetic, one can use interval arithmetic to guarantee a rigorous outer covering of box images. Interval arithmetic is a technique from validated numerics which performs calculations while simultaneously recording the error of such calculations. A more detailed discussion and julia-implementation of interval arithmetic can be found in IntervalArithmetic.jl. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"IntervalBoxMap","category":"page"},{"location":"boxmap/#GAIO.IntervalBoxMap","page":"BoxMaps","title":"GAIO.IntervalBoxMap","text":"BoxMap(:interval, map, domain::Box{N}; n_subintervals::NTuple{N} = ntuple(_->4, N)) -> IntervalBoxMap\nBoxMap(:interval, map, domain::Box{N}; n_subintervals::Function) -> IntervalBoxMap\n\nType representing a discretization of a map using  interval arithmetic to construct rigorous outer coverings  of map images. n_subintervals describes how many times  a given box will be subdivided before mapping.  n_subintervals is a Function which  has the signature n_subintervals(center, radius) and  returns a tuple. If a tuple is passed directly for  n_subintervals, then this is converted to a constant Function (_, _) -> n_subintervals\n\nFields:\n\nmap:              Map that defines the dynamical system.\ndomain:           Domain of the map, B.\nn_subintervals:   Function with the signature                      n_subintervals(center, radius) which                      returns a tuple describing how many                      times a box is subdivided in each                      dimension before mapping. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"boxmap/#CPUSampledBoxMap","page":"BoxMaps","title":"CPUSampledBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"Naturally, if an increase in accuracy is desired in a SampledBoxMap, a larger set of test points may be chosen. This leads to a dilemma: the more accurate we wish our approximation to be, the more we need to map very similar test points forward, causing a considerable slow down for complicated dynamical systems. However, the process of mapping each test point forward is completely independent on other test points. This means we do not need to perform each calculation sequentially; we can parallelize. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"If the point map only uses \"basic\" instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple funnction calls can be made at the same time, increasing performance. For more details, see the maximizing performance section. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"GridBoxMap(c::Val{:cpu}, map, domain::Box{N,T}; no_of_points) where {N,T}\nMonteCarloBoxMap(c::Val{:cpu}, map, domain::Box{N,T}; no_of_points) where {N,T}","category":"page"},{"location":"boxmap/#GPUSampledBoxmap","page":"BoxMaps","title":"GPUSampledBoxmap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"If an Nvidia gpu is available, the above technique can be improved dramatically. The gpu uses a \"massively parallel programming\" paradigm, which fits perfectly to the problem of mapping many sample points independently. For more information, see the maximizing performance section.","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"GridBoxMap(c::Val{:gpu}, map, domain::Box{N,T}; no_of_points) where {N,T}\nMonteCarloBoxMap(c::Val{:gpu}, map, domain::Box{N,T}; no_of_points) where {N,T}","category":"page"},{"location":"boxmap/#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}","page":"BoxMaps","title":"GAIO.GridBoxMap","text":"BoxMap(:grid, :gpu, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_->16, N)) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses a grid of test points.  The size of the grid is defined by n_points, which is  a tuple of length equal to the dimension of the domain. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"method"},{"location":"boxmap/#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}","page":"BoxMaps","title":"GAIO.MonteCarloBoxMap","text":"BoxMap(:montecarlo, :gpu, map, domain::Box{N}; n_points=16*N) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses n_points  Monte-Carlo test points. \n\nRequires a CUDA-capable gpu.\n\n\n\n\n\n","category":"method"},{"location":"boxmap/#PointDiscretizedBoxMap","page":"BoxMaps","title":"PointDiscretizedBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"A generalization of MonteCarloBoxMap and GridBoxMap can be defined as follows: ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"we provide a \"global\" set of test points within the unit cube -11^d. \nFor each box Box(c,r), we rescale the global test points to lie within the box by calculating c .+ r .* p for each global test point p. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"PointDiscretizedBoxMap","category":"page"},{"location":"boxmap/#GAIO.PointDiscretizedBoxMap","page":"BoxMaps","title":"GAIO.PointDiscretizedBoxMap","text":"BoxMap(:pointdiscretized, map, domain, points) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses the iterator points as test points.  points must be an array or iterator of test points within the unit cube  [-1,1]^N. \n\n\n\n\n\nBoxMap(:pointdiscretized, :simd, map, domain, points) -> CPUSampledBoxMap\n\nConstruct a CPUSampledBoxMap that uses the iterator  points as test points. points must have eltype  SVector{N, SIMD.Vec{S,T}} and be within the unit  cube [-1,1]^N. \n\n\n\n\n\nBoxMap(:pointdiscretized, :gpu, map, domain, points) -> GPUSampledBoxMap\n\nConstruct a GPUSampledBoxMap that uses the Vector points as test points.  points must be a VECTOR of test points within the unit cube  [-1,1]^N. \n\nRequires a CUDA-capable gpu. \n\n\n\n\n\n","category":"function"},{"location":"boxmap/#SampledBoxMap","page":"BoxMaps","title":"SampledBoxMap","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"We can even further generalize the concept of MonteCarloBoxMap, GridBoxMap, PointDiscretizedBoxMap as follows: we define two functions domain_points(c, r) and image_points(c, r) for any Box(c, r). ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"for each box Box(c, r) a set of test points within the box is initialized using domain_points(C, r) and mapped forward by the point map. \nFor each of the pointwise images fc, an optional set of \"perturbations\" can be applied. These perturbations are generated with image_points(fc, r). The boxes which are hit by these perturbations are recorded. ","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"SampledBoxMap\nCPUSampledBoxMap\nGPUSampledBoxMap","category":"page"},{"location":"boxmap/#GAIO.SampledBoxMap","page":"BoxMaps","title":"GAIO.SampledBoxMap","text":"BoxMap(:sampled, map, domain::Box, domain_points, image_points)\n\nType representing a discretization of a map using sample points. \n\nFields:\n\nmap:              map that defines the dynamical system.\ndomain:           domain of the map, B.\ndomain_points:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature domain_points(center, radius) and return                      an iterator of points within Box(center, radius). \nimage_points:     the spread of test points for comparison in intersection algorithms.                     Must have the signature domain_points(center, radius) and return                      an iterator of points within Box(center, radius). \n\n.\n\n\n\n\n\n","category":"type"},{"location":"boxmap/#GAIO.CPUSampledBoxMap","page":"BoxMaps","title":"GAIO.CPUSampledBoxMap","text":"BoxMap(:cpu, map, domain; n_points) -> CPUSampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a CPUSampledBoxMap defined  on Boxes. \n\nUses the CPU's SIMD acceleration capabilities. \n\nBy default uses a grid of sample points. \n\nBoxMap(:sampled, :cpu, boxmap, idx_base, temp_vec, temp_points)\n\nType representing a discretization of a map using  sample points which are explicitly vectorized. This  type performs roughly 2x as many floating point  operations per second as standard SampledBoxMaps. \n\nFields:\n\nboxmap:         SampledBoxMap with one restriction:                   boxmap.domain_points(c, r) must                    return an iterable with eltype                    SVector{N, SIMD.Vec{S,T}} where N                   is the dimension, S is the cpu's                    SIMD operation capacity, e.g. 4,                    and T is the individual element type,                    e.g. Float64. \nidx_base:       SIMD.Vec{S,Int} which is used to                    transform a                    Vector{SVector{N, SIMD.Vec{S,T}}}                   into a                    Vector{SVector{N,T}}. \ntemp_points:    Raw data Vector{SVector{N,T}}                    which holds the S temporary pointwise                    images of a SVector{N, SIMD.Vec{S,T}}                   under the point map. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"boxmap/#GAIO.GPUSampledBoxMap","page":"BoxMaps","title":"GAIO.GPUSampledBoxMap","text":"BoxMap(:gpu, map, domain; n_points) -> GPUSampledBoxMap\n\nTransforms a map Q  Q defined on points in  the domain Q  ℝᴺ to a GPUSampledBoxMap defined  on Boxes. \n\nUses the GPU's acceleration capabilities. \n\nBy default uses a grid of sample points. \n\nBoxMap(:sampled, :gpu, boxmap)\n\nType representing a dicretization of a map using  sample points, which are mapped on the gpu. This  type performs orders of magnitude faster than  standard SampledBoxMaps. \n\nwarning: `image_points` with `GPUSampledBoxMap`\nGPUSampledBoxMap makes NO use of the image_points  field in SampledBoxMaps. \n\nFields:\n\nboxmap:     SampledBoxMap with one restriction:                boxmap.image_points will not be used. \n\nRequires a CUDA-capable gpu. \n\n\n\n\n\n","category":"type"},{"location":"boxmap/#Creating-you-own-BoxMap-type","page":"BoxMaps","title":"Creating you own BoxMap type","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"Subtypes of the abstract type BoxMap must have three restrictions:","category":"page"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"There must be a domain field within the type, i.e.\nstruct MyBoxMap{N,T}\n    domain::Box{N,T}\n    # other things ...\nend\nThere must be a method map_boxes(g::MyBoxMap, source::BoxSet) which computes the setwise image of source under g and returns a BoxSet. \nThere must be a method construct_transfers(g::MyBoxMap, source::BoxSet) which computes a dictionary-of-keys sparse matrix mat with mat[(hit_key, source_key)] = weight for the TransferOperator, as well as a BoxSet called variant_set which is setdiff(g(source), source). These are both returned by construct_transfers(g::MyBoxMap, source::BoxSet). ","category":"page"},{"location":"boxmap/#References","page":"BoxMaps","title":"References","text":"","category":"section"},{"location":"boxmap/","page":"BoxMaps","title":"BoxMaps","text":"[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"GAIO.jl offers plotting recipes for both Plots.jl and Makie.jl. This means that one can use all the surrounding functionality of Plots.jl or makie.jl, e.g. creating multiple subplots, animations, colorbars, etc. simply by loading either Plots.jl or Makie.jl. ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"note: Why offer both Plots and Makie recipes?\nMakie.jl offers much more funcitonality and performance in interactive plots, but suffers much more greatly from the well known time to fist plot problem. Hence GAIO.jl offers Plots.jl recipes for fast, 2-dimensional, non-interactive plotting, and Makie.jl recipes for interactive, 2- and 3-dimensional, or publication-quality visualizations. To see a difference in the plotting capability, see the Hénon map example. ","category":"page"},{"location":"plotting/#Using-Plots","page":"Plotting","title":"Using Plots","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To make a plot, one needs to simply load the package. Add Plots using the package manager","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"pkg> add Plots","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Load Plots with","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plots","category":"page"},{"location":"plotting/#Using-Makie","page":"Plotting","title":"Using Makie","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To see a plot, one needs to load one of the Makie backends (see makie documentation about backends). We will use GLMakie, which uses OpenGL. Add GLMakie using the package manager","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"pkg> add GLMakie","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Load the GLMakie backend and some plotting tools with","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using GLMakie: plot #, Axis3, Colorbar, etc...","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"warning: A note on Namespaces\nMakie and GAIO.jl both export the type Box. For this reason, it is recommended NOT to use using GLMakieand instead only load the function names one needs from Makie. ","category":"page"},{"location":"plotting/#Common-Interface","page":"Plotting","title":"Common Interface","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To plot a BoxSet or BoxFun b, simply call ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(b)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The mutating function plot! is also available. All of Plots.jl's or Makie.jl's keyword arguments, such as color, colormap, etc. can be used. In addition, the keyword argument projection is used to project to a lower dimensional space if the dimension of the space d is greater than 2 for Plots.jl or greater than 3 for Makie.jl. By default, the function used is x -> x[1:2] for Plots.jl and x -> x[1:3] for Makie.jl. For an example using a custom projection function, eg. to plot the unstable set of the dadras system:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using GAIO\nusing GLMakie: plot\n\n# the Dadras system\nconst a, b, c = 8.0, 40.0, 14.9\nv((x,y,z,w)) = (a*x-y*z+w, x*z-b*y, x*y-c*z+x*w, -y)\nf(x) = rk4_flow_map(v, x, 0.01, 5)\n\ncen, rad = (0,0,0,0), (250,150,200,25)\nP = BoxPartition(Box(cen, rad), (128,128,128,128))\nF = AdaptiveBoxMap(f, P.domain)\n\nx = zeros(4)        # equilibrium\nW = unstable_set(F, P[x])\n\nA = [0 1 0 0;\n     0 0 1 0;\n     0 0 0 1]\n\nplot(W, projection = x -> A*x)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"GAIO.plotboxes","category":"page"},{"location":"plotting/#GAIO.plotboxes","page":"Plotting","title":"GAIO.plotboxes","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :red Color used for the boxes.\n\ncolormap = :default Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box. Only works if using Makie for plotting. \n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"function"},{"location":"#GAIO.jl","page":"Home","title":"GAIO.jl","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GAIO (Global Analysis of Invariant Objects) is a Julia package for set oriented computations.  Sets are represented by  collections of boxes. A box (or cube) is a higher dimensional interval, i.e. a set of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"a_1b_1)    a_nb_n)    a_kb_k  ℝ","category":"page"},{"location":"","page":"Home","title":"Home","text":"GAIO.jl provides algorithms for  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"dynamical systems\ninvariant sets (maximal invariant set, chain recurrent set, (relative) attractor, (un-)stable manifold)\nalmost invariant and coherent sets\nfinite time Lyapunov exponents\nentropy and box dimension\nroot finding problems\nmulti-objective optimization problems\ncomputing implicitely defined manifolds","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package requires Julia 1.7 or later. In Julia's package manager, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gaioguys/GAIO.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"followed by","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GAIO","category":"page"},{"location":"","page":"Home","title":"Home","text":"at the Julia prompt in order to load the package.","category":"page"},{"location":"#Project-origin","page":"Home","title":"Project origin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package originated as a university seminar for master students in the summer 2020, with the aim to enhance  and convert the already existing Matlab GAIO package to Julia.","category":"page"}]
}
