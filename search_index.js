var documenterSearchIndex = {"docs":
[{"location":"cuda/#Using-the-GPU-(Nvidia)","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"","category":"section"},{"location":"cuda/#Tutorial","page":"Using the GPU (Nvidia)","title":"Tutorial","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"using GAIO","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"This example demonstrates how to get a vast speedup in your code using nvidia CUDA. The speedup factor increases exponentially with the complexity of the map.","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"Consider the point map f:","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"const σ, ρ, β = 10.0f0, 28.0f0, 0.4f0\nfunction v(x)\n    # Some map, here we use the Lorenz equation\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\n# set f as 100 steps of the classic 4th order RK method\nf(x) = rk4_flow_map(v, x, 0.002f0, 100)","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"tip: Single vs Double Precision Arithmetic\nFor best results, ensure that your functions only use 32-bit operations, as GPUs are not efficient with 64-bit.GAIO can convert your BoxPartition to 32-bit automatically when you use GPU acceleration, but preferred are still explicit 32-bit literals likecenter, radius = (0f0,0f0,25f0), (30f0,30f0,30f0)instead of center, radius = (0,0,25), (30,30,30). ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"danger: Using TreePartition\nTreePartition with GPU acceleratioin is not yet supported, since linear indexing of the tree structure is not yet implemented. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"All we need to do is pass :cpu as the final argument to one of the box map constructors, eg. BoxMap, PointDiscretizedMap, AdaptiveBoxMap. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"center, radius = (0f0,0f0,25f0), (30f0,30f0,30f0)\nP = BoxPartition(Box(center, radius), (128,128,128))\nF = BoxMap(f, P, :gpu)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\n@time W = unstable_set!(F, P[x])","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"Using CUDA, one can achieve a more than 100-fold increase in performance. However, the performance increase is dependent on the complexity of the map f. For \"simple\" maps (eg. f from above with 20 steps), the GPU accelerated version will actually perform worse because computation time is dominated by the time required to transfer data across the (comparatively slow) PCIe bus. The GPU accelerated version only beats the CPU accelerated version if f is set to use more than 40 steps. Hence it is highly recommended to use the GPU if the map f is not dominated by memory transfer speed, but not recommended otherwise. For more detail, see [1]. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"(Image: performance metrics)","category":"page"},{"location":"cuda/#I-get-InvalidIRError-due-to-unsupported-dynamic-function-invocation","page":"Using the GPU (Nvidia)","title":"I get InvalidIRError due to unsupported dynamic function invocation","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"CUDA.jl generally give somewhat cryptic error messages. An unsupported dynamic function invocation can be caused by a simple error in the code. Hence, first try algorithms with f WITHOUT using the GPU, and ensure that no errors occur. ","category":"page"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"If you still recieve dynamic function invocations, there likely is an operation somewhere in f which is not supported in CUDA.jl. A deliberately unsupported function can be for example matrix factorization, matrix-matrix multiplication, etc. because this is typically a performance trap if done on a single GPU thread. One option for linear algebra based functions which cause unsupported dynamic function invocations is to use StaticArrays. StaticArrays implements specialized methods for many low-dimensional linear algebra routines, allowing one to escape the standard methods which may cause unsupported dynamic function invocations. However, this is not a solution for all such problems, so a read through the CUDA.jl documentation, opening an issue on the GAIO.jl repo, or posting a question on the GPU category of julia Discourse for help may be necessary. ","category":"page"},{"location":"cuda/#References","page":"Using the GPU (Nvidia)","title":"References","text":"","category":"section"},{"location":"cuda/","page":"Using the GPU (Nvidia)","title":"Using the GPU (Nvidia)","text":"[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. ","category":"page"},{"location":"data_structures/#Data-Structures","page":"Data Structures","title":"Data Structures","text":"","category":"section"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Pages = [\"data_structures.md\"]","category":"page"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Box\nvolume(box::Box)","category":"page"},{"location":"data_structures/#GAIO.Box","page":"Data Structures","title":"GAIO.Box","text":"Box{N,T}(center, radius)\nBox(center, radius)\n\nA generalized box in dimension N with element type T.  Mathematically, this is a set\n\ncenter_1 - radius_1 center_1 + radius_1)  times  center_N - radius_N center_N + radius_N)\n\nFields:\n\ncenter:   vector where the box's center is located\nradius:   vector of radii, length of the box in each dimension\n\nMethods implemented:\n\n:(==), in #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.volume-Tuple{Box}","page":"Data Structures","title":"GAIO.volume","text":"Computes the volume of a box. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxPartition\nsubdivide(P::BoxPartition{N,T,I}, dim) where {N,T,I}","category":"page"},{"location":"data_structures/#GAIO.BoxPartition","page":"Data Structures","title":"GAIO.BoxPartition","text":"BoxPartition(domain::Box{N}, dims::NTuple{N,<:Integer} = ntuple(_->1, N))\n\nData structure to partition a box into a  dims[1] x dims[2] x ... dims[N] equidistant grid. \n\nFields:\n\ndomain:       box defining the entire domain\nleft:         leftmost / bottom edge of the domain\nscale:        1 / diameter of each box in the new partition (componentwise)\ndims:         tuple, number of boxes in each dimension\ndimsprod:     for indexing the partition. BoxPartition uses linear indices, i.e.                 keys are counted up in first dimension first,                  then second dimension, etc... \n\n         1st dim →\n          * — * — * — *\n    2nd   | 1 | 2 | 3 |\n    dim   * — * — * — *\n    ↓     | 4 | 5 | 6 |\n          * — * — * — *\n\nMethods implemented:\n\n:(==), ndims, size, length, keys, keytype #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Data Structures","title":"GAIO.subdivide","text":"subdivide(P::BoxPartition, dim) -> BoxPartition\nsubdivide(B::BoxSet, dim) -> BoxSet\n\nBisect every box in boxset along the axis dim,  giving rise to a new partition of the domain, with  double the amount of boxes. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"TreePartition\nsubdivide!","category":"page"},{"location":"data_structures/#GAIO.TreePartition","page":"Data Structures","title":"GAIO.TreePartition","text":"TreePartition(domain::Box)\n\nBinary tree structure to partition domain into (variably sized) boxes. \n\nFields:\n\ndomain: Box denoting the full domain.\nnodes: vector of Nodes. Each node holds two indices pointing to \n\nother nodes in the vector, or 0. \n\nregular_partitions: vector of BoxPartitions. The indices held in \n\na node also refer to this vector. \n\nMethods implemented:\n\ncopy, keytype #, etc...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.subdivide!","page":"Data Structures","title":"GAIO.subdivide!","text":"subdivide!(tree:TreePartition), key::NTuple{2,<:Integer}) -> TreePartition\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, key::NTuple{2,<:Integer}) -> BoxSet\n\nSubdivide a TreePartition at the node key. Dimension along which  the node is subdivided depends on the depth of the node. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"SampledBoxMap\nBoxMap\nPointDiscretizedMap\nAdaptiveBoxMap","category":"page"},{"location":"data_structures/#GAIO.SampledBoxMap","page":"Data Structures","title":"GAIO.SampledBoxMap","text":"SampledBoxMap(map, domain::Box, domain_points, image_points, acceleration)\n\nTransforms a map Q  Q defined on points in the box Q  ℝᴺ to a SampledBoxMap defined  on Boxes. \n\nConstructors:\n\nBoxMap\nPointDiscretizedMap\nAdaptiveBoxMap\n\nFields:\n\nmap:              map that defines the dynamical system.\ndomain:           domain of the map, B.\ndomain_points:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature domain_points(center, radius) and return                      an iterator of points within Box(center, radius). \nimage_points:     the spread of test points for comparison in intersection algorithms.                     Must have the signature domain_points(center, radius) and return                      an iterator of points within Box(center, radius). \nacceleration:     Whether to use optimized functions in intersection algorithms.                     Accepted values: nothing, BoxMapCPUCache, BoxMapGPUCache.                     BoxMapGPUCache does nothing unless you have a CUDA capable gpu.\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.BoxMap","page":"Data Structures","title":"GAIO.BoxMap","text":"BoxMap(map, domain::Box{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -> SampledBoxMap\nBoxMap(map, P::BoxPartition{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses no_of_points Monte-Carlo  test points. \n\n\n\n\n\n","category":"type"},{"location":"data_structures/#GAIO.PointDiscretizedMap","page":"Data Structures","title":"GAIO.PointDiscretizedMap","text":"PointDiscretizedMap(map, domain, points, accel=nothing) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses the iterator points as test points.  points must be an array or iterator of test points within the unit cube  -11^N. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/#GAIO.AdaptiveBoxMap","page":"Data Structures","title":"GAIO.AdaptiveBoxMap","text":"AdaptiveBoxMap(f, domain::Box, accel=nothing) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses sample_adaptive to generate  test points. \n\n\n\n\n\n","category":"function"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxSet","category":"page"},{"location":"data_structures/#GAIO.BoxSet","page":"Data Structures","title":"GAIO.BoxSet","text":"BoxSet(partition, indices::AbstractSet)\n\nInternal data structure to hold boxes within a partition. \n\nConstructors:\n\nFor all boxes in a partition: \n\npartition[:]\n\nFor one box containing a point x: \n\npartition[x]\n\nFor a covering of a set S = [Box(c_1, r_1), Box(c_2, r_r)] # etc...: \n\npartition[S]\n\nFields:\n\npartition:  the partition that the set is defined over\nset:        set of partition-keys corresponding to the boxes in the set\n\nMost set operations such as \n\nunion, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...\n\nare supported. \n\n\n\n\n\n","category":"type"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"BoxFun\nBase.sum(f, boxfun::BoxFun)\n∘(f, boxfun::BoxFun)","category":"page"},{"location":"data_structures/#GAIO.BoxFun","page":"Data Structures","title":"GAIO.BoxFun","text":"BoxFun(partition, vals)\n\nDiscretization of a function over the domain partition.domain, as a piecewise constant function over the boxes of partition. \n\nImplemented as a sparse vector over the indices of partition. \n\nFields:\n\npartition: An AbstractBoxPartition whose indices are used \n\nfor vals\n\nvals: A sparse vector whose indices are the box indices from \n\npartition, and whose values represent the values of the function. \n\nMethods implemented:\n\nlength, LinearAlgebra.norm, LinearAlgebra.normalize!\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/#Base.sum-Tuple{Any, BoxFun}","page":"Data Structures","title":"Base.sum","text":"sum(f, boxfun::BoxFun)\n\nIntegrate a function f using boxfun as a density, that is, if boxfun is the discretization of a measure mu over the domain  Q, then approximate the value of \n\nint_Q f  dmu \n\n\n\n\n\n","category":"method"},{"location":"data_structures/#Base.:∘-Tuple{Any, BoxFun}","page":"Data Structures","title":"Base.:∘","text":"∘(f, boxfun::BoxFun) -> BoxFun\n\nCompose the function f with the boxfun. \n\n\n\n\n\n","category":"method"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"TransferOperator","category":"page"},{"location":"data_structures/#GAIO.TransferOperator","page":"Data Structures","title":"GAIO.TransferOperator","text":"TransferOperator(map::BoxMap, support::BoxSet, mat::SparseMatrixCSC)\nTransferOperator(map::BoxMap, support::BoxSet)\n\nDiscretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with the same linear indices as support, e.g. if \n\njulia> B = BoxSet(partition, [3,10,30])\n  Boxset over [...] partition\n\njulia> T = TransferOperator(boxmap, B)\n  TransferOperator over [...] BoxSet\n\nfor some partition and boxmap, then \n\njulia> axes(T)\n  ([3, 10, 30], [3, 10, 30])\n\nIt is important to note that TranferOperator is only supported over the  box set B, but if one lets a TranferOperator act on a BoxFun, then  the support B is extended \"on the fly\" to include the support of the BoxFun.\n\nMethods Implemented: \n\n:(==), axes, size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...\n\n.\n\n\n\n\n\n","category":"type"},{"location":"data_structures/","page":"Data Structures","title":"Data Structures","text":"Add SparseArrays.sparse(g::TransferOperator) once next PR is pushed","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Consider the Hénon map [1]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"f(xy) = (1-ax^2+y bx) quad ab in mathbbR","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Iterating some random intial point exhibits a strange attractor (a=1.4 and b=0.3)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"(Image: Hénon attractor)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Since this map is chaotic [2,3], it has sensitive dependence on initial conditions.  That is, small perturbations (as unavoidable on a computer) during the computation grow exponentially during the iteration.  Thus, apart from a few iterates at the beginning, the computed trajectory does not (necessarily) follow a true trajectory. One might therefore question how reliable this figure is.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Instead of trying to approximate the attractor by a long forward trajectory, we will capture it by computing a collection of boxes (i.e. cubes) covering the attractor. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Start by loading the GAIO package","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using GAIO","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A Box is descibed by its center and its radius","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"box_center, box_radius = (0,0), (3,3)\nQ = Box(box_center, box_radius)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This box will serve as the domain for our computation.  The box covering which we will compute is a subset of a partition of Q into smaller boxes. The command","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"P = BoxPartition(Q, (4,4)) ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a partition of Q into a grid of 4 x 4 equally sized smaller boxes. From P, box sets can be constructed. For example, the command","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"B = P[:]","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"yields a BoxSet containing all boxes from the partition P (i.e. a set containing 16 boxes).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In order to deal with the Hénon map as a map on box sets, we have to turn it into a BoxMap on the given partition P","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"a, b = 1.4, 0.3\nf((x,y)) = (1 - a*x^2 + y, b*x) \nF = BoxMap(f, P) ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"We can now compute a covering of the attractor in Q, starting with the full box set B, by applying 15 steps of the subdivison algorithm described in [4]:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"A = relative_attractor(F, B, steps = 15)  \nplot(A)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"(Image: box covering of the Hénon attractor)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In addition to covering the attractor, this box collection also covers an unstable fixed point near (-1,-0.3) and its unstabe manifold (cf. [4]).","category":"page"},{"location":"getting_started/#References","page":"Getting started","title":"References","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[1] Hénon, Michel. \"A two-dimensional mapping with a strange attractor\". Communications in Mathematical Physics 50.1 (1976): 69–77.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[2] Benedicks, Michael, and Lennart Carleson. \"The dynamics of the Hénon map.\" Annals of Mathematics 133.1 (1991): 73-169.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[3] Zgliczynski, Piotr. \"Computer assisted proof of chaos in the Rössler equations and in the Hénon map.\" Nonlinearity 10.1 (1997): 243. ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"[4] Dellnitz, Michael, and Andreas Hohmann. \"A subdivision algorithm for the computation of unstable manifolds and global attractors.\" Numerische Mathematik 75.3 (1997): 293-317.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#How-to-Use","page":"Examples","title":"How to Use","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To see examples of how to use GAIO.jl explore the examples folder. This contains a Project.toml file that can be used to download all the necessary dependencies for the examples. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To try the examples, one can choose between two options:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(recommended) simply download an example file and see what packages are used, add them in the package manager\nclone the GAIO.jl GitHub repository. Navigate to the repository folder /path/to/GAIO.jl/examples in the julia REPL using pwd and cd. Finally, call the following in the julia REPL","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"pkg> activate .\njulia> pwd()\n\"/path/to/GAIO.jl\"\n\njulia> cd(\"./examples\")\n\n(GAIO) pkg> activate .\n  Activating project at `/path/to/GAIO.jl/examples`\n\n(examples) pkg> dev ../\n   Resolving package versions...\n  No Changes to `/path/to/GAIO.jl/examples/Project.toml`\n  No Changes to `/path/to/GAIO.jl/examples/Manifest.toml`\n\n(examples) pkg> instantiate\n  69 dependencies successfully precompiled in 74 seconds","category":"page"},{"location":"examples/#Example-Files","page":"Examples","title":"Example Files","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Relative attractor of the Hénon map\nUnstable manifold of the Lorenz system\nChain recurrent of a knotted flow\nInvariant measure of the transfer operator for the logistic map\nInvariant measure of the transfer operator for the Hénon map over the relative attractor\nInvariant measure of the transfer operator for the Lorenz map over the unstable manifold\nRoot covering of a cubic map\nDoubling performance using SIMD operations\nVastly improving performance using Nvidia CUDA","category":"page"},{"location":"general/#Usage","page":"General usage","title":"Usage","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The base of the numerical set oriented methods of this framework are BoxSet (the discretization of a set) and BoxMap (the discretization of a map), thus, in the following, we will have a closer look at the two and other useful things to know when using GAIO.jl. ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To create a Box given its center point c = (c_1, c_2, ..., c_d) as well as its \"radius\" in every axis direction r = (r_1, r_2, ..., c_d), simply type ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"using GAIO\n\nQ = Box(c, r)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This creates a set Q = c_1 - r_1 c_1 + r_1) times ldots times c_d - r_d c_d + r_d). ","category":"page"},{"location":"general/#BoxPartition","page":"General usage","title":"BoxPartition","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"Most algorithms in GAIO.jl revolve around a partition of the domain Q into small boxes. To create an n_1 times ldots times n_d - element equidistant grid of boxes, we can pass the tuple n = (n_1 ldots n_d) into the function BoxPartition","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"P = BoxPartition(Q, n)","category":"page"},{"location":"general/#TreePartition","page":"General usage","title":"TreePartition","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"For partitions of Q into variably sized boxes, one can use TreePartition:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"P = TreePartition(Q)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"warning: Using `TreePartition`\nTreePartition is an area of active development, and an overhaul is potentially planned in the future. Please keep this in mind when using TreePartitions. ","category":"page"},{"location":"general/#BoxSet","page":"General usage","title":"BoxSet","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The core ideabehind GAIO.jl is to approximate an subset of the domain via a collection of small boxes. To construct BoxSets, there are two main options: getting all boxes in the partition, or locating a box surrounding a point x in Q","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"B = P[:]    # set of all boxes in P\n\nB = P[x]    # one box surrounding the point x","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"One can also create a Boxset from an iterable of Boxes. This will cover every element of the iterable with boxes from P:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... \n\nB = P[S]","category":"page"},{"location":"general/#BoxMap","page":"General usage","title":"BoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"A BoxMap is a function which maps boxes to boxes. Given a pointmap f, initialize the corresponding BoxMap F by","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"F = BoxMap(f, P.domain)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This will generate a BoxMap which uses Monte-Carlo test points to map boxes. To specify the amount of test points used, use the no_of_points keyword argument:","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"F = BoxMap(f, P.domain, no_of_points=300)","category":"page"},{"location":"general/#AdaptiveBoxMap","page":"General usage","title":"AdaptiveBoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"For choosing test points we can use some knowledge of the Lipschitz matrix for f in a box Box(c, r), that is, a matrix L in mathbbR^d times d such that ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":" f(y) - f(z)  leq L   y - z  quad textfor all  y z in textBox(c r)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"where the operations  cdot  and leq are to be understood elementwise. The function AdaptiveBoxMap attempts to approximate L before choosing an adaptive grid of test points in each box, as described in [1]","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"F = AdaptiveBoxMap(f, P.domain)","category":"page"},{"location":"general/#Using-BoxMap-/-AdaptiveBoxMap","page":"General usage","title":"Using BoxMap / AdaptiveBoxMap","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"Now, one can map a BoxSet via the BoxMap F by simply calling F as a function ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"C = F(B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"where the output C is also a BoxSet.","category":"page"},{"location":"general/#TransferOperator","page":"General usage","title":"TransferOperator","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The Perron-Frobenius operator (or transfer operator) [2] is discretized in GAIO.jl using the TransferOperator type. To initialize a TransferOperator that acts on a subdomain of Q, type","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"T = TransferOperator(F, B)   # T operates on the domain covered by the box set B","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"To find an approximate invariant measure over B use the eigs function","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"λ, ev, num_converged_eigs = eigs(T)\n\nμ = ev[1]   # ev is an array of measures, grab the first one","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"This can also be done with the adjoint Koopman operator T'. ","category":"page"},{"location":"general/#BoxFun","page":"General usage","title":"BoxFun","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"The return type of eigs(T) is a stepwise constant function over the boxes in B, which is called a BoxFun. One can let T act on a BoxFun simply through multiplication","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"ν = T * μ","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Of course, the same holds for the the Koopman operator as well. ","category":"page"},{"location":"general/#Plotting","page":"General usage","title":"Plotting","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"GAIO.jl uses Makie to plot boxes. To plot a box set, simply choose a Makie backend, eg. GLMakie, and call plot","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"using GLMakie: plot\n\nplot(B)","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"Plotting works with all the functionality of Makie. This means you can set box plots as subplots, add colorbars, etc., using the Makie commands. For an example, see examples/invariant_measure_2d.jl. ","category":"page"},{"location":"general/#References","page":"General usage","title":"References","text":"","category":"section"},{"location":"general/","page":"General usage","title":"General usage","text":"[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.","category":"page"},{"location":"general/","page":"General usage","title":"General usage","text":"[2] Andrzej Lasota and Michael C. Mackey. Chaos, Fractals, and Noise. Stochastic Aspects of Dynamics. Springer New York, NY, 1994. doi: https://doi.org/10.1007/978-1-4612-4286-4.","category":"page"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"GAIO.jl hooks into the Makie.jl plotting API. This means that one can use all the surrounding functionality of Makie, eg. Axis, Axis3, Colorbar, etc. ","category":"page"},{"location":"plotting/#Makie-Backends","page":"Plotting","title":"Makie Backends","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To see a plot, one needs to load one of the Makie backends (see makie documentation about backends). We will use GLMakie, which uses OpenGL. Add GLMakie using the package manager:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"pkg> add GLMakie","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Load the GLMakie backend and some plotting tools with","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using GLMakie: plot #, Axis3, Colorbar, etc...","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"warning: A note on Namespaces\nMakie and GAIO.jl both export the type Box. For this reason, it is recommended NOT to use using GLMakieand instead only load the function names one needs from Makie. ","category":"page"},{"location":"plotting/#Plotting-BoxSets-and-BoxFuns","page":"Plotting","title":"Plotting BoxSets and BoxFuns","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"To plot a BoxSet or BoxFun b, simply call ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"plot(b)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The mutating function plot! is also available. All of Makie's plotting keyword arguments, such as color, colormap, etc. In addition, the keyword argument projection_func is used to project to 3-dimensional space if the dimension of the space d is greater than 3. By default, the function used is x -> x[1:3]. For an example using a custom projection function, eg. to plot the unstable set of the dadras system:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using GAIO\nusing GLMakie: plot\n\n# the Dadras system\nconst a, b, c = 8.0, 40.0, 14.9\nv((x,y,z,w)) = (a*x-y*z+w, x*z-b*y, x*y-c*z+x*w, -y)\nf(x) = rk4_flow_map(v, x, 0.01, 5)\n\ncen, rad = (0,0,0,0), (250,150,200,25)\nP = BoxPartition(Box(cen, rad), (128,128,128,128))\nF = AdaptiveBoxMap(f, P.domain)\n\nx = zeros(4)        # equilibrium\nW = unstable_set!(F, P[x])\n\nA = [1 0 0 0;\n     0 1 0 0;\n     0 0 1 0]\n\nplot(W, projection_func = x -> A*x)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"GAIO.plotboxes\nGAIO.plotboxes!","category":"page"},{"location":"plotting/#GAIO.plotboxes","page":"Plotting","title":"GAIO.plotboxes","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection_func = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :firebrick1 Color used for the boxes.\n\ncolormap = :jet Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box.\n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#GAIO.plotboxes!","page":"Plotting","title":"GAIO.plotboxes!","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection_func = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :firebrick1 Color used for the boxes.\n\ncolormap = :jet Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box.\n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"function"},{"location":"simd/#Using-the-CPU","page":"Using the CPU","title":"Using the CPU","text":"","category":"section"},{"location":"simd/#Tutorial","page":"Using the CPU","title":"Tutorial","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"This example demonstrates how to get a ~2x speedup in your code using your CPU's SIMD capabilities. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Consider the point map f:","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"using GAIO\n\nconst σ, ρ, β = 10.0, 28.0, 0.4\nfunction v(x)\n    # Some map, here we use the Lorenz equation\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\n# set f as 20 steps of the classic 4th order RK method\nf(x) = rk4_flow_map(v, x, 0.01, 20)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Internally, GAIO calls this function on many test points within the various boxes. This means many function calls have to be made. Notably, all of these function calls are independent of one another, meaning that they can be performed in parallel. If your function only uses \"basic\" instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple funnction calls can be made at the same time, increasing performance. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"tip: Which instructions are supported?\nGAIO.jl uses SIMD.jl to explicitly vectorize operations. To see precisely which instructions are supported, refer to the documentation for SIMD.jl. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"All we need to do is pass :cpu as the final argument to one of the box map constructors, eg. BoxMap, PointDiscretizedMap, AdaptiveBoxMap. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"center, radius = (0,0,25), (30,30,30)\nP = BoxPartition(Box(center, radius), (128,128,128))\nF = BoxMap(f, P, :cpu)\n\nx = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)\n@time W = unstable_set!(F, P[x])","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Using SIMD vectorization, one can roughly double the effective floating point operations per second. For more detail, see [1]. ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"(Image: performance metrics)","category":"page"},{"location":"simd/#I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})","page":"Using the CPU","title":"I get MethodError: No method matching f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"If your code returns a MethodError with reference to SIMD.Vec somewhere, this most likely means that your pointmap f uses operations not explicitly supported by SIMD.jl. In this case, one you may need to rewrite sections of f to use only supported operations. For example, consider a \"scaled\" Lorenz flow map ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"function v(x_in)\n    \n    x = x_in ./ sqrt(norm(x_in))\n\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\nf(x) = rk4_flow_map(v, x)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"This code will return a MethodError due to LinearAlgebra.norm. For the L^2 norm, this can be manually rewritten as follows: ","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"function v(x_in)\n    \n    sqnorm = sum(y -> y*y, x_in)\n    sqnorm = sqrt(sqrt(sqnorm))\n\n    x = (\n        x_in[1] / sqnorm,\n        x_in[2] / sqnorm,\n        x_in[3] / sqnorm\n    )\n\n    dx = (\n           σ * x[2] -    σ * x[1],\n           ρ * x[1] - x[1] * x[3] - x[2],\n        x[1] * x[2] -    β * x[3]\n    )\n    return dx\nend\n\nf(x) = rk4_flow_map(v, x)","category":"page"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"Generally, most \"simple\" functions can be rewritten (if needed) to support SIMD.jl. However, more complicated functions can make rewriting unnecessarily difficult. ","category":"page"},{"location":"simd/#References","page":"Using the CPU","title":"References","text":"","category":"section"},{"location":"simd/","page":"Using the CPU","title":"Using the CPU","text":"[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. ","category":"page"},{"location":"#GAIO.jl","page":"Home","title":"GAIO.jl","text":"","category":"section"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GAIO (Global Analysis of Invariant Objects) is a Julia package for set oriented computations.  Sets are represented by  collections of boxes. A box (or cube) is a higher dimensional interval, i.e. a set of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"a_1b_1)    a_nb_n)    a_kb_k  ℝ","category":"page"},{"location":"","page":"Home","title":"Home","text":"GAIO.jl provides algorithms for  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"dynamical systems\ninvariant sets (maximal invariant set, chain recurrent set, (relative) attractor, (un-)stable manifold)\nalmost invariant and coherent sets\nfinite time Lyapunov exponents\nentropy and box dimension\nroot finding problems\nmulti-objective optimization problems\ncomputing implicitely defined manifolds","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package requires Julia 1.7 or later. In Julia's package manager, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/gaioguys/GAIO.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"followed by","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GAIO","category":"page"},{"location":"","page":"Home","title":"Home","text":"at the Julia prompt in order to load the package.","category":"page"},{"location":"#Project-origin","page":"Home","title":"Project origin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package originated as a university seminar for master students in the summer 2020, with the aim to enhance  and convert the already existing Matlab GAIO package to Julia.","category":"page"},{"location":"library_reference/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"library_reference/","page":"Library Reference","title":"Library Reference","text":"Pages = [\"library_reference.md\"]","category":"page"},{"location":"library_reference/","page":"Library Reference","title":"Library Reference","text":"Modules = [GAIO]","category":"page"},{"location":"library_reference/#GAIO.BoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.BoxMap","text":"BoxMap(map, domain::Box{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -> SampledBoxMap\nBoxMap(map, P::BoxPartition{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses no_of_points Monte-Carlo  test points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.Node","page":"Library Reference","title":"GAIO.Node","text":"Node structure used for TreePartitions\n\nFields:\n\nleft and right refer to indices w.r.t. trp.nodes and \n\ntrp.regular_partitions for a TreePartition trp. \n\n.\n\n\n\n\n\n","category":"type"},{"location":"library_reference/#Arpack.eigs-Union{Tuple{TransferOperator{GAIO.BoxList{P, L}}}, Tuple{L}, Tuple{P}} where {P, L}","page":"Library Reference","title":"Arpack.eigs","text":"eigs(gstar::TransferOperator [; kwargs...]) -> (d[, v], nconv)\n\nCompute a set of eigenvalues d and eigenmeasures v of gstar.  Works with the adjoint Koopman operator as well.  All keyword arguments from Arpack.eigs can be passed. See the  documentation for Arpack.eigs. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#Base.:∘-Union{Tuple{V}, Tuple{K}, Tuple{P}, Tuple{Any, BoxFun{P, K, V}}} where {P, K, V}","page":"Library Reference","title":"Base.:∘","text":"∘(f, boxfun::BoxFun) -> BoxFun\n\nCompose the function f with the boxfun. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#Base.getindex-Tuple{AbstractBoxPartition, Any}","page":"Library Reference","title":"Base.getindex","text":"getindex constructors:\nset of all boxes in P:\njulia   B = P[:]\ncover the point x, or points x = [x_1, x_2, x_3] # etc ... using boxes from P\njulia   B = P[x]    \na covering of S using boxes from P\njulia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = P[S]\n\nReturn a subset of the partition P based on the second argument. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{Any, BoxFun{K, V}}} where {K, V}","page":"Library Reference","title":"Base.sum","text":"sum(f, boxfun::BoxFun)\n\nIntegrate a function f using boxfun as a density, that is, if boxfun is the discretization of a measure mu over the domain  Q, then approximate the value of \n\nint_Q f  dmu \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.AdaptiveBoxMap","text":"AdaptiveBoxMap(f, domain::Box, accel=nothing) -> SampledBoxMap\n\nConstruct a SampledBoxMap which uses sample_adaptive to generate  test points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.PointDiscretizedMap","page":"Library Reference","title":"GAIO.PointDiscretizedMap","text":"PointDiscretizedMap(map, domain, points, accel=nothing) -> SampledBoxMap\n\nConstruct a SampledBoxMap that uses the iterator points as test points.  points must be an array or iterator of test points within the unit cube  -11^N. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.adaptive_newton_step","page":"Library Reference","title":"GAIO.adaptive_newton_step","text":"adaptive_newton_step(g, g_jacobian, x, k=1)\n\nReturn one step of the adaptive Newton algorithm for the point x. \n\nThe optional argument k is the iteration number, which is  used to tune the step size. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.bounded_point_to_ints-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.bounded_point_to_ints","text":"bounded_point_to_ints(partition::BoxPartition, point)\n\nFind the cartesian index of the nearest box within a  BoxPartition to a point. Conicides with unsafe_point_to_ints  if the point lies in the partition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.center-Tuple{Any, Any}","page":"Library Reference","title":"GAIO.center","text":"center(b::Box)\ncenter(center, radius)\n\nReturn the center of a box as an iterable.  Default function for image_points in SampledBoxMaps. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.chain_recurrent_set","text":"chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the chain recurrent set over the box set B. Generally,  B should be a box set containing the whole partition P,  ie B = P[:]. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_boxes-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.cover_boxes","text":"cover_boxes(partition::BoxPartition, boxes)\n\nReturn a covering of an iterator of Boxes using Boxes from partition.  Only covers the part of boxes which lies within partition.domain. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.cover_roots","text":"cover_roots(g, Dg, B::BoxSet; steps=12) -> BoxSet\n\nCompute a covering of the roots of g within the  partition P. Generally, B should be  a box set containing the whole partition P, ie B = P[:], and should contain a root of g. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.depth-Tuple{TreePartition}","page":"Library Reference","title":"GAIO.depth","text":"Return the depth of the tree structure. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.finite_time_lyapunov_exponents-Tuple{BoxSet, Any}","page":"Library Reference","title":"GAIO.finite_time_lyapunov_exponents","text":"finite_time_lyapunov_exponents(boxset::BoxSet, g; T, num_points=20, ϵ=1e-6) -> BoxFun\n\nCompute the Finite Time Lyapunov Exponent for every box in boxset.\n\nArguments:\n\nboxset is the starting BoxSet.\ng is a point map (not a BoxMap) describing the dynamics.\nT is the length of the time interval under consideration.\nnum_points is the number of points used in each box\nϵ is the maximum size of a perturbation in each coordinate\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.ints_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T}, Union{Tuple{Vararg{I, N}}, StaticArraysCore.StaticArray{Tuple{N}, I, 1}}}} where {N, T, I<:Integer}","page":"Library Reference","title":"GAIO.ints_to_box","text":"ints_to_box(P::BoxPartition, x_ints)\n\nReturn the box associated with the cartesian index x_ints  within a BoxPartition.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.ints_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I<:Integer}","page":"Library Reference","title":"GAIO.ints_to_key","text":"ints_to_key(P::BoxPartition, x_ints)\n\nConvert cartesian index to linear  index for a BoxPartition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Union{Integer, CartesianIndex{N}, Tuple{Vararg{var\"#s4\", N}} where var\"#s4\"<:Integer}}} where {N, T, I}","page":"Library Reference","title":"GAIO.key_to_box","text":"key_to_box(P::BoxPartition, key)\n\nReturn the box associated with the index within a BoxPartition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.key_to_ints-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Union{Integer, CartesianIndex{N}, Tuple{Vararg{var\"#s4\", N}} where var\"#s4\"<:Integer}}} where {N, T, I}","page":"Library Reference","title":"GAIO.key_to_ints","text":"key_to_ints(P::BoxPartition, key)\n\nConvert an index (linear or cartesian) in a BoxPartition to  cartesian indices.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.plotboxes!-Tuple","page":"Library Reference","title":"GAIO.plotboxes!","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection_func = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :firebrick1 Color used for the boxes.\n\ncolormap = :jet Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box.\n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.plotboxes-Tuple","page":"Library Reference","title":"GAIO.plotboxes","text":"plot(boxset::BoxSet)\nplot(boxfun::BoxFun)\nplot!(boxset::BoxSet)\nplot!(boxfun::BoxFun)\n\nPlot a BoxSet or BoxFun. \n\nSpecial Attributes:\n\nprojection_func = x -> x[1:3] If the dimension of the system is larger than 3, use this function to project to 3-d space.\n\ncolor = :firebrick1 Color used for the boxes.\n\ncolormap = :jet Colormap used for plotting BoxFuns values.\n\nmarker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1)) The marker for an individual box.\n\nAll other attributes are taken from MeshScatter.\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.point_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.point_to_box","text":"point_to_box(P::BoxPartition, point)\n\nFind the box within a BoxPartition containing a point. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.point_to_key","text":"point_to_key(P::BoxPartition, point)\n\nFind the linear index for the box within a BoxPartition  contatining a point. \n\nnote: Bounds checking\nunlike unsafe_point_to_ints, point_to_key will return  nothing if the point does not lie in the partition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P<:AbstractBoxPartition{Box{N, T}}}} where {N, T}","page":"Library Reference","title":"GAIO.relative_attractor","text":"relative_attractor(F::BoxMap, B::BoxSet; steps=12) -> BoxSet\n\nCompute the attractor relative to B. Generally, B should be  a box set containing the whole partition P, ie B = P[:].\n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Tuple{Any, Any, Any}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(center, radius, points)\n\nReturn an iterable which calls rescale(center, radius, point) for each point in points. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Tuple{Any}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(points)\n\nReturn a function \n\n(center, radius) -> rescale(center, radius, points)\n\nUsed in domain_points for BoxMap, PointDiscretizedMap. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.rescale","text":"rescale(box, point::Union{<:StaticVector{N,T}, <:NTuple{N,T}})\nrescale(center, radius, point::Union{<:StaticVector{N,T}, <:NTuple{N,T}})\n\nScale a point within the unit box -1 1^N  to lie within box = Box(center, radius). \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rk4-Tuple{Any, Any, Any}","page":"Library Reference","title":"GAIO.rk4","text":"rk4(f, x, τ)\n\nCompute one step with step size τ of the classic  fourth order Runge-Kutta method. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.rk4_flow_map","page":"Library Reference","title":"GAIO.rk4_flow_map","text":"rk4_flow_map(f, x, step_size=0.01, steps=20)\n\nPerform steps steps of the classic Runge-Kutta fourth order method, with step size step_size. \n\n\n\n\n\n","category":"function"},{"location":"library_reference/#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, StaticArraysCore.SVector{N, T}}, Tuple{Any, StaticArraysCore.SVector{N, T}, Any}} where {N, T}","page":"Library Reference","title":"GAIO.sample_adaptive","text":"sample_adaptive(Df, center::SVector, accel=nothing)\n\nCreate a grid of test points using the adaptive technique  described in \n\nOliver Junge. “Rigorous discretization of subdivision techniques”. In:  International Conference on Differential Equations. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.subdivide!-Union{Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T}, Tuple{Int64, Int64}}} where {N, T}","page":"Library Reference","title":"GAIO.subdivide!","text":"subdivide!(tree:TreePartition), key::NTuple{2,<:Integer}) -> TreePartition\nsubdivide!(boxset::BoxSet{<:Any,<:Any,<:TreePartition}, key::NTuple{2,<:Integer}) -> BoxSet\n\nSubdivide a TreePartition at the node key. Dimension along which  the node is subdivided depends on the depth of the node. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}} where {B, P<:TreePartition, S}","page":"Library Reference","title":"GAIO.subdivide","text":"subdivide(B::BoxSet{<:Any,<:Any,<:TreePartition}) -> BoxSet\n\nBisect every box in boxset along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.unsafe_point_to_ints-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}","page":"Library Reference","title":"GAIO.unsafe_point_to_ints","text":"unsafe_point_to_ints(P::BoxPartiton, point)\n\nFind the cartesian index for the box within a  BoxPartition containing a point.\n\ndanger: bounds checking\nunsafe_point_to_ints does not do any bounds checking. The returned  cartesian index will be out of bounds if the point does not lie in the  partition. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.unstable_set!-Tuple{BoxMap, BoxSet}","page":"Library Reference","title":"GAIO.unstable_set!","text":"unstable_set!(F::BoxMap, B::BoxSet) -> BoxSet\n\nCompute the unstable set for a box set B. Generally, B should be  a small box surrounding a fixed point of F. The partition should  be fine enough, since no subdivision occurs in this algorithm. \n\n\n\n\n\n","category":"method"},{"location":"library_reference/#GAIO.vertices-Union{Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}","page":"Library Reference","title":"GAIO.vertices","text":"vertices(box)\nvertices(center, radius)\n\nReturn an iterator over the vertices of a box = Box(center, radius). \n\n\n\n\n\n","category":"method"},{"location":"algorithms/#Algorithms-and-Mathematical-Background","page":"Algorithms","title":"Algorithms and Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"note: Note\nIn the following, let Q subset mathbbR^d be compact. Further, f  mathbbR^d to mathbbR^d will always refer to the map describing the dynamics of a system, while F will be the corresponding BoxMap.","category":"page"},{"location":"algorithms/#Mapping-Boxes","page":"Algorithms","title":"Mapping Boxes","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The following algorithms all require a method to approximate the set-wise image f(b) of a box b. To do this, GAIO.jl splits the domain Q into a partition P of boxes, and uses test points within b. When a SampledBoxMap is initialized, we require a function to calculate test points that are mapped by f. This function is stored in the field F.domain_points. These test points are then mapped forward by f, and the boxes which are hit become the image set. More precisely, mapping a box set is done in two main steps within GAIO.jl: ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Test points within the box are generated (or retrieved) using F.domain_points(b.center, b.radius). These test points are mapped forward by the given function f.\nFor each mapped test point fp, an optional set of ”perturbations” are generated using F.image_points(fp, b.radius). For each of the perturbed points, the index of the box within the partition containing this point is calculated. This index gets added to the image set.","category":"page"},{"location":"algorithms/#Implementation","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function map_boxes(F::BoxMap, source::BoxSet{B,Q,S}) where {B,Q,S}\n    P = source.partition\n    @floop for box in source\n        c, r = box.center, box.radius\n        for p in F.domain_points(c, r)\n            fp = F.map(p)\n            hitbox = point_to_box(P, fp)\n            isnothing(hitbox) && continue\n            r = hitbox.radius\n            for ip in F.image_points(fp, r)\n                hit = point_to_key(P, ip)\n                isnothing(hit) && continue\n                @reduce(image = union!(S(), hit))\n            end\n        end\n    end\n    return BoxSet(P, image)\nend ","category":"page"},{"location":"algorithms/#Relative-Global-Attractor","page":"Algorithms","title":"Relative Global Attractor","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-2","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The set ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"A_Q = bigcap_k geq 0 f^k(Q)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"is called the global attractor relative to Q. The relative global attractor can be seen as the set which is eventually approached by every orbit originating in Q. In particular, A_Q contains each invariant set in Q and therefore all the potentially interesting dynamics.  The idea of the algorithm is to cover the relative global attractor with boxes and recursively tighten the covering by refining appropriately selected boxes.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Mathematically, the algorithm to compute the global attractor relative to Q takes two input arguments: a compact set Q as well as a map f, which describes the dynamics. Now in each iteration, two steps happen:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: All those boxes b in the new box set B whose image does not intersect the domain, ie f(b) cap left( bigcup_b in B b right) neq emptyset, get discarded. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If we repeatedly refine the box set B through k subdivision steps, then as k to infty the collection of boxes B converges to the relative global attractor A_Q in the Hausdorff metric.","category":"page"},{"location":"algorithms/#Implementation-2","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function relative_attractor(F::BoxMap, B::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    for k = 1:steps\n        B = subdivide(B, (k % N) + 1)\n        B = B ∩ F(B)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The third input parameter steps describes the level of approximation. Since in each step of the algorithm the initial domain is divided in half, the final partition after steps many steps will contain n = 2^textdepth boxes, i.e. every box in the final covering is frac1n times the size of the initial box.  For this algorithm the box set should be the full partition of the set Q. ","category":"page"},{"location":"algorithms/#Unstable-Set","page":"Algorithms","title":"Unstable Set","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In the following we are presenting the algorithm to cover invariant manifolds within some domain Q, which has to contain a fixed point.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"note: Note\nFor simplicity, we will explain the algorithm for the case of the unstable manifold. However one can compute the stable manifold as well by considering the boxmap describing the inverse map f^-1 as input argument for the algorithm.","category":"page"},{"location":"algorithms/#Mathematical-Background-3","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The unstable manifold is defined as","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"W^U(x_0) = x lim_k to - infty f^k(x) = x_0 ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where x_0 is a fixed point of f.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The idea behind the algorithm to compute the unstable manifold can be explained in two steps. Before starting we need to identify a hyperbolic fixed point and the region Q, which we are going to compute the manifold in. The region Q needs to be already partitioned into small boxes.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"initialization step Since a fixed point is always part of the unstable manifold, we need to identify a small region/box containing this fixed point. This box may be known a-priori, or one can use the relative_attractor around a region where one suspects a fixed point to exist. \ncontinuation step The small box containing the fixed point is then mapped forward by F and the boxes that are hit under the image are added to the box collection. Then those newly included boxes are mapped forward and the procedure is repeated until no new boxes are added. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"warning: Note on Convergence\nOne might not be able to compute the parts of the unstable manifold whose preimage lies outside the domain Q. Thus, it is important to choose Q large enough.","category":"page"},{"location":"algorithms/#Implementation-3","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function unstable_set!(F::BoxMap, B::BoxSet)\n    B_new = B\n    while !isempty(B_new)\n        B_new = F(B_new)\n        setdiff!(B_new, B)\n        union!(B, B_new)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The input argument B includes two things:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The domain Q we are going to compute the unstable manifold in (Q can be implemented as a large Box) and the underlying partition of the domain. Unlike in the previous algorithm, the domain will not be subdivided along the algorithms course, but we need to pass a partition which is already subdivided to the depth d (and therefore the level of accuracy) we want our final boxcovering to have. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Note: This algorithm works with two mutable sets of boxes: B, which collects the boxes we aquire in each iteration and will eventually cover part of the unstable manifold, and B_new, which will be overwritten in each iteration and contains only the boxes which will be newly added to our collection.","category":"page"},{"location":"algorithms/#Chain-Recurrent-Set","page":"Algorithms","title":"Chain Recurrent Set","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-4","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The chain recurrent set over Q R_Q is defined as the set of all x_0 in Q such that for every epsilon  0 there exists a set ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"left x_0 x_1 x_2 ldots x_n-1 right subset Q quad textwith quad  f(x_i  textmod  n) - x_i+1  textmod  n   epsilon  textfor all  i","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The chain recurrent set describes \"arbitrarily small perturbations\" of periodic orbits. This definition is useful since our box coverings our finite and hence inherently slightly uncertain. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The idea for the algorithm is to construct a directed graph G whose vertices are the box set B, and for which edges are drawn from B_1 to B_2 if f(B_1) cap B_2 neq emptyset. We can now ask for a subset of the vertices, for which each vertex is part of a directed cycle. This set is equivalent to the strongly connected subset of G. We therefore perform two steps: ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"subdivision step The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \ngraph construction step Generate the graph G. This is done by generating the transition matrix over B (see the next algorithm) and noting the nonzero elements. This is the adjacency matrix for the graph G. \nselection step Find the strongly connected subset of G. Discard all vertices (boxes) which are not part of a strongly connected component. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If we repeadetly refine the strongly connected box set through k subdivision steps, then the algorithm converges to the chain recurrent set as k to infty in the Hausdorff metric. ","category":"page"},{"location":"algorithms/#Implementation-4","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function chain_recurrent_set(F::BoxMap, B::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)\n        P = TransferOperator(F, B)\n        G = Graph(P)\n        B = strongly_connected_components(G)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/#Transfer-Operator","page":"Algorithms","title":"Transfer Operator","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-5","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The transition matrix is the discretization of the transfer operator P w.r.t. f. Formally, the transfer operator w.r.t. f is defined for measurable functions g implicitly through the integral equation","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"int_A Pg (x)  dmu (x) = int_f^-1(A) g(x)  dmu (x) quad textfor any   A   textmeasurable","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"We will use a Galerkin approximation for P which maintains the eigenvalues and cyclic behavior of P. To do this, we project to a subspace chi_B generated by the basis left chi_b vert b in B right  of indicator functions on the boxes of our box set. Further, we enumerate the partition P = {b_1, b_2, ..., b_n} with integer indices and define the transition matrix ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"    (P^n)_ij = fracmathcalLleft(b_j cap f^-1(b_i)right)mathcalL(b_j) quad i j = 1 ldots n","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where mathcalL is the lebesque measure. Finally, we define the approximate transfer operator Q_n P  chi_B to chi_B as the linear extension of ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"    (Q_n P) chi_b_i = sum_j = 1^n P_ij^n chi_b_j quad i = 1 ldots n","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The operator Q_n P can be created in GAIO.jl by calling ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"T = TransferOperator(F, B)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where F is a BoxMap and B is a box set. T acts as a matrix in every way, but the explicit transition matrix P^n_ij can be generated by calling ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"M = sparse(T)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"To realize this approximation, we need to calculate P^n_ij. For this there are two techniques discussed in [1]. The simpler of the two techniques is a Monte-Carlo approach. Namely, we choose a fixed number r of test points in one of the boxes b_j, and set P^n_ij as the fraction of test points which land in b_i. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"It is important to note that TranferOperator is only supported over the box set B, but if one lets a TranferOperator act on a BoxFun (see general), then the support B is extended \"on the fly\" to include the support of the BoxFun.","category":"page"},{"location":"algorithms/#Implementation-5","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"const plusmerge! = mergewith!(+)\nfunction TransferOperator(\n        g::BoxMap, boxset::BoxSet{B,Q,S}\n    ) where {N,T,I,B,Q<:BoxPartition{N,T,I},S}\n\n    P = boxset.partition\n    D = Dict{Tuple{I,I},T}      # initialize a \"dict-of-keys\" sparse matrix\n    @floop for key in boxset.set\n        box = key_to_box(P, key)\n        c, r = box.center, box.radius\n        domain_points = g.domain_points(c, r)\n        inv_n = 1. / length(domain_points)\n        for p in domain_points\n            c = g.map(p)\n            hitbox = point_to_box(P, c)\n            isnothing(hitbox) && continue\n            r = hitbox.radius\n            for ip in g.image_points(c, r)\n                hit = point_to_key(P, ip)\n                isnothing(hit) && continue\n                @reduce(mat = plusmerge!(D(), D((key,hit) => inv_n)))\n            end\n        end\n    end\n    matcsc = sparse(mat, length(P), length(P))      # convert to \"compressed sparse column\" format\n    return TransferOperator(g, boxset, matcsc)\nend","category":"page"},{"location":"algorithms/#Root-Covering","page":"Algorithms","title":"Root Covering","text":"","category":"section"},{"location":"algorithms/#Mathematical-Background-6","page":"Algorithms","title":"Mathematical Background","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Nonlinear optimization theory offers a multitude of algorithms to iteratively approximate roots of functions h  mathbbR^d to mathbbR^d, that is, algorithms f  mathbbR^d to mathbbR^d such that (under some conditions) f^k (x) to x_0 as k to infty with h(x_0) = mathbf0. We can consider these algorithms from the point of view of dynamics, and reframe the problem of finding a root of h to finding a fixed point of f. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Specifically, we will consider f to be a globalized Newton algorithm. One step of the (local) Newton algorithm follows the specification: solve the linear equation ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"J_h (x) d = - h(x)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"and set ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f(x) = x + d ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"where J_h (x) is the Jacobi matrix of h at x. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The local Newton algorithm is not guaranteed to converge to a global solution to h(x) = 0. To rectify this, the step size  d  and direction d   d  need to be modified. There are multiple heuristics to do this, and GAIO.jl uses the \"Armijo rule\": fix some sigma  1 and find the largest alpha leq 1 such that ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"h(x + alpha d) - h(x) leq alpha sigma  J_h (x)^T d","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"This is done by initializing alpha = 1 and testing the above condition. If it is not satisfied, scale alpha by some constant rho, ie set alpha = rho cdot alpha, and test the condition again. GAIO.jl uses sigma = 10^-4 and rho = 4  5. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Using this iterative solver, one can follow a technique very similar to the algorithm for the realtive attractor. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"subdivision step: The box set B is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in B. \nselection step: The box set B is mapped forward using one step of the adaptive newton algorithm. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"If we repeadetly refine the box set B through k subdivision steps, then as k to infty the collection of boxes converges to the set of roots of h in the Hausdorff metric. ","category":"page"},{"location":"algorithms/#Implementation-6","page":"Algorithms","title":"Implementation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"function cover_roots(h, Dh, B::BoxSet{Box{N,T}}; steps=12) where {N,T}\n    domain = B.partition.domain\n    for k in 1:steps\n        B = subdivide(B, (k % N) + 1)\n        f = x -> adaptive_newton_step(h, Dh, x, k)\n        F = BoxMap(f, domain)\n        B = F(B)\n    end\n    return B\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The arguments needed are the map h, some approximation of the Jacobian J_h which we call Dh, and a box set B containing some root of h. ","category":"page"},{"location":"algorithms/#Finite-Time-Lyapunov-Exponents","page":"Algorithms","title":"Finite Time Lyapunov Exponents","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"(TODO)","category":"page"},{"location":"algorithms/#References","page":"Algorithms","title":"References","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"[1] Michael Dellnitz, Oliver Junge, and Gary Froyland. “The Algorithms Behind GAIO - Set Oriented Numerical Methods for Dynamical Systems”. In: Ergodic Theory,Analysis, and Efficient Simulations of Dynamical Systems. Ed. by Bernold Fiedler.Springer Berlin, 2001, pp. 145–174. doi: https://doi.org/10.1007/3-540-35593-6. ","category":"page"}]
}
