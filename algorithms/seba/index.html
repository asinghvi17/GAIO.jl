<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extracting Multiple Sets via SEBA · GAIO.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GAIO.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting started</a></li><li><a class="tocitem" href="../../general/">General usage</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../coherent/">Coherent Sets</a></li><li class="is-active"><a class="tocitem" href>Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../root_covering/">Root Covering</a></li><li><a class="tocitem" href="../implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../../simd/">Using the CPU</a></li><li><a class="tocitem" href="../../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../../examples/">Other Examples</a></li><li><a class="tocitem" href="../../library_reference/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Transfer- and Koopman Operators</a></li><li class="is-active"><a href>Extracting Multiple Sets via SEBA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extracting Multiple Sets via SEBA</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/algorithms/seba.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Eigenbasis-Approximation-(SEBA)"><a class="docs-heading-anchor" href="#Sparse-Eigenbasis-Approximation-(SEBA)">Sparse Eigenbasis Approximation (SEBA)</a><a id="Sparse-Eigenbasis-Approximation-(SEBA)-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Eigenbasis-Approximation-(SEBA)" title="Permalink"></a></h1><h3 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h3><p>A common use pattern in GAIO.jl is to construct the transfer operator (or related operators), and then investigate the eigenfunctions for some specific structure. This may be e.g. partitioning the state space based on the result of the second leading eigenvector to find almost invariant sets. A common approach is to use <span>$k$</span>-means, though this may not be entirely sufficient. The method of Froyland et. al. [1] attempts to find a sparse basis that approximately spans the one produced by a set of eigenvalues. </p><p>More specifically: denote some eigenvalues <span>$\lambda_1 \geq \ldots \geq \lambda_r$</span> and corresponding eigenvectors <span>$v_1, \ldots, v_r \in \mathbb{R}^d$</span> (typically <span>$r \ll p$</span>) of a data matrix. We write <span>$V = [v_1 \vert \ldots \vert v_r]$</span>. In the context of GAIO.jl this matrix may be the discretized transfer operator. The eigenvectors span a basis <span>$\mathcal{V} \subset \mathbb{R}^p$</span>. We wish to transform this basis into a basis of sparse vectors <span>$s_1, \ldots, s_r \in \mathbb{R}^p$</span> that span a subspace <span>$\mathcal{S} \approx \mathcal{V}$</span>. Mathematically, this can be formulated as solving the optimization problem</p><p class="math-container">\[\underset{S, R}{\mathrm{arg\,min}}\ \frac{1}{2} \| V - S R \|_F^2 + \mu \| S \|_{1,1}\]</p><p>where <span>$S \in \mathbb{R}^{n \times p}$</span> has <span>$\ell_2$</span> norm in each column, <span>$R \in \mathbb{R}^{r \times r}$</span> is orthogonal, and <span>$\mu &gt; 0$</span> is a penalty term. <span>$\| \cdot \|_F$</span> denotes the Frobenius norm and <span>$\| \cdot \|_{1,1}$</span> the element sum norm. </p><p>Solving this problem for <span>$S = [s_1 \vert \ldots \vert s_r]$</span> is done by the SEBA algorithm [1], (which is based on sparse principal component analysis by rotation and truncation - <em>SPCArt</em> [2]). At this point, most of the work is finished. Indeed, one may be satisfied with the sparse basis alone. However, recall that the goal is to <em>partition</em> the state space into sets based on the eigenvalues. Hence the final step is to threshhold the sparse vectors to fix which indices are in or out of a feature, that is, find an appropriate <span>$\tau$</span> and set <code>S[S .≤ τ] .= 0</code> such that the least infomation is lost. For this, three heuristics are offered by GAIO.jl:</p><ul><li>Maximum likelihood partition (without threshholding): For each feature (each row) <span>$i$</span>, set <span>$S_{ij} = 0$</span> for all <span>$j$</span> except <span>$j_0 = \underset{j}{\mathrm{arg\,min}}\ S_{ij}$</span>. </li><li>Hard partition: For each feature (each row) <span>$i$</span>, write the values <span>$s_{i1}, \ldots, s_{ir}$</span> of <span>$S_{i\cdot}$</span> in decreasing order. Choose the threshhold <span>$\tau^{dp} = \underset{1 \leq i \leq p}{\mathrm{max}}\ s_{i2}$</span>, i.e. the maximum over the <em>second largest</em> element of each row. Set <code>S[S .≤ τ] .= 0</code>. </li><li>Partition of unity: For each feature (each row) <span>$i$</span>, write the values <span>$s_{i1}, \ldots, s_{ir}$</span> of <span>$S_{i\cdot}$</span> in decreasing order. Choose the threshhold <span>$\tau^{pu} = \underset{1 \leq i \leq p,\  1 \leq j \leq r}{\mathrm{max}} \left\{ s_{ij} \vert \sum_{k=1}^j s_{ik} &gt; 1 \right\}$</span>, i.e. the minimum threshhold such that all rows sum to less than <span>$1$</span>. Set <code>S[S .≤ τ] .= 0</code>. </li></ul><p>Note that the final heuristic does not return a strict partition of the features, but rather a partition of unity. </p><p>By default when calling GAIO.jl&#39;s <code>seba</code>, hard partitioning is performed. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.seba" href="#GAIO.seba"><code>GAIO.seba</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seba(V::Vector{&lt;:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -&gt; S, A</code></pre><p>Construct a sparse eigenbasis approximation of <code>V</code>, as described in  [1]. Returns an <code>Array</code> of <code>BoxFun</code>s corresponding to the eigenbasis,  as well as a maximum-likelihood <code>BoxFun</code> that maps a box to the  element of <code>S</code> which has the largest value over the support. </p><p>The keyword <code>which</code> is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are</p><pre><code class="language-julia hljs">partition_unity, partition_disjoint, partition_likelihood</code></pre><p>which are all exported functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/algorithms/seba.jl#L1-L16">source</a></section><section><div><pre><code class="language-julia hljs">seba(V::Matrix{&lt;:Real}, Rinit=nothing, maxiter=5000) -&gt; S, R</code></pre><p>Construct a sparse approximation of the basis <code>V</code>, as described in  [1]. Returns matrices <span>$S$</span>, <span>$R$</span> such that</p><p class="math-container">\[\frac{1}{2} \| V - SR \|_F^2 + \mu \| S \|_{1,1}\]</p><p>is minimized, where <span>$\mu \in \mathbb{R}$</span>, <span>$\| \cdot \|_F$</span> is the Frobenuius-norm,  and <span>$\| \cdot \|_{1,1}$</span> is the element sum norm, and <span>$R$</span>  is orthogonal. See [1] for further information on the argument  <code>Rinit</code>, as well as a description of the algorithm. </p><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/algorithms/seba.jl#L70-L89">source</a></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>We will continue using the periodically driven double-gyre introduced in the section on <a href="../almost_invariant/#Almost-Invariant-(metastable)-Sets">Almost Invariant (metastable) Sets</a>. See that code block for the definition of the map. </p><pre><code class="language-julia hljs">t₀, τ, steps = 0, 0.1, 20
t₁ = t₀ + τ * steps
Tspan = t₁ - t₀
Φₜ₀ᵗ¹(z) = Φ(z, t₀, τ, steps)

domain = Box((1.0, 0.5), (1.0, 0.5))
P = BoxPartition(domain, (256, 128))
S = cover(P, :)

F = BoxMap(:montecarlo, Φₜ₀ᵗ¹, domain, n_points=32)

T = TransferOperator(F, S, S)

# we give Arpack some help converging to the eigenvalues,
# see the Arpack docs for explanations of keywords
tol, maxiter, v0 = eps()^(1/4), 1000, ones(size(T, 2))
λ, ev = eigs(T; nev=2, which=:LR, maxiter=maxiter, tol=tol, v0=v0)

μ = abs ∘ ev[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BoxFun in 256 x 128 - element BoxPartition with 32768 stored weights</code></pre><pre><code class="language-julia hljs">using Plots

p = plot(μ, colormap=:jet);</code></pre><p><img src="../second_eigvec.svg" alt="Second egienvector of the transfer operator"/></p><p>We notice there are two &quot;blobs&quot; defining the second eigenmeasure. These correspond to the almost invariant sets; there are two &quot;vortices&quot; where mass flows in a circular pattern and doesn&#39;t mix with the rest of the domain. We wish to isolate these blobs using <code>seba</code></p><pre><code class="language-julia hljs"># seba expects real numbers, ev is complex, so we grab the real components.
# We also potentially have to scale by -1, this depends on what Arpack
# returns so always try both
re_ev = real .∘ (-1 .* ev)

ev_seba, feature_vec = seba(re_ev, which=partition_unity)
μ1, μ2 = ev_seba[1], ev_seba[2]

S1 = BoxSet(P, Set(key for key in keys(μ1) if μ1[key] &gt; 0.01))
S2 = BoxSet(P, Set(key for key in keys(μ2) if μ2[key] &gt; 0.01))


p = plot(S1, xlims=(0,2), ylims=(0,1), color=:red);
p = plot!(p, S2, color=:blue);</code></pre><p><img src="../seba.svg" alt="Almost invriant sets isolated by SEBA"/></p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou. Sparse eigenbasis approximation: multiple feature extraction across spatiotemporal scales with application to coherent set identification. Communications in Nonlinear Science and Numerical Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p><p>[2] Z. Hu, G. Pan, Y. Wang, and Z. Wu. Sparse principal component analysis via rotation and truncation. IEEE Transactions on Neural Networks and Learning Systems, 27(4):875–890, 2016.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../coherent/">« Coherent Sets</a><a class="docs-footer-nextpage" href="../box_dimension/">Fractal Dimension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 19 December 2023 14:17">Tuesday 19 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
