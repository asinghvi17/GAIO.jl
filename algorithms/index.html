<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Mapping-Boxes"><span>Mapping Boxes</span></a></li><li><a class="tocitem" href="#Relative-Global-Attractor"><span>Relative Global Attractor</span></a></li><li><a class="tocitem" href="#Unstable-Set"><span>Unstable Set</span></a></li><li><a class="tocitem" href="#Chain-Recurrent-Set"><span>Chain Recurrent Set</span></a></li><li><a class="tocitem" href="#Transfer-Operator"><span>Transfer Operator</span></a></li><li><a class="tocitem" href="#Root-Covering"><span>Root Covering</span></a></li><li><a class="tocitem" href="#Finite-Time-Lyapunov-Exponents"><span>Finite Time Lyapunov Exponents</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms-and-Mathematical-Background"><a class="docs-heading-anchor" href="#Algorithms-and-Mathematical-Background">Algorithms and Mathematical Background</a><a id="Algorithms-and-Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-and-Mathematical-Background" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the following, let <span>$Q \subset \mathbb{R}^d$</span> be compact. Further, <span>$f : \mathbb{R}^d \to \mathbb{R}^d$</span> will always refer to the map describing the dynamics of a system, while <code>F</code> will be the corresponding <code>BoxMap</code>.</p></div></div><h2 id="Mapping-Boxes"><a class="docs-heading-anchor" href="#Mapping-Boxes">Mapping Boxes</a><a id="Mapping-Boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-Boxes" title="Permalink"></a></h2><h3 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h3><p>The following algorithms all require a method to approximate the set-wise image <span>$f(b)$</span> of a box <span>$b$</span>. To do this, GAIO.jl splits the domain <span>$Q$</span> into a partition <code>P</code> of boxes, and uses test points within <span>$b$</span>. When a SampledBoxMap is initialized, we require a function to calculate test points that are mapped by <span>$f$</span>. This function is stored in the field <code>F.domain_points</code>. These test points are then mapped forward by <span>$f$</span>, and the boxes which are hit become the image set. More precisely, mapping a box set is done in two main steps within GAIO.jl: </p><ol><li>Test points within the box are generated (or retrieved) using <code>F.domain_points(b.center, b.radius)</code>. These test points are mapped forward by the given function <code>f</code>.</li><li>For each mapped test point <code>fp</code>, an optional set of ”perturbations” are generated using <code>F.image_points(fp, b.radius)</code>. For each of the perturbed points, the index of the box within the partition containing this point is calculated. This index gets added to the image set.</li></ol><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><pre><code class="language-julia hljs"># wee need a small helper function because of 
# how julia dispatches on `union!`
⊔(set1::AbstractSet, set2::AbstractSet) = union!(set1, set2)
⊔(set1::AbstractSet, object) = union!(set1, (object,))

function map_boxes(F::BoxMap, source::BoxSet{B,Q,S}) where {B,Q,S}
    P = source.partition
    @floop for box in source
        c, r = box.center, box.radius
        for p in F.domain_points(c, r)
            fp = F.map(p)
            hitbox = point_to_box(P, fp)
            isnothing(hitbox) &amp;&amp; continue
            r = hitbox.radius
            for ip in F.image_points(fp, r)
                hit = point_to_key(P, ip)
                isnothing(hit) &amp;&amp; continue
                @reduce(image = S() ⊔ hit)
            end
        end
    end
    return BoxSet(P, image)
end </code></pre><h2 id="Relative-Global-Attractor"><a class="docs-heading-anchor" href="#Relative-Global-Attractor">Relative Global Attractor</a><a id="Relative-Global-Attractor-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-Global-Attractor" title="Permalink"></a></h2><h3 id="Mathematical-Background-2"><a class="docs-heading-anchor" href="#Mathematical-Background-2">Mathematical Background</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-2" title="Permalink"></a></h3><p>The set </p><p class="math-container">\[A_Q = \bigcap_{k \geq 0} f^k(Q)\]</p><p>is called the global attractor relative to <span>$Q$</span>. The relative global attractor can be seen as the set which is eventually approached by every orbit originating in <span>$Q$</span>. In particular, <span>$A_Q$</span> contains each invariant set in <span>$Q$</span> and therefore all the potentially interesting dynamics.  The idea of the algorithm is to cover the relative global attractor with boxes and recursively tighten the covering by refining appropriately selected boxes.</p><p>Mathematically, the algorithm to compute the global attractor relative to <span>$Q$</span> takes two input arguments: a compact set <span>$Q$</span> as well as a map <span>$f$</span>, which describes the dynamics. Now in each iteration, two steps happen:</p><ol><li><strong>subdivision step:</strong> The box set <code>B</code> is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in <code>B</code>. </li><li><strong>selection step:</strong> All those boxes <code>b</code> in the new box set <code>B</code> whose image does not intersect the domain, ie <span>$f(b) \cap \left( \bigcup_{b&#39; \in B} b&#39; \right) \neq \emptyset$</span>, get discarded. </li></ol><p>If we repeatedly refine the box set <code>B</code> through <span>$k$</span> subdivision steps, then as <span>$k \to \infty$</span> the collection of boxes <span>$B$</span> converges to the relative global attractor <span>$A_Q$</span> in the Hausdorff metric.</p><h3 id="Implementation-2"><a class="docs-heading-anchor" href="#Implementation-2">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">function relative_attractor(F::BoxMap, B::BoxSet{Box{N,T}}; steps=12) where {N,T}
    for k = 1:steps
        B = subdivide(B, (k % N) + 1)
        B = B ∩ F(B)
    end
    return B
end</code></pre><p>The third input parameter <code>steps</code> describes the level of approximation. Since in each step of the algorithm the initial domain is divided in half, the final partition after <code>steps</code> many steps will contain <span>$n := 2^{\text{depth}}$</span> boxes, i.e. every box in the final covering is <span>$\frac{1}{n}$</span> times the size of the initial box.  For this algorithm the box set should be the full partition of the set <span>$Q$</span>. </p><h2 id="Unstable-Set"><a class="docs-heading-anchor" href="#Unstable-Set">Unstable Set</a><a id="Unstable-Set-1"></a><a class="docs-heading-anchor-permalink" href="#Unstable-Set" title="Permalink"></a></h2><p>In the following we are presenting the algorithm to cover invariant manifolds within some domain <span>$Q$</span>, which has to contain a fixed point.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For simplicity, we will explain the algorithm for the case of the <em>unstable manifold</em>. However one can compute the stable manifold as well by considering the boxmap describing the inverse map <span>$f^{-1}$</span> as input argument for the algorithm.</p></div></div><h3 id="Mathematical-Background-3"><a class="docs-heading-anchor" href="#Mathematical-Background-3">Mathematical Background</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-3" title="Permalink"></a></h3><p>The unstable manifold is defined as</p><p class="math-container">\[W^U(x_0) = \{x: \lim_{k \to - \infty} f^k(x) = x_0 \}\]</p><p>where <span>$x_0$</span> is a fixed point of <span>$f$</span>.</p><p>The idea behind the algorithm to compute the unstable manifold can be explained in two steps. Before starting we need to identify a hyperbolic fixed point and the region <span>$Q$</span>, which we are going to compute the manifold in. The region <span>$Q$</span> needs to be already partitioned into small boxes.</p><ol><li><strong>initialization step</strong> Since a fixed point is always part of the unstable manifold, we need to identify a small region/box containing this fixed point. This box may be known a-priori, or one can use the <code>relative_attractor</code> around a region where one suspects a fixed point to exist. </li><li><strong>continuation step</strong> The small box containing the fixed point is then mapped forward by <code>F</code> and the boxes that are hit under the image are added to the box collection. Then those newly included boxes are mapped forward and the procedure is repeated until no new boxes are added. </li></ol><div class="admonition is-warning"><header class="admonition-header">Note on Convergence</header><div class="admonition-body"><p>One might not be able to compute the parts of the unstable manifold whose preimage lies outside the domain <span>$Q$</span>. Thus, it is important to choose <span>$Q$</span> large enough.</p></div></div><h3 id="Implementation-3"><a class="docs-heading-anchor" href="#Implementation-3">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">function unstable_set!(F::BoxMap, B::BoxSet)
    B_new = B
    while !isempty(B_new)
        B_new = F(B_new)
        setdiff!(B_new, B)
        union!(B, B_new)
    end
    return B
end</code></pre><p>The input argument <code>B</code> includes two things:</p><p>The domain <span>$Q$</span> we are going to compute the unstable manifold in (<span>$Q$</span> can be implemented as a large <code>Box</code>) and the underlying partition of the domain. Unlike in the previous algorithm, the domain will not be subdivided along the algorithms course, but we need to pass a partition which is already subdivided to the depth <span>$d$</span> (and therefore the level of accuracy) we want our final boxcovering to have. </p><p>Note: This algorithm works with two mutable sets of boxes: <code>B</code>, which collects the boxes we aquire in each iteration and will eventually cover part of the unstable manifold, and <code>B_new</code>, which will be overwritten in each iteration and contains only the boxes which will be newly added to our collection.</p><h2 id="Chain-Recurrent-Set"><a class="docs-heading-anchor" href="#Chain-Recurrent-Set">Chain Recurrent Set</a><a id="Chain-Recurrent-Set-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-Recurrent-Set" title="Permalink"></a></h2><h3 id="Mathematical-Background-4"><a class="docs-heading-anchor" href="#Mathematical-Background-4">Mathematical Background</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-4" title="Permalink"></a></h3><p>The <em>chain recurrent set over <span>$Q$</span></em> <span>$R_Q$</span> is defined as the set of all <span>$x_0 \in Q$</span> such that for every <span>$\epsilon &gt; 0$</span> there exists a set </p><p class="math-container">\[\left\{ x_0,\, x_1,\, x_2,\, \ldots,\, x_{n-1} \right\} \subset Q \quad \text{with} \quad \| f(x_{i \, \text{mod} \, n}) - x_{i+1 \, \text{mod} \, n} \| &lt; \epsilon \,\ \text{for all} \,\ i\]</p><p>The chain recurrent set describes &quot;arbitrarily small perturbations&quot; of periodic orbits. This definition is useful since our box coverings our finite and hence inherently slightly uncertain. </p><p>The idea for the algorithm is to construct a directed graph <span>$G$</span> whose vertices are the box set <span>$B$</span>, and for which edges are drawn from <span>$B_1$</span> to <span>$B_2$</span> if <span>$f(B_1) \cap B_2 \neq \emptyset$</span>. We can now ask for a subset of the vertices, for which each vertex is part of a directed cycle. This set is equivalent to the <em>strongly connected subset of <span>$G$</span></em>. We therefore perform two steps: </p><ol><li><strong>subdivision step</strong> The box set <code>B</code> is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in <code>B</code>. </li><li><strong>graph construction step</strong> Generate the graph <code>G</code>. This is done by generating the <em>transition matrix over <code>B</code></em> (see the next algorithm) and noting the nonzero elements. This is the (transposed) adjacency matrix for the graph <code>G</code>. </li><li><strong>selection step</strong> Find the strongly connected subset of <code>G</code>. Discard all vertices (boxes) which are not part of a strongly connected component. </li></ol><p>If we repeadetly refine the strongly connected box set through <span>$k$</span> subdivision steps, then the algorithm converges to the chain recurrent set as <span>$k \to \infty$</span> in the Hausdorff metric. </p><h3 id="Implementation-4"><a class="docs-heading-anchor" href="#Implementation-4">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-4" title="Permalink"></a></h3><pre><code class="language-julia hljs">function chain_recurrent_set(F::BoxMap, B::BoxSet{Box{N,T}}; steps=12) where {N,T}
    for k in 1:steps
        B = subdivide(B, (k % N) + 1)
        P = TransferOperator(F, B)
        G = Graph(P)
        B = strongly_connected_components(G)
    end
    return B
end</code></pre><h2 id="Transfer-Operator"><a class="docs-heading-anchor" href="#Transfer-Operator">Transfer Operator</a><a id="Transfer-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Transfer-Operator" title="Permalink"></a></h2><h3 id="Mathematical-Background-5"><a class="docs-heading-anchor" href="#Mathematical-Background-5">Mathematical Background</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-5" title="Permalink"></a></h3><p>The transition matrix is the discretization of the <em>transfer operator <span>$P$</span> w.r.t. <span>$f$</span></em>. Formally, the transfer operator w.r.t. <span>$f$</span> is defined for measurable functions <span>$g$</span> implicitly through the integral equation</p><p class="math-container">\[\int_A Pg (x) \, d\mu (x) = \int_{f^{-1}(A)} g(x) \, d\mu (x) \quad \text{for any} \ \ A \ \ \text{measurable}\]</p><p>We will use a Galerkin approximation for <span>$P$</span> which maintains the eigenvalues and cyclic behavior of <span>$P$</span>. To do this, we project to a subspace <span>$\chi_B$</span> generated by the basis <span>$\left\{ \chi_b\ \vert\ b \in B \right\}$</span>  of indicator functions on the boxes of our box set. Further, we enumerate the box set <code>B = {b_1, b_2, ..., b_n}</code> with integer indices and define the <em>transition matrix</em> </p><p class="math-container">\[    (P^n)_{ij} = \frac{\mathcal{L}\left(b_j \cap f^{-1}(b_i)\right)}{\mathcal{L}(b_j)}, \quad i,\, j = 1, \ldots, n,\]</p><p>where <span>$\mathcal{L}$</span> is the lebesque measure. Finally, we define the approximate transfer operator <span>$Q_n P : \chi_B \to \chi_B$</span> as the linear extension of </p><p class="math-container">\[    (Q_n P)\, \chi_{b_i} = \sum_{j = 1}^n P_{ij}^n\, \chi_{b_j}, \quad i = 1, \ldots, n.\]</p><p>The operator <span>$Q_n P$</span> can be created in GAIO.jl by calling </p><pre><code class="language-julia hljs">T = TransferOperator(F, B)</code></pre><p>where <code>F</code> is a <code>BoxMap</code> and <code>B</code> is a box set. <code>T</code> acts as a matrix in every way, but the explicit transition matrix <span>$P^n_{ij}$</span> can be generated by calling </p><pre><code class="language-julia hljs">M = sparse(T)</code></pre><p>To realize this approximation, we need to calculate <span>$P^n_{ij}$</span>. For this there are two techniques discussed in [1]. The simpler of the two techniques is a Monte-Carlo approach. Namely, we choose a fixed number <span>$r$</span> of test points in one of the boxes <span>$b_j$</span>, and set <span>$P^n_{ij}$</span> as the fraction of test points which land in <span>$b_i$</span>. </p><p>It is important to note that <code>TranferOperator</code> is only supported over the box set <code>B</code>, but if one lets a <code>TranferOperator</code> act on a <code>BoxFun</code> (see general), then the support <code>B</code> is extended &quot;on the fly&quot; to include the support of the <code>BoxFun</code>.</p><h3 id="Implementation-5"><a class="docs-heading-anchor" href="#Implementation-5">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-5" title="Permalink"></a></h3><pre><code class="language-julia hljs"># helper function so we aren&#39;t doing type piracy on `mergewith!`
⊔(d::AbstractDict...) = mergewith!(+, d...)

function construct_transfers(
        g::BoxMap, boxset::BoxSet{R,Q,S}
    ) where {N,T,R&lt;:Box{N,T},Q&lt;:BoxPartition,S&lt;:OrderedSet}

    P = boxset.partition
    D = Dict{Tuple{keytype(Q),keytype(Q)},T}    # &quot;dict-of-keys&quot; sparse matrix
    @floop for key in boxset.set
        box = key_to_box(P, key)
        c, r = box.center, box.radius
        domain_points = g.domain_points(c, r)
        inv_n = 1. / length(domain_points)
        for p in domain_points
            c = g.map(p)
            hitbox = point_to_box(P, c)
            isnothing(hitbox) &amp;&amp; continue
            r = hitbox.radius
            for ip in g.image_points(c, r)
                hit = point_to_key(P, ip)
                isnothing(hit) &amp;&amp; continue
                @reduce( mat = D() ⊔ D((hit,key) =&gt; inv_n) )

                # if `boxset` is not invariant, then the image of some 
                # boxes will lie outside of `boxset`. These &quot;variant&quot; 
                # image boxes need to be recorded.
                hit in boxset.set || @reduce( variant_keys = S() ⊔ hit )
            end
        end
    end
    return mat, variant_keys
end</code></pre><p>A note on the enumeration of the box set:</p><p>The astute reader may have taken notice of the line &quot;enumerate the box set <code>B = {b_1, b_2, ..., b_n}</code>&quot;. The base <code>Set</code> data structure does not guarantee a deterministic ordering, so we cannot just use the box set without any effort. Instead we use <code>OrderedSet</code> from <code>OrderedCollections.jl</code>. Internally an <code>OrderedSet</code> is just a regular array with a hash table built on top. In particular, the array is guaranteed to maintain the order of insertion. To access this internal array of partition-keys, one can call <code>boxset.set.dict.keys</code>. Using this knowledge we can convert between partition-keys and the index in the enumeration <code>B = {b_1, b_2, ..., b_n}</code> using the internal GAIO functions <code>GAIO.getkeyindex(boxset, partition_key)</code>, <code>GAIO.getindex_fromkeys(boxset, enumeration_index)</code>. </p><h2 id="Root-Covering"><a class="docs-heading-anchor" href="#Root-Covering">Root Covering</a><a id="Root-Covering-1"></a><a class="docs-heading-anchor-permalink" href="#Root-Covering" title="Permalink"></a></h2><h3 id="Mathematical-Background-6"><a class="docs-heading-anchor" href="#Mathematical-Background-6">Mathematical Background</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-6" title="Permalink"></a></h3><p>Nonlinear optimization theory offers a multitude of algorithms to iteratively approximate roots of functions <span>$h : \mathbb{R}^d \to \mathbb{R}^d$</span>, that is, algorithms <span>$f : \mathbb{R}^d \to \mathbb{R}^d$</span> such that (under some conditions) <span>$f^k (x) \to x_0$</span> as <span>$k \to \infty$</span> with <span>$h(x_0) = \mathbf{0}$</span>. We can consider these algorithms from the point of view of dynamics, and reframe the problem of finding a root of <span>$h$</span> to finding a fixed point of <span>$f$</span>. </p><p>Specifically, we will consider <span>$f$</span> to be a globalized Newton algorithm. One step of the (local) Newton algorithm follows the specification: solve the linear equation </p><p class="math-container">\[Dh (x) d = - h(x)\]</p><p>and set </p><p class="math-container">\[f(x) = x + d, \]</p><p>where <span>$Dh (x)$</span> is the Jacobi matrix of <span>$h$</span> at <span>$x$</span>. </p><p>The local Newton algorithm is not guaranteed to converge to a global solution to <span>$h(x) = 0$</span>. To rectify this, the step size <span>$\| d \|$</span> and direction <span>$d / \| d \|$</span> need to be modified. There are multiple heuristics to do this, and GAIO.jl uses the &quot;Armijo rule&quot;: fix some <span>$\sigma &lt; 1$</span> and find the largest <span>$\alpha \leq 1$</span> such that </p><p class="math-container">\[h(x + \alpha d) - h(x) \leq \alpha \sigma \, J_h (x)^T d.\]</p><p>This is done by initializing <span>$\alpha = 1$</span> and testing the above condition. If it is not satisfied, scale <span>$\alpha$</span> by some constant <span>$\rho$</span>, ie set <span>$\alpha = \rho \cdot \alpha$</span>, and test the condition again. GAIO.jl uses <span>$\sigma = 10^{-4}$</span> and <span>$\rho = 4 / 5$</span>. </p><p>Using this iterative solver, one can follow a technique very similar to the algorithm for the realtive attractor. </p><ol><li><strong>subdivision step:</strong> The box set <code>B</code> is subdivided once, i.e. every box is bisected along one axis, which gives rise to a new partition of the domain, with double the amount of boxes. This is saved in <code>B</code>. </li><li><strong>selection step:</strong> The box set <code>B</code> is mapped forward using one step of the adaptive newton algorithm. </li></ol><p>If we repeadetly refine the box set <code>B</code> through <span>$k$</span> subdivision steps, then as <span>$k \to \infty$</span> the collection of boxes converges to the set of roots of <code>h</code> in the Hausdorff metric. </p><h3 id="Implementation-6"><a class="docs-heading-anchor" href="#Implementation-6">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-6" title="Permalink"></a></h3><pre><code class="language-julia hljs">function cover_roots(h::Function, Dh::Function, B::BoxSet{Box{N,T}}; steps=12) where {N,T}
    domain = B.partition.domain
    for k in 1:steps
        B = subdivide(B, (k % N) + 1)
        f = x -&gt; adaptive_newton_step(h, Dh, x, k)
        F = BoxMap(f, domain)
        B = F(B)
    end
    return B
end</code></pre><p>The arguments needed are the map <code>h</code>, some approximation of the Jacobian <code>Dh</code>, and a box set <code>B</code> containing some root of <code>h</code>. </p><h2 id="Finite-Time-Lyapunov-Exponents"><a class="docs-heading-anchor" href="#Finite-Time-Lyapunov-Exponents">Finite Time Lyapunov Exponents</a><a id="Finite-Time-Lyapunov-Exponents-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Time-Lyapunov-Exponents" title="Permalink"></a></h2><h3 id="Mathematical-Background-7"><a class="docs-heading-anchor" href="#Mathematical-Background-7">Mathematical Background</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background-7" title="Permalink"></a></h3><p>We change focus now to a continuous dynamical system, e.g. an ODE <span>$\dot{u} = g(t, u)$</span> with solution <span>$\Phi^{t,t_0} (x)$</span>. Since <span>$\Phi^{t,t_0} (x)$</span> is continuously dependent on the initial condition <span>$x$</span>, there exists an <span>$\tilde{x}$</span> near <span>$x$</span> with <span>$sup_{t \in [t_0 , t_0 + T]} \| \Phi^{t,t_0} (\tilde{x}) - \Phi^{t,t_0} (x) \| &lt; \epsilon$</span> for any fixed <span>$\epsilon &gt; 0$</span> and <span>$T$</span> small enough. We wish to characterize this expansion term. We write <span>$y = x + \delta x_0$</span> where <span>$\delta x_0 \in \mathbb{R}^d$</span> is infinitesimal. Then if <span>$g$</span> is <span>$\mathcal{C}^1$</span> w.r.t. <span>$x$</span>,</p><p class="math-container">\[\delta x (t_0 + T) := \Phi^{t_0 + T, t_0} (y) - \Phi^{t_0 + T, t_0} (x)
= D_x \Phi^{t_0 + T, t_0} (x) \cdot \delta x_0 + \mathcal{O}(\| \delta x_0 \|^2)\]</p><p>Hence we can write </p><p class="math-container">\[\| \delta x (t_0 + T) \|_2 = \| D_x \Phi^{t_0 + T, t_0} (x) \cdot \delta x_0 \|_2 \leq \| D_x \Phi^{t_0 + T, t_0} (x) \|_2 \cdot \| \delta x_0 \|_2\]</p><p>or equivalently</p><p class="math-container">\[\frac{ \| \delta x (t_0 + T) \|_2 }{ \| \delta x_0 \|_2 } \leq \| D_x \Phi^{t_0 + T, t_0} (x) \|_2\]</p><p>where equality holds if <span>$\delta x_0$</span> is the eigenvector corresponding to the largest eigenvalue of </p><p class="math-container">\[\Delta = \left( D_x \Phi^{t_0 + T, t_0} (x) \right)^T \left( D_x \Phi^{t_0 + T, t_0} (x) \right) . \]</p><p>Hence if we define </p><p class="math-container">\[\sigma^{t_0 + T, t_0} (x) = \frac{1}{T} \ln \left( \sqrt{\lambda_{\text{max}}} (\Delta) \right) = \frac{1}{T} \ln \left( \sup_{\delta x_0} \frac{ \| \delta x (t_0 + T) \|_2 }{ \| \delta x_0 \|_2 } \right)\]</p><p>then </p><p class="math-container">\[\| \delta x (t_0 + T) \|_2 \leq e^{T \cdot \sigma^{t_0 + T, t_0} (x)} \cdot \| \delta x_0 \|_2 . \]</p><p>From this we see why <span>$\sigma^{t_0 + T, t_0} (x)$</span> is called the <em>maximal finite-time lyapunov exponent (FTLE)</em>. </p><p>The definition of <span>$\sigma^{t_0 + T, t_0} (x)$</span> leads to a natural <em>ansatz</em> for approximating the FTLE: compute <span>$\frac{1}{T} \ln \left( \sup_{\delta x_0} \frac{ \| \delta x (t_0 + T) \|_2 }{ \| \delta x_0 \|_2 } \right)$</span> for each of a set of test points <span>$\| \delta x_0 \|$</span> of fixed order <span>$\epsilon &gt; 0$</span> and set <span>$\sigma^{t_0 + T, t_0} (x)$</span> to be the maximum over this set of test points. </p><h3 id="Implementation-7"><a class="docs-heading-anchor" href="#Implementation-7">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-7" title="Permalink"></a></h3><p>We assume all boxes in the box set <code>B</code> have radii of order <span>$\epsilon$</span>, that is, all test points of order <span>$\epsilon$</span>. </p><pre><code class="language-julia hljs">function finite_time_lyapunov_exponents(F::BoxMap, B::BoxSet{R,Q,S}; T) where {N,V,R&lt;:Box{N,V},Q,S}
    P, D = B.partition, Dict{keytype(Q),Float}
    @floop for key in B.set
        box = key_to_box(P, key)
        c, r = box.center, box.radius
        fc = F.map(box.center)
        ftle = -Inf
        for p in F.domain_points(c, r)
            ϵ = norm(c .- p)
            fp = F.map(p)
            ftle_pot = log( norm(fc .- fp) / ϵ ) / abs(T)
            ftle = max(ftle, ftle_pot)
        end
        @reduce( vals = D() ⊔ (key =&gt; ftle) )
    end
    return BoxFun(B.partition, vals)
end</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Michael Dellnitz, Oliver Junge, and Gary Froyland. “The Algorithms Behind GAIO - Set Oriented Numerical Methods for Dynamical Systems”. In: <em>Ergodic Theory,Analysis, and Efficient Simulations of Dynamical Systems</em>. Ed. by Bernold Fiedler.Springer Berlin, 2001, pp. 145–174. doi: https://doi.org/10.1007/3-540-35593-6. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../general/">« General usage</a><a class="docs-footer-nextpage" href="../simd/">Using the CPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 30 November 2022 14:35">Wednesday 30 November 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
