<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General usage · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>General usage</a><ul class="internal"><li><a class="tocitem" href="#BoxPartition"><span>BoxPartition</span></a></li><li><a class="tocitem" href="#TreePartition"><span>TreePartition</span></a></li><li><a class="tocitem" href="#BoxSet"><span>BoxSet</span></a></li><li><a class="tocitem" href="#BoxMap"><span>BoxMap</span></a></li><li><a class="tocitem" href="#Using-BoxMap"><span>Using BoxMap</span></a></li><li><a class="tocitem" href="#TransferOperator"><span>TransferOperator</span></a></li><li><a class="tocitem" href="#BoxFun"><span>BoxFun</span></a></li><li><a class="tocitem" href="#BoxGraph"><span>BoxGraph</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../algorithms/chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>General usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/general.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The base of the numerical set oriented methods of this framework are <code>BoxSet</code> (the discretization of a set of boxes) and <code>BoxMap</code> (the discretization of a map). Thus, in the following, we will have a closer look at the two and other useful things to know when using GAIO.jl. </p><p>To create a <code>Box</code> given its center point <code>c = (c_1, c_2, ..., c_d)</code> as well as its &quot;radius&quot; in every axis direction <code>r = (r_1, r_2, ..., c_d)</code>, simply type </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GAIO</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = (0.5, 0.5), (0.5, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">((0.5, 0.5), (0.5, 0.5))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q = Box(c, r)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><p>This creates a set <span>$Q = [c_1 - r_1, c_1 + r_1), \times \ldots \times [c_d - r_d, c_d + r_d)$</span>. Conversely, one can get back the vectors <code>c</code> and <code>r</code> by calling</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c, r = Q</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.5, 0.5]
   radius: [0.5, 0.5]</code></pre><h2 id="BoxPartition"><a class="docs-heading-anchor" href="#BoxPartition">BoxPartition</a><a id="BoxPartition-1"></a><a class="docs-heading-anchor-permalink" href="#BoxPartition" title="Permalink"></a></h2><p>Most algorithms in GAIO.jl revolve around a partition of the domain <span>$Q$</span> into small boxes. To create an <span>$n_1 \times \ldots \times n_d$</span> - element equidistant grid of boxes, we can pass the tuple <span>$n = (n_1, \ldots, n_d)$</span> into the function <code>BoxPartition</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = (4, 2)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = BoxPartition(Q, n)</code><code class="nohighlight hljs ansi" style="display:block;">4 x 2 - element BoxPartition</code></pre><p><code>BoxPartition</code>s use a cartesian indexing structure to be memory-efficient. These indices are accessed and used through the API:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key = point_to_key(P, x)    # x is some point in the domain Q</code><code class="nohighlight hljs ansi" style="display:block;">(1, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = key_to_box(P, key)    # cover the point x with a box from P</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box = point_to_box(P, x)    # performs both above functions</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code></pre><h2 id="TreePartition"><a class="docs-heading-anchor" href="#TreePartition">TreePartition</a><a id="TreePartition-1"></a><a class="docs-heading-anchor-permalink" href="#TreePartition" title="Permalink"></a></h2><p>For partitions of <span>$Q$</span> into variably sized boxes, one can use <code>TreePartition</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P2 = TreePartition(Q)</code><code class="nohighlight hljs ansi" style="display:block;">TreePartition of depth 1</code></pre><p>A <code>TreePartition</code> uses a binary tree structure to store a partition of the domain. Every Box of a <code>TreePartition</code> can be split using the command </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(P2)</code><code class="nohighlight hljs ansi" style="display:block;">TreePartition of depth 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(P2)</code><code class="nohighlight hljs ansi" style="display:block;">TreePartition of depth 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subdivide!(P2)</code><code class="nohighlight hljs ansi" style="display:block;">TreePartition of depth 4</code></pre><p>The axis direction along which to subdivide cycles through with the depth, i.e. subdividing at depth 1 splits along dimension 1, subdividing at depth <code>d+1</code> splits along dimension 1 again. </p><p>The <code>TreePartition</code> created above is equivalent to a 4x2 <code>BoxPartition</code>. One can retrieve this using </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; P3 = BoxPartition(P2)</code><code class="nohighlight hljs ansi" style="display:block;">4 x 2 - element BoxPartition</code></pre><p><code>TreePartition</code>s use indices of the type <code>(depth, cartesian_index)</code> where <code>cartesian_index</code> is the equivalent index of a <code>BoxPartition</code> with the same size as a <code>TreePartition</code> subdivided <code>depth</code> times. In other words,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; key_to_box( P, (1, 1) ) == key_to_box( P2, (4, (1, 1)) )</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; key_to_box( P, (4, 2) ) == key_to_box( P2, (4, (4, 2)) )</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="BoxSet"><a class="docs-heading-anchor" href="#BoxSet">BoxSet</a><a id="BoxSet-1"></a><a class="docs-heading-anchor-permalink" href="#BoxSet" title="Permalink"></a></h2><p>The core idea behind GAIO.jl is to approximate a subset of the domain via a collection of small boxes. To construct <code>BoxSet</code>s, there are two main options: getting all boxes in the partition, or locating a box surrounding a point <span>$x \in Q$</span></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, x)    # one box surrounding the point x</code><code class="nohighlight hljs ansi" style="display:block;">1 - element BoxSet in 4 x 2 - element BoxPartition</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, :)    # set of all boxes in P</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxPartition</code></pre><p>One can also create a <code>Boxset</code> from an iterable of <code>Box</code>es. This will cover every element of the iterable with boxes from <code>P</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x1 = (0.2, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">(0.2, 0.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box1 = point_to_box(P, x1)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.125, 0.25]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x2 = (0.3, 0.6)</code><code class="nohighlight hljs ansi" style="display:block;">(0.3, 0.6)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; box2 = point_to_box(P, x2)</code><code class="nohighlight hljs ansi" style="display:block;">Box{2, Float64}:
   center: [0.375, 0.75]
   radius: [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, [box1, box2])</code><code class="nohighlight hljs ansi" style="display:block;">2 - element BoxSet in 4 x 2 - element BoxPartition</code></pre><p><code>BoxSet</code> is a highly memory-efficient way of storing boxes. However, should you want to access the boxes or their internal data, this can be done via iteration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for box in B
           center, radius = box
           # do something
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # get an array of boxes
       arr_of_boxes = collect(B)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Box{2, Float64}}:
 [0.0, 0.25) × [0.0, 0.5)
 [0.25, 0.5) × [0.5, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # get an array of box centers
       arr_of_centers = collect(box.center for box in B)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SVector{2, Float64}}:
 [0.125, 0.25]
 [0.375, 0.75]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # get an array of box radii
       arr_of_radii = collect(box.radius for box in B)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SVector{2, Float64}}:
 [0.125, 0.25]
 [0.125, 0.25]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # (memory-efficiently) create a matrix where each center is a column
       mat_of_centers = reinterpret(reshape, eltype(arr_of_centers[1]), arr_of_centers)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 reinterpret(reshape, Float64, ::Vector{SVector{2, Float64}}) with eltype Float64:
 0.125  0.375
 0.25   0.75</code></pre><h2 id="BoxMap"><a class="docs-heading-anchor" href="#BoxMap">BoxMap</a><a id="BoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMap" title="Permalink"></a></h2><p>A BoxMap is a function which maps boxes to boxes. Given a pointmap <code>f : ℝᵈ → ℝᵈ</code> which accepts an <code>SVector</code> from <code>StaticArrays.jl</code> (or just an <code>NTuple</code>) and returns the same, </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(u)   # the Baker transformation
           x, y = u
           if x &lt; 0.5
               (2x, y/2)
           else
               (2x - 1, y/2 + 1/2)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code></pre><p>initialize the corresponding <code>BoxMap</code> <code>F</code> by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = BoxMap(f, Q)</code><code class="nohighlight hljs ansi" style="display:block;">SampledBoxMap with 2 sample points</code></pre><p>This will generate a <code>BoxMap</code> which attempts to calculate setwise images of <code>f</code>. There are many types of <code>BoxMap</code> discretizations available, see the section on BoxMaps for more information. </p><h2 id="Using-BoxMap"><a class="docs-heading-anchor" href="#Using-BoxMap">Using BoxMap</a><a id="Using-BoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#Using-BoxMap" title="Permalink"></a></h2><p>Now, one can map a <code>BoxSet</code> via the <code>BoxMap</code> <code>F</code> by simply calling <code>F</code> as a function </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = F(B)</code><code class="nohighlight hljs ansi" style="display:block;">7 - element BoxSet in 4 x 2 - element BoxPartition</code></pre><p>where the output <code>C</code> is also a <code>BoxSet</code>.</p><p>For long running computations, GAIO.jl can also display a progress meter</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProgressMeter</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = F(B; show_progress = true)</code><code class="nohighlight hljs ansi" style="display:block;">7 - element BoxSet in 4 x 2 - element BoxPartition</code></pre><p>(Adding a progress meter adds a little bit of overhead, so for super short computations like the above it isn&#39;t recommended)</p><h2 id="TransferOperator"><a class="docs-heading-anchor" href="#TransferOperator">TransferOperator</a><a id="TransferOperator-1"></a><a class="docs-heading-anchor-permalink" href="#TransferOperator" title="Permalink"></a></h2><p>The <em>Perron-Frobenius operator</em> (or <em>transfer operator</em>) [2] is discretized in GAIO.jl using the <code>TransferOperator</code> type. To initialize a <code>TransferOperator</code> that acts on a subdomain of <span>$Q$</span>, type</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = cover(P, :)</code><code class="nohighlight hljs ansi" style="display:block;">8 - element BoxSet in 4 x 2 - element BoxPartition</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, B)   # T operates on the domain covered by the box set B</code><code class="nohighlight hljs ansi" style="display:block;">8 x 8 TransferOperator over 4 x 2 - element BoxPartition with 33 stored entries:

⎡⢿⣇⠶⠆⎤
⎣⠘⠛⠘⡿⎦</code></pre><p>In this case, the codomain is generated automatically. This is not always ideal (e.g. in eigenvalue calculations), so the codomain can be specified as the third argument</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, B, B)</code><code class="nohighlight hljs ansi" style="display:block;">8 x 8 TransferOperator over 4 x 2 - element BoxPartition with 33 stored entries:

⎡⢻⣧⠩⠥⎤
⎣⢤⣄⢤⣗⎦</code></pre><p>Again, a progress meter can be displayed for long computations</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ProgressMeter</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = TransferOperator(F, B, B; show_progress = true)</code><code class="nohighlight hljs ansi" style="display:block;">8 x 8 TransferOperator over 4 x 2 - element BoxPartition with 33 stored entries:

⎡⢻⣧⠩⠥⎤
⎣⢤⣄⢤⣗⎦</code></pre><p>To convert this to the underlying transfer matrix described in [3], one can simply call the <code>sparse</code> function from <code>SparseArrays</code> </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sparse(T)</code><code class="nohighlight hljs ansi" style="display:block;">8×8 SparseMatrixCSC{Float64, Int64} with 33 stored entries:
 0.333333  0.166667  0.166667   ⋅        0.5  0.25  0.214286    ⋅
 0.333333  0.166667  0.166667   ⋅         ⋅    ⋅     ⋅          ⋅
  ⋅        0.166667  0.166667  0.333333   ⋅   0.25  0.214286   0.428571
  ⋅        0.166667  0.166667  0.333333   ⋅    ⋅     ⋅          ⋅
  ⋅         ⋅         ⋅         ⋅         ⋅    ⋅    0.214286    ⋅
  ⋅         ⋅         ⋅         ⋅         ⋅    ⋅    0.214286   0.428571
 0.333333  0.166667  0.166667   ⋅        0.5  0.25  0.0714286   ⋅
  ⋅        0.166667  0.166667  0.333333   ⋅   0.25  0.0714286  0.142857</code></pre><p>To find an approximate invariant measure over <code>B</code> use the <code>eigs</code> function from <code>Arpack.jl</code>. All keyword arguments from <code>Arpack.eigs</code> are supported. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # for the Baker trafo, the Lebesgue measure
       # - i.e. the constant-weight measure - is invariant
       λ, ev = eigs(T);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{ComplexF64}:
   0.9999999999999991 + 0.0im
  0.49999999999999967 + 0.0im
 -0.37896131637649966 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ev</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{BoxFun{Box{2, Float64}, Tuple{Int64, Int64}, ComplexF64, BoxPartition{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, ComplexF64}}}:
 BoxFun in 4 x 2 - element BoxPartition with 8 stored weights
 BoxFun in 4 x 2 - element BoxPartition with 8 stored weights
 BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; μ = ev[1]   # ev is an array of measures, grab the first one</code><code class="nohighlight hljs ansi" style="display:block;">BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code></pre><p>This can also be done with the adjoint <em>Koopman operator</em> <code>T&#39;</code>. </p><h2 id="BoxFun"><a class="docs-heading-anchor" href="#BoxFun">BoxFun</a><a id="BoxFun-1"></a><a class="docs-heading-anchor-permalink" href="#BoxFun" title="Permalink"></a></h2><p>The return type of the second output of <code>eigs(T)</code> is a discretization of a measure over the domain. Specifically, it is a piecewise constant function defined on boxes in <code>B</code>, which is called a <code>BoxFun</code>. One can let <code>T</code> act on a <code>BoxFun</code> simply through multiplication</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T*μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code></pre><p>Of course, the same holds for the the Koopman operator as well. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν = T&#39;μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code></pre><p>Since a measure <span>$\mu$</span> is a function defined over measurable sets, composite measures <span>$g \circ \mu$</span> are well-defined for functions <span>$g : \mathbb{R} \to \mathbb{R}$</span> (or <span>$g : \mathbb{C} \to \mathbb{C}$</span>). This is supported in GAIO.jl for <code>BoxFuns</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; η = exp ∘ μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code></pre><p>For multiple BoxFuns, e.g. as the result of calling <code>eigs(T)</code>, the concatenation operator <code>∘</code> can be applied to each one using julia&#39;s broadcasting functionality</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; real_ev = real .∘ ev</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{BoxFun{Box{2, Float64}, Tuple{Int64, Int64}, Float64, BoxPartition{2, Float64, Int64}, OrderedCollections.OrderedDict{Tuple{Int64, Int64}, Float64}}}:
 BoxFun in 4 x 2 - element BoxPartition with 8 stored weights
 BoxFun in 4 x 2 - element BoxPartition with 8 stored weights
 BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code></pre><p>Similarly, finite signed measures can be given a vector space structure. This is also supported in GAIO.jl</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ν + μ</code><code class="nohighlight hljs ansi" style="display:block;">BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2ν - μ/2</code><code class="nohighlight hljs ansi" style="display:block;">BoxFun in 4 x 2 - element BoxPartition with 8 stored weights</code></pre><h2 id="BoxGraph"><a class="docs-heading-anchor" href="#BoxGraph">BoxGraph</a><a id="BoxGraph-1"></a><a class="docs-heading-anchor-permalink" href="#BoxGraph" title="Permalink"></a></h2><p>One could equivalently view the transfer operator as a weighted directed graph. That is, a transfer matrix in GAIO.jl is the (transposed) weighted adjacency matrix for a graph. This graph can be constructed using</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; G = Graph(T)</code><code class="nohighlight hljs ansi" style="display:block;">{8, 33} directed simple Int64 graph representation of TransferOperator</code></pre><p>The return type is a <code>BoxGraph</code>. <code>Boxgraph</code> is hooked into the <code>Graphs.jl</code> interface, which means all algorithms or etc. from Graphs.jl should work &quot;out of the box&quot;. To construct a BoxSet from some index / indices of vertices in a BoxGraph, call</p><pre><code class="language-julia hljs">BoxSet(G, vertex_index_or_indices)</code></pre><p>See the docstring for <code>BoxGraph</code> for details on how to translate between GAIO.jl and Graphs.jl. </p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>GAIO.jl offers both <code>Plots</code> or <code>Makie</code> for plotting. To plot a <code>BoxSet</code> or a <code>BoxFun</code>, simply choose either Plots or a Makie backend, eg. <code>GLMakie</code>, and call <code>plot</code> on a <code>BoxSet</code> or <code>BoxFun</code></p><pre><code class="language-julia hljs">using GLMakie: plot

plot(B)</code></pre><p>Plotting works with all the functionality of either package. This means you can set box plots as subplots, add colorbars, etc., using the Plots or Makie interface. For an example, see <code>examples/invariant_measure_2d.jl</code>. </p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.</p><p>[2] Andrzej Lasota and Michael C. Mackey. <em>Chaos, Fractals, and Noise. Stochastic Aspects of Dynamics</em>. Springer New York, NY, 1994. doi: https://doi.org/10.1007/978-1-4612-4286-4.</p><p>[3] Michael Dellnitz, Oliver Junge, and Gary Froyland. “The Algorithms Behind GAIO - Set Oriented Numerical Methods for Dynamical Systems”. In: <em>Ergodic Theory, Analysis, and Efficient Simulations of Dynamical Systems</em>. Ed. by Bernold Fiedler. Springer Berlin, 2001, pp. 145–174. doi: https://doi.org/10.1007/3-540-35593-6.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 19 December 2023 14:17">Tuesday 19 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
