<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../algorithms/chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/library_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><ul><li><a href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.Node"><code>GAIO.Node</code></a></li><li><a href="#Arpack.eigs-Tuple{TransferOperator, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a></li><li><a href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a></li><li><a href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a></li><li><a href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a></li><li><a href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a></li><li><a href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a></li><li><a href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a></li><li><a href="#GAIO.cover"><code>GAIO.cover</code></a></li><li><a href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a></li><li><a href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a></li><li><a href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a></li><li><a href="#GAIO.expon"><code>GAIO.expon</code></a></li><li><a href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a></li><li><a href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a></li><li><a href="#GAIO.index_pair-Tuple{BoxMap, BoxSet}"><code>GAIO.index_pair</code></a></li><li><a href="#GAIO.index_quad-Tuple{BoxMap, BoxSet}"><code>GAIO.index_quad</code></a></li><li><a href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a></li><li><a href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a></li><li><a href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a></li><li><a href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxFun}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxPartition}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.marginal-Tuple{BoxSet}"><code>GAIO.marginal</code></a></li><li><a href="#GAIO.maximal_backward_invariant_set"><code>GAIO.maximal_backward_invariant_set</code></a></li><li><a href="#GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_adjacencies</code></a></li><li><a href="#GAIO.morse_adjacencies_and_tiles-Tuple{TransferOperator}"><code>GAIO.morse_adjacencies_and_tiles</code></a></li><li><a href="#GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_component_map</code></a></li><li><a href="#GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}"><code>GAIO.morse_map</code></a></li><li><a href="#GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_tiles</code></a></li><li><a href="#GAIO.neighborhood-Tuple{BoxSet}"><code>GAIO.neighborhood</code></a></li><li><a href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a></li><li><a href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a></li><li><a href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a></li><li><a href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a></li><li><a href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}"><code>GAIO.seba</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a></li><li><a href="#GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.tree_search</code></a></li><li><a href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a></li><li><a href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a></li><li><a href="#GAIO.@save-Tuple{Any, Vararg{Any}}"><code>GAIO.@save</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}" href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain; no_of_points=ntuple(_-&gt;4, N)) -&gt; SampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>By default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated <code>BoxMap</code>s, uses a grid of test points by default. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.Node" href="#GAIO.Node"><code>GAIO.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Node structure used for <code>TreePartition</code>s</p><p>Fields:</p><ul><li><code>left</code> and <code>right</code> refer to indices w.r.t. </li></ul><p><code>trp.nodes</code> for a <code>TreePartition</code> <code>trp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}" href="#Arpack.eigs-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs-Tuple{TransferOperator, Any}" href="#Arpack.eigs-Tuple{TransferOperator, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}" href="#Arpack.eigs-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}, Any}"><code>Arpack.eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.svds-Tuple{TransferOperator}" href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}" href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(x-&gt;1, μ, B)</code></pre><p>Integrate a function <code>f</code> using <code>μ</code> as a density, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxfun.jl#L58-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:adaptive, f, domain::Box) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to  generate test points as described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap_sampled.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>n_points</code>, which is  a tuple of length equal to the dimension of the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap_sampled.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses <code>n_points</code>  Monte-Carlo test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap_sampled.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}" href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, map, domain, points) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap_sampled.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.adaptive_newton_step" href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_newton_step(g, g_jacobian, x, k=1)</code></pre><p>Return one step of the adaptive Newton algorithm for the point <code>x</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/optimization.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -&gt; Matrix</code></pre><p>Compute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies </p><p class="math-container">\[| f(x) - f(y) | \leq L | x - y | \quad \forall \, x,y \in \text{Box(center, radius)}\]</p><p>componentwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap_sampled.jl#L92-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.armijo_rule" href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)</code></pre><p>Find a step size multiplier <span>$\alpha \in (\alpha_0, \alpha_1]$</span>  such that </p><p class="math-container">\[g(x + \alpha d) - g(x) \leq \alpha \sigma \, Dg(x) \cdot d\]</p><p>This is done by initializing <span>$\alpha = 1$</span> and testing the  above condition. If it is not satisfied, scale <span>$\alpha$</span>  by some constant <span>$\rho &lt; 1$</span> (i.e. set  <span>$\alpha = \rho \cdot \alpha$</span>), and test the condition  again. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/optimization.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}" href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(P::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the partition. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_regular.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.box_dimension-Tuple{Any}" href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box_dimension(boxsets) -&gt; D</code></pre><p>For an iterator <code>boxsets</code> of (successively finer)  <code>BoxSet</code>s, compute the box dimension <code>D</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># F is some BoxMap, S is some BoxSet
box_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/scalar_diagnostics.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.center-Tuple{Any, Any}" href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(center, radius)</code></pre><p>Return the center of a box as an iterable.  Default function for <code>image_points</code> in <code>SampledBoxMap</code>s. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.center-Tuple{Box}" href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(b::Box)</code></pre><p>Return the center of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the chain recurrent set over the box set <code>B</code>.  <code>B</code> should be a (coarse) covering of the relative attractor,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/invariant_sets.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover" href="#GAIO.cover"><code>GAIO.cover</code></a> — <span class="docstring-category">Function</span></header><section><div><ul><li><code>BoxSet</code> constructors:<ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><code>julia   B = cover(P, :)</code><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><code>julia   B = cover(P, x)</code>    <ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><code>julia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)</code></li></ul><p>Return a subset of the partition or box set <code>P</code> based on the second argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxset.jl#L64-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}" href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_manifold(f, B::BoxSet; steps=12)</code></pre><p>Use interval arithmetic to compute a covering of  an implicitly defined manifold <span>$M$</span> of the form </p><p class="math-container">\[f(M) \equiv 0\]</p><p>for some function <span>$f : \mathbb{R}^N \to \mathbb{R}$</span>. </p><p>The starting BoxSet <code>B</code> should (coarsely) cover  the manifold. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/optimization.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_roots(g, Dg, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute a covering of the roots of <code>g</code> within the  partition <code>P</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie  <code>B = cover(P, :)</code>, and should contain a root of <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/optimization.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}" href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth(tree::TreePartition)</code></pre><p>Return the depth of the tree structure. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.expon" href="#GAIO.expon"><code>GAIO.expon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expon(h, k=1, ϵ=0.2, δ=0.1)</code></pre><p>Return a rough estimate of how many Newton steps  should be taken, given a step size h. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/optimization.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}" href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_at_depth(tree, depth)</code></pre><p>Return all node indices at a specified depth. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(f, Df, μ::BoxFun; n=8) -&gt; σ</code></pre><p>Compute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff&#39;s ergodic theorem. Computes </p><p class="math-container">\[\sigma_j = \frac{1}{n} \int \log R_{jj}( Df^n (x) ) \, dμ (x), \quad j = 1, \ldots, d\]</p><p>with respect to an ergodic invariant measure <span>$\mu$</span>. </p><p>[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/scalar_diagnostics.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -&gt; BoxFun</code></pre><p>Compute the Finite Time Lyapunov Exponent for  every box in <code>boxset</code>, where <code>F</code> represents a time-<code>T</code>  integration of some continuous dynamical system.  It is assumed that all boxes in <code>boxset</code> have radii  of some fixed order ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/scalar_diagnostics.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.fixqr!-Tuple{Any, Any}" href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixqr!(Q, R)</code></pre><p>Adjust a QR-decomposition such that the  R-factor has positive diagonal entries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/scalar_diagnostics.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hidden_keys(tree)</code></pre><p>Return all keys within the tree, including  keys not corresponding to leaf nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.index_pair-Tuple{BoxMap, BoxSet}" href="#GAIO.index_pair-Tuple{BoxMap, BoxSet}"><code>GAIO.index_pair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_pair(F::BoxMap, N::BoxSet) -&gt; (P₁, P₀)</code></pre><p>Compute an index pair of <code>BoxSet</code>s P₀ ⊆ P₁ ⊆ M where M = N ∪ nbhd(N). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/conley_index.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.index_quad-Tuple{BoxMap, BoxSet}" href="#GAIO.index_quad-Tuple{BoxMap, BoxSet}"><code>GAIO.index_quad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_quad(F::BoxMap, N::BoxSet) -&gt; (P₁, P₀, P̄₁, P̄₀)</code></pre><p>Compute a tuple of index pairs such that  <code>F: (P₁, P₀) → (P̄₁, P̄₀)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/conley_index.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.index_to_key-Tuple{AbstractArray, Any}" href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_to_key(iterable, i)</code></pre><p>Return the object held in the <code>i</code>th position of <code>iterable</code>.  Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L285-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_regular.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_index-Tuple{AbstractArray, Any}" href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_index(iterable, key)</code></pre><p>Find the index in <code>1..length(iterable)</code> which holds <code>key</code>,  or return <code>nothing</code>. Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/transfer_operator.jl#L269-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}" href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leaves(tree, initial_node_idx=1)</code></pre><p>Return the node indices of all leaves.  Begins search at <code>initial_node_idx</code>, i.e. only returns node indices of nodes below  <code>initial_node_idx</code> within the tree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L253-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.linreg-Tuple{Any, Any}" href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linreg(xs, ys)</code></pre><p>Simple one-dimensional lunear regression used to  approximate box dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/scalar_diagnostics.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxFun}" href="#GAIO.marginal-Tuple{BoxFun}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(μ::BoxFun{Box{N}}; dim) -&gt; BoxFun{Box{N-1}}</code></pre><p>Compute the marginal distribution of μ along an axis given by its dimension <code>dim</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxfun.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxPartition}" href="#GAIO.marginal-Tuple{BoxPartition}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(P::BoxPartition{N}; dim) -&gt; BoxPartition{N-1}</code></pre><p>Construct the projection of a <code>BoxPartition</code> along an axis given by  its dimension <code>dim</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_regular.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.marginal-Tuple{BoxSet}" href="#GAIO.marginal-Tuple{BoxSet}"><code>GAIO.marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marginal(B::BoxSet{Box{N}}; dim) -&gt; BoxSet{Box{N-1}}</code></pre><p>Construct the projection of the <code>BoxSet</code> along an axis given by  its dimension <code>dim</code>. This means that all boxes are projected to  dimension N-1. Overlapping boxes are counted only once. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxset.jl#L312-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.maximal_backward_invariant_set" href="#GAIO.maximal_backward_invariant_set"><code>GAIO.maximal_backward_invariant_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relative_attractor(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet
maximal_backward_invariant_set(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the attractor relative to <code>B</code>. <code>B</code> should be  a (coarse) covering of the relative attractor, e.g.  <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/invariant_sets.jl#L103-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}" href="#GAIO.morse_adjacencies-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_adjacencies</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a <code>strong_components_output</code> from <code>MatrixNetworks</code> (in particular  the component map) as well as the morse map (see <code>morse_map</code>), compute  the adjacency matrix for the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/morse_graph.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.morse_adjacencies_and_tiles-Tuple{TransferOperator}" href="#GAIO.morse_adjacencies_and_tiles-Tuple{TransferOperator}"><code>GAIO.morse_adjacencies_and_tiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a transfer operator (interpreted as a transfer graph),  compute the adjacency matrix for the mose graph as well as  the boxes representing the vertices for the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/morse_graph.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}" href="#GAIO.morse_component_map-Tuple{MatrixNetworks.Strong_components_output, Any}"><code>GAIO.morse_component_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Concatenation of the condensation map and morse map.  See <code>morse_map</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/morse_graph.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}" href="#GAIO.morse_map-Tuple{MatrixNetworks.Strong_components_output}"><code>GAIO.morse_map</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a <code>Strong_components_output</code> from <code>MatrixNetworks</code> (in particular  the component map), compute a second map on the vertices of the  condensation graph to the vertices of the morse graph. Vertices of the condensation graph which do not correspond to morse sets, get sent to the (arbitrary) vertex index 0.</p><pre><code class="nohighlight hljs"> origninal         condensation        morse
 graph             graph               graph

    * ──────┐
            │
    * ──────┴───────→ * ───────────────→ *

    * ──────────────→ * ───┐     ┌─────→ *
                           │     │
    * ──────────────→ * ───┴─────┼────→  0
                                 │
    * ─────┬────────→ * ─────────┘
           │
    * ─────┤
           │
    * ─────┘

    ⋮ ==============⟹ ⋮ ==============⟹ ⋮
        condensation        morse
        map                 map</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/morse_graph.jl#L16-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}" href="#GAIO.morse_tiles-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{BoxSet{R, Q, S}, AbstractVector}} where {R, Q, S&lt;:OrderedCollections.OrderedSet}"><code>GAIO.morse_tiles</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a transfer operator and a morse component map (see  <code>morse_component_map</code>), compute the boxes corresponding to the vertices  of the morse graph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/morse_graph.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.neighborhood-Tuple{BoxSet}" href="#GAIO.neighborhood-Tuple{BoxSet}"><code>GAIO.neighborhood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neighborhood(B::BoxSet) -&gt; BoxSet
nbhd(B::BoxSet) -&gt; BoxSet</code></pre><p>Return a one-box wide neighborhood of a BoxSet <code>B</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxset.jl#L284-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.nth_iterate_jacobian-NTuple{4, Any}" href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nth_iterate_jacobian(f, Df, x, n; return_QR=false) -&gt; Z[, R]</code></pre><p>Compute the Jacobian of the <code>n</code>-times iterated function  <code>f ∘ f ∘ ... ∘ f</code> at <code>x</code> using a QR iteration based on [1].  Requires an approximation <code>Df</code> of the jacobian of <code>f</code>, e.g.  <code>Df(x) = ForwardDiff.jacobian(f, x)</code>.  Optionally, return the QR decomposition. </p><p>[1] Dieci, L., Russell, R. D., Van Vleck, E. S.: &quot;On the  Computation of Lyapunov Exponents for Continuous Dynamical  Systems,&quot; submitted to SIAM J. Numer. Ana. (1993).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/scalar_diagnostics.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}" href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::AbstractBoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_regular.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_regular.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet, Q::BoxSet) -&gt; BoxSet</code></pre><p>Compute the (restricted to <code>Q</code>) preimage of <code>B</code> under <code>F</code>, i.e.</p><p class="math-container">\[F^{-1} (B) \cap Q . \]</p><p>Note that the larger <span>$Q$</span> is, the more calculation time required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/invariant_sets.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F^{-1} (B) \cap B . \]</p><p>Significantly faster than calling <code>preimage(F, B, B)</code>. </p><div class="admonition is-warning"><header class="admonition-header">This is not the entire preimage in the mathematical sense!</header><div class="admonition-body"><p><code>preimage(F, B)</code> computes the RESTRICTED preimage <span>$F^{-1} (B) \cap B$</span>, NOT the full preimage  <span>$F^{-1} (B)$</span>. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/invariant_sets.jl#L53-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.radius-Tuple{Box}" href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius(b::Box)</code></pre><p>Return the radius of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any, Any, Any}" href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(center, radius, points)</code></pre><p>Return an iterable which calls <code>rescale(center, radius, point)</code> for each point in <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any}" href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(points)</code></pre><p>Return a function </p><pre><code class="language-julia hljs">(center, radius) -&gt; rescale(center, radius, points)</code></pre><p>Used in <code>domain_points</code> for <code>BoxMap</code>, <code>PointDiscretizedMap</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L201-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(box, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})
rescale(center, radius, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})</code></pre><p>Scale a <code>point</code> within the unit box <span>$[-1, 1]^N$</span>  to lie within <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4-Tuple{Any, Any, Any}" href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rk4(f, x, τ)</code></pre><p>Compute one step with step size <code>τ</code> of the classic  fourth order Runge-Kutta method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/maps.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4_flow_map" href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rk4_flow_map(f, x, step_size=0.01, steps=20)</code></pre><p>Perform <code>steps</code> steps of the classic Runge-Kutta fourth order method, with step size <code>step_size</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/maps.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_adaptive(f, center::SVector, radius::SVector)</code></pre><p>Create a grid of test points using the adaptive technique  described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxmap_sampled.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seba(V::Matrix{&lt;:Real}, Rinit=nothing, maxiter=5000) -&gt; S, R</code></pre><p>Construct a sparse approximation of the basis <code>V</code>, as described in  [1]. Returns matrices <span>$S$</span>, <span>$R$</span> such that</p><p class="math-container">\[\frac{1}{2} \| V - SR \|_F^2 + \mu \| S \|_{1,1}\]</p><p>is minimized, where <span>$\mu \in \mathbb{R}$</span>, <span>$\| \cdot \|_F$</span> is the Frobenuius-norm,  and <span>$\| \cdot \|_{1,1}$</span> is the element sum norm, and <span>$R$</span>  is orthogonal. See [1] for further information on the argument  <code>Rinit</code>, as well as a description of the algorithm. </p><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/seba.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seba(V::Vector{&lt;:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -&gt; S, A</code></pre><p>Construct a sparse eigenbasis approximation of <code>V</code>, as described in  [1]. Returns an <code>Array</code> of <code>BoxFun</code>s corresponding to the eigenbasis,  as well as a maximum-likelihood <code>BoxFun</code> that maps a box to the  element of <code>S</code> which has the largest value over the support. </p><p>The keyword <code>which</code> is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are</p><pre><code class="language-julia hljs">partition_unity, partition_disjoint, partition_likelihood</code></pre><p>which are all exported functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/seba.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}" href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::TreePartition, key::keytype(tree)) -&gt; TreePartition
subdivide!(tree::TreePartition, depth::Integer) -&gt; TreePartition

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}" href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(B::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/boxset.jl#L265-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.symmetric_image-Tuple{BoxMap, BoxSet}" href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetric_image(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F (B) \cap B \cap F^{-1} (B) . \]</p><p>Internally performs the following computation  (though more efficiently) </p><pre><code class="language-julia hljs"># create a measure with support over B
μ = BoxFun(B)

# compute transfer weights (restricted to B)
T = TransferOperator(F, B, B)

C⁺ = BoxSet(T*μ)    # support of pushforward measure
C⁻ = BoxSet(T&#39;μ)    # support of pullback measure

C = C⁺ ∩ C⁻</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/invariant_sets.jl#L73-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.tree_search-Union{Tuple{TR}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TR, Any}, Tuple{TR, Any, Any}} where {N, T, I, TR&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.tree_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree_search(tree, point, max_depth=Inf) -&gt; key, node_idx</code></pre><p>Find the key and correspoinding node index within the tree  data structure containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/partition_tree.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.unstable_set-Tuple{BoxMap, BoxSet}" href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstable_set(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Compute the unstable set for a box set <code>B</code>. Generally, <code>B</code> should be  a small box surrounding a fixed point of <code>F</code>. The partition must  be fine enough, since no subdivision occurs in this algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/invariant_sets.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}" href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(box)</code></pre><p>Return an iterator over the vertices of a <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/box.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.@save-Tuple{Any, Vararg{Any}}" href="#GAIO.@save-Tuple{Any, Vararg{Any}}"><code>GAIO.@save</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@save boxset prefix=&quot;./&quot; suffix=&quot;.boxset&quot; -&gt; filename
@save boxset filename -&gt; filename</code></pre><p>Save a <code>BoxSet</code> as a list of keys. The default file name is the  variable name. </p><p>Note that this does not include information on the  partition of the <code>BoxSet</code>, just the keys. </p><p>.</p><pre><code class="nohighlight hljs">@save boxmap source prefix=&quot;./&quot; suffix=&quot;.boxmap&quot; -&gt; filename
@save boxmap source filename -&gt; filename</code></pre><p>Save a <code>BoxMap</code> as a list of source-keys and their image-keys in the form</p><pre><code class="nohighlight hljs">key_1 -&gt; {image_1, image_2, image_3}
key_2 -&gt; {image_2, image_4, image_8, image_6}
⋮</code></pre><p>.</p><pre><code class="nohighlight hljs">@save transfer_operator prefix=&quot;./&quot; suffix=&quot;.boxmap&quot; -&gt; filename
@save transfer_operator filename -&gt; filename</code></pre><p>Save a <code>TransferOperator</code> as a list of keys and their image-keys in the form</p><pre><code class="nohighlight hljs">key_1 -&gt; {image_1, image_2, image_3}
key_2 -&gt; {image_2, image_4, image_8, image_6}
⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/e15a6bfa318fefc70ddafeb90c2560337006d37e/src/algorithms/conley_index.jl#L55-L88">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Other Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 24 December 2023 12:51">Sunday 24 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
