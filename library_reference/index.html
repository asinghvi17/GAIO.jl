<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../boxmap/">BoxMaps</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/library_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><ul><li><a href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1&lt;:(TransferOperator{P, T, S} where S&lt;:(BoxSet{P, P1} where P1&lt;:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S&lt;:BoxSet{B, Q, R}, P&lt;:(TransferOperator{B, T, S})}"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.Node"><code>GAIO.Node</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}, Any}} where {B, K, V}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a></li><li><a href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a></li><li><a href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a></li><li><a href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a></li><li><a href="#GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition"><code>GAIO.cover</code></a></li><li><a href="#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:BoxPartition{N, T, I}}"><code>GAIO.cover_boxes</code></a></li><li><a href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a></li><li><a href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a></li><li><a href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{BoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a></li><li><a href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a></li><li><a href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a></li><li><a href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a></li><li><a href="#GAIO.plotboxes-Tuple"><code>GAIO.plotboxes</code></a></li><li><a href="#GAIO.plotboxes!-Tuple"><code>GAIO.plotboxes!</code></a></li><li><a href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.relative_attractor</code></a></li><li><a href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a></li><li><a href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a></li><li><a href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}"><code>GAIO.sample_adaptive</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a></li><li><a href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArraysCore.StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}" href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain; no_of_points=ntuple(_-&gt;4, N)) -&gt; SampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>By default uses a grid of sample points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1&lt;:(TransferOperator{P, T, S} where S&lt;:(BoxSet{P, P1} where P1&lt;:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S&lt;:BoxSet{B, Q, R}, P&lt;:(TransferOperator{B, T, S})}" href="#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1&lt;:(TransferOperator{P, T, S} where S&lt;:(BoxSet{P, P1} where P1&lt;:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S&lt;:BoxSet{B, Q, R}, P&lt;:(TransferOperator{B, T, S})}"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxSet(boxgraph, graph_index_or_indices) -&gt; BoxSet</code></pre><p>Construct a BoxSet from some  index / indices of vertices in a BoxGraph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxgraph.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.Node" href="#GAIO.Node"><code>GAIO.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Node structure used for <code>TreePartition</code>s</p><p>Fields:</p><ul><li><code>left</code> and <code>right</code> refer to indices w.r.t. </li></ul><p><code>trp.nodes</code> for a <code>TreePartition</code> <code>trp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_tree.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d[, v], nconv)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/transfer_operator.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d[, v], nconv)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/transfer_operator.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d[, v], nconv)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/transfer_operator.jl#L175-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}, Any}} where {B, K, V}" href="#Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}, Any}} where {B, K, V}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(identity, μ, B)</code></pre><p>Integrate a function <code>f</code> using <code>μ</code> as a density, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxfun.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:adaptive, f, domain::Box) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to  generate test points as described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_sampled.jl#L162-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, map, domain::Box{N,T}; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap
GridBoxMap(:grid, P::BoxPartition{N,T}; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>no_of_points</code>, which is  a tuple of length equal to the dimension of the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_sampled.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, map, domain::Box{N,T}; no_of_points=16*N) -&gt; SampledBoxMap
BoxMap(:montecarlo, map, P::BoxPartition{N,T}; no_of_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses <code>no_of_points</code>  Monte-Carlo test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_sampled.jl#L146-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}" href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, map, domain, points) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_sampled.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :cpu, map, domain, points) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses the iterator  <code>points</code> as test points. <code>points</code> must have eltype  <code>SVector{N, SIMD.Vec{S,T}}</code> and be within the unit  cube <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_simd.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :gpu, map, domain, points) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses the Vector <code>points</code> as test points.  <code>points</code> must be a VECTOR of test points within the unit cube  <code>[-1,1]^N</code>. </p><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/no_boxmap_cuda.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.adaptive_newton_step" href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_newton_step(g, g_jacobian, x, k=1)</code></pre><p>Return one step of the adaptive Newton algorithm for the point <code>x</code>. </p><p>The optional argument <code>k</code> is the iteration number, which is  used to tune the step size. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -&gt; Matrix</code></pre><p>Compute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies </p><p class="math-container">\[| f(x) - f(y) | \leq L | x - y | \quad \forall \, x,y \in \text{Box(center, radius)}\]</p><p>componentwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_sampled.jl#L180-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}" href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(partition::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the partition. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_regular.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.center-Tuple{Any, Any}" href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(b::Box)
center(center, radius)</code></pre><p>Return the center of a box as an iterable.  Default function for <code>image_points</code> in <code>SampledBoxMap</code>s. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/box.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the chain recurrent set over the box set <code>B</code>. Generally,  <code>B</code> should be a box set containing the whole partition <code>P</code>,  ie <code>B = P[:]</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition" href="#GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition"><code>GAIO.cover</code></a> — <span class="docstring-category">Method</span></header><section><div><ul><li><code>BoxSet</code> constructors:<ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><code>julia   B = cover(P, :)</code><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><code>julia   B = cover(P, x)</code>    <ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><code>julia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)</code></li></ul><p>Return a subset of the partition or box set <code>P</code> based on the second argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxset.jl#L55-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:BoxPartition{N, T, I}}" href="#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:BoxPartition{N, T, I}}"><code>GAIO.cover_boxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_boxes(partition::BoxPartition, boxes)</code></pre><p>Return a covering of an iterator of <code>Box</code>es using <code>Box</code>es from <code>partition</code>.  Only covers the part of <code>boxes</code> which lies within <code>partition.domain</code>.  This is returned by <code>cover(partition, boxes)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxset.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_roots(g, Dg, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute a covering of the roots of <code>g</code> within the  partition <code>P</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie <code>B = P[:]</code>, and should contain a root of <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L82-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}" href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth(tree::TreePartition)</code></pre><p>Return the depth of the tree structure. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_tree.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}" href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_at_depth(tree, depth)</code></pre><p>Return all node indices at a specified depth. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_tree.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{BoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{BoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(F::BoxMap, boxset::BoxSet) -&gt; BoxFun</code></pre><p>Compute the Finite Time Lyapunov Exponent for  every box in <code>boxset</code>, where <code>F</code> represents a time-<code>T</code>  integration of some continuous dynamical system.  It is assumed that all boxes in <code>boxset</code> have radii  of some fixed order ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L102-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hidden_keys(tree)</code></pre><p>Return all keys within the tree, including  keys not corresponding to leaf nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_tree.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.index_to_key-Tuple{AbstractArray, Any}" href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_to_key(iterable, i)</code></pre><p>Return the object held in the <code>i</code>th position of <code>iterable</code>.  Used to enumerate <code>BoxSet</code>s as  <span>$\left{ B_1, B_2, \ldots, B_n \right}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/transfer_operator.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_regular.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_index-Tuple{AbstractArray, Any}" href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_index(iterable, key)</code></pre><p>Find the index in <code>1..length(iterable)</code> which holds <code>key</code>,  or return <code>nothing</code>. Used to enumerate <code>BoxSet</code>s as  <span>$\left{ B_1, B_2, \ldots, B_n \right}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/transfer_operator.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}" href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leaves(tree, initial_node_idx=1)</code></pre><p>Return the node indices of all leaves.  Begins search at <code>initial_node_idx</code>, i.e. only returns node indices of nodes below  <code>initial_node_idx</code> within the tree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_tree.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.plotboxes!-Tuple" href="#GAIO.plotboxes!-Tuple"><code>GAIO.plotboxes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/plot.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.plotboxes-Tuple" href="#GAIO.plotboxes-Tuple"><code>GAIO.plotboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/plot.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}" href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::AbstractBoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_regular.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_regular.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.relative_attractor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_attractor(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the attractor relative to <code>B</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie <code>B = P[:]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any, Any, Any}" href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(center, radius, points)</code></pre><p>Return an iterable which calls <code>rescale(center, radius, point)</code> for each point in <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/box.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any}" href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(points)</code></pre><p>Return a function </p><pre><code class="language-julia hljs">(center, radius) -&gt; rescale(center, radius, points)</code></pre><p>Used in <code>domain_points</code> for <code>BoxMap</code>, <code>PointDiscretizedMap</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/box.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(box, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})
rescale(center, radius, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})</code></pre><p>Scale a <code>point</code> within the unit box <span>$[-1, 1]^N$</span>  to lie within <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/box.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4-Tuple{Any, Any, Any}" href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rk4(f, x, τ)</code></pre><p>Compute one step with step size <code>τ</code> of the classic  fourth order Runge-Kutta method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4_flow_map" href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rk4_flow_map(f, x, step_size=0.01, steps=20)</code></pre><p>Perform <code>steps</code> steps of the classic Runge-Kutta fourth order method, with step size <code>step_size</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}" href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}"><code>GAIO.sample_adaptive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_adaptive(f, center::SVector, radius::SVector, accel=nothing)</code></pre><p>Create a grid of test points using the adaptive technique  described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxmap_sampled.jl#L213-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}" href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::TreePartition, key::keytype(tree)) -&gt; TreePartition
subdivide!(tree::TreePartition, depth::Integer) -&gt; TreePartition

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/partition_tree.jl#L129-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}" href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(B::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/boxset.jl#L250-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.unstable_set-Tuple{BoxMap, BoxSet}" href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstable_set(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Compute the unstable set for a box set <code>B</code>. Generally, <code>B</code> should be  a small box surrounding a fixed point of <code>F</code>. The partition should  be fine enough, since no subdivision occurs in this algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/algorithms.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArraysCore.StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}" href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArraysCore.StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(box)
vertices(center, radius)</code></pre><p>Return an iterator over the vertices of a <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/01e3a6990ea9c8df5738e518d0352e2167b6051e/src/box.jl#L92-L97">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structures/">« Data Structures</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 7 March 2023 14:57">Tuesday 7 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
