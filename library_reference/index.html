<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/library_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><ul><li><a href="#GAIO.BoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1&lt;:(TransferOperator{P, T, S} where S&lt;:(BoxSet{P, P1} where P1&lt;:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S&lt;:BoxSet{B, Q, R}, P&lt;:(TransferOperator{B, T, S})}"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.Node"><code>GAIO.Node</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Base.getindex-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition"><code>Base.getindex</code></a></li><li><a href="#Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}, Any}} where {B, K, V}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedMap"><code>GAIO.PointDiscretizedMap</code></a></li><li><a href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a></li><li><a href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}"><code>GAIO.approx_lipschitz</code></a></li><li><a href="#GAIO.bounded_point_to_cartesian-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.bounded_point_to_cartesian</code></a></li><li><a href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a></li><li><a href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a></li><li><a href="#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:(BoxPartition{N, T, I})}"><code>GAIO.cover_boxes</code></a></li><li><a href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a></li><li><a href="#GAIO.depth-Tuple{TreePartition}"><code>GAIO.depth</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{BoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I, IndexCartesian}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.plotboxes-Tuple"><code>GAIO.plotboxes</code></a></li><li><a href="#GAIO.plotboxes!-Tuple"><code>GAIO.plotboxes!</code></a></li><li><a href="#GAIO.point_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I, IndexCartesian}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.relative_attractor</code></a></li><li><a href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a></li><li><a href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a></li><li><a href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}"><code>GAIO.sample_adaptive</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!-Union{Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T}, Tuple{Int64, Int64}}} where {N, T}"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.unsafe_point_to_cartesian-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.unsafe_point_to_cartesian</code></a></li><li><a href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a></li><li><a href="#GAIO.vertices-Union{Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.vertices</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.BoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain::Box{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -&gt; SampledBoxMap
BoxMap(map, P::BoxPartition{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>no_of_points</code> Monte-Carlo  test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1&lt;:(TransferOperator{P, T, S} where S&lt;:(BoxSet{P, P1} where P1&lt;:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S&lt;:BoxSet{B, Q, R}, P&lt;:(TransferOperator{B, T, S})}" href="#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{Q}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{P, T, P1} where {T, P1&lt;:(TransferOperator{P, T, S} where S&lt;:(BoxSet{P, P1} where P1&lt;:AbstractBoxPartition{P}))}, Any}} where {B, T, Q, R, S&lt;:BoxSet{B, Q, R}, P&lt;:(TransferOperator{B, T, S})}"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxSet(boxgraph, graph_index_or_indices) -&gt; BoxSet</code></pre><p>Construct a BoxSet from some  index / indices of vertices in a BoxGraph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxgraph.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.Node" href="#GAIO.Node"><code>GAIO.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Node structure used for <code>TreePartition</code>s</p><p>Fields:</p><ul><li><code>left</code> and <code>right</code> refer to indices w.r.t. <code>trp.nodes</code> and </li></ul><p><code>trp.regular_partitions</code> for a <code>TreePartition</code> <code>trp</code>. </p><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_tree.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d[, v], nconv)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/transfer_operator.jl#L186-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d[, v], nconv)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/transfer_operator.jl#L186-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d[, v], nconv)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/transfer_operator.jl#L186-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition" href="#Base.getindex-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><ul><li>getindex constructors:<ul><li>set of all boxes in <code>P</code>:</li></ul><code>julia   B = P[:]</code><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><code>julia   B = P[x]</code>    <ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><code>julia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = P[S]</code></li></ul><p>Return a subset of the partition <code>P</code> based on the second argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxset.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}, Any}} where {B, K, V}" href="#Base.sum-Union{Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}}, Tuple{Any, BoxFun{B, K, V, P, D} where {P&lt;:AbstractBoxPartition{B}, D&lt;:AbstractDict{K, V}}, Any}} where {B, K, V}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(identity, μ, B)</code></pre><p>Integrate a function <code>f</code> using <code>μ</code> as a density, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxfun.jl#L29-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}, Tuple{Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AdaptiveBoxMap(f, domain::Box, accel=nothing) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to generate  test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedMap" href="#GAIO.PointDiscretizedMap"><code>GAIO.PointDiscretizedMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PointDiscretizedMap(map, domain, points, accel=nothing) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <span>$[-1,1]^N$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.adaptive_newton_step" href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_newton_step(g, g_jacobian, x, k=1)</code></pre><p>Return one step of the adaptive Newton algorithm for the point <code>x</code>. </p><p>The optional argument <code>k</code> is the iteration number, which is  used to tune the step size. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}" href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}"><code>GAIO.approx_lipschitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -&gt; Matrix</code></pre><p>Compute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies </p><p class="math-container">\[| f(x) - f(y) | \leq L | x - y | \quad \forall \, x,y \in \text{Box(center, radius)}\]</p><p>componentwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L117-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.bounded_point_to_cartesian-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.bounded_point_to_cartesian-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.bounded_point_to_cartesian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_cartesian(partition::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>unsafe_point_to_ints</code>  if the point lies in the partition. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L151-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.center-Tuple{Any, Any}" href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(b::Box)
center(center, radius)</code></pre><p>Return the center of a box as an iterable.  Default function for <code>image_points</code> in <code>SampledBoxMap</code>s. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the chain recurrent set over the box set <code>B</code>. Generally,  <code>B</code> should be a box set containing the whole partition <code>P</code>,  ie <code>B = P[:]</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:(BoxPartition{N, T, I})}" href="#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:(BoxPartition{N, T, I})}"><code>GAIO.cover_boxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_boxes(partition::BoxPartition, boxes)</code></pre><p>Return a covering of an iterator of <code>Box</code>es using <code>Box</code>es from <code>partition</code>.  Only covers the part of <code>boxes</code> which lies within <code>partition.domain</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxset.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_roots(g, Dg, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute a covering of the roots of <code>g</code> within the  partition <code>P</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie <code>B = P[:]</code>, and should contain a root of <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.depth-Tuple{TreePartition}" href="#GAIO.depth-Tuple{TreePartition}"><code>GAIO.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the depth of the tree structure. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_tree.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{BoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{BoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(F::BoxMap, boxset::BoxSet) -&gt; BoxFun</code></pre><p>Compute the Finite Time Lyapunov Exponent for  every box in <code>boxset</code>, where <code>F</code> represents a time-<code>T</code>  integration of some continuous dynamical system.  It is assumed that all boxes in <code>boxset</code> have radii  of some fixed order ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I, IndexCartesian}, Any}} where {N, T, I}" href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I, IndexCartesian}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.plotboxes!-Tuple" href="#GAIO.plotboxes!-Tuple"><code>GAIO.plotboxes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/plot.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.plotboxes-Tuple" href="#GAIO.plotboxes-Tuple"><code>GAIO.plotboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/plot.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.point_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::BoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I, IndexCartesian}, Any}} where {N, T, I}" href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I, IndexCartesian}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point. </p><div class="admonition is-info"><header class="admonition-header">Bounds checking</header><div class="admonition-body"><p>unlike <code>unsafe_point_to_ints</code>, <code>point_to_key</code> will return  <code>nothing</code> if the point does not lie in the partition. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L170-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.relative_attractor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_attractor(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the attractor relative to <code>B</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie <code>B = P[:]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any, Any, Any}" href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(center, radius, points)</code></pre><p>Return an iterable which calls <code>rescale(center, radius, point)</code> for each point in <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any}" href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(points)</code></pre><p>Return a function </p><pre><code class="language-julia hljs">(center, radius) -&gt; rescale(center, radius, points)</code></pre><p>Used in <code>domain_points</code> for <code>BoxMap</code>, <code>PointDiscretizedMap</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(box, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})
rescale(center, radius, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})</code></pre><p>Scale a <code>point</code> within the unit box <span>$[-1, 1]^N$</span>  to lie within <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4-Tuple{Any, Any, Any}" href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rk4(f, x, τ)</code></pre><p>Compute one step with step size <code>τ</code> of the classic  fourth order Runge-Kutta method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4_flow_map" href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rk4_flow_map(f, x, step_size=0.01, steps=20)</code></pre><p>Perform <code>steps</code> steps of the classic Runge-Kutta fourth order method, with step size <code>step_size</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}" href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Any}} where {N, T}"><code>GAIO.sample_adaptive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_adaptive(f, center::SVector, radius::SVector, accel=nothing)</code></pre><p>Create a grid of test points using the adaptive technique  described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L148-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!-Union{Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T}, Tuple{Int64, Int64}}} where {N, T}" href="#GAIO.subdivide!-Union{Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T}, Tuple{Int64, Int64}}} where {N, T}"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree:TreePartition), key::NTuple{2,&lt;:Integer}) -&gt; TreePartition
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key::NTuple{2,&lt;:Integer}) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at the node <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_tree.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}} where {B, P&lt;:TreePartition, S}" href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(B::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxset.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.unsafe_point_to_cartesian-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.unsafe_point_to_cartesian-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.unsafe_point_to_cartesian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_point_to_cartesian(P::BoxPartiton, point)</code></pre><p>Find the cartesian index for the box within a  <code>BoxPartition</code> containing a point.</p><div class="admonition is-danger"><header class="admonition-header">bounds checking</header><div class="admonition-body"><p><code>unsafe_point_to_ints</code> does not do any bounds checking. The returned  cartesian index will be out of bounds if the point does not lie in the  partition. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L135-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.unstable_set-Tuple{BoxMap, BoxSet}" href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstable_set(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Compute the unstable set for a box set <code>B</code>. Generally, <code>B</code> should be  a small box surrounding a fixed point of <code>F</code>. The partition should  be fine enough, since no subdivision occurs in this algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/algorithms.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.vertices-Union{Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.vertices-Union{Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(box)
vertices(center, radius)</code></pre><p>Return an iterator over the vertices of a <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L55-L60">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../data_structures/">« Data Structures</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 December 2022 08:21">Tuesday 6 December 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
