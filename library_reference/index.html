<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../algorithms/chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/library_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><ul><li><a href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{P1}, Tuple{B1}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{B, T, P}, Any}} where {B, T, B1, P1, R, S&lt;:BoxSet{B1, P1, R}, P&lt;:(TransferOperator{B, T, S})}"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.Node"><code>GAIO.Node</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.eigs"><code>Arpack.eigs</code></a></li><li><a href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a></li><li><a href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a></li><li><a href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a></li><li><a href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a></li><li><a href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a></li><li><a href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a></li><li><a href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a></li><li><a href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a></li><li><a href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a></li><li><a href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a></li><li><a href="#GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition"><code>GAIO.cover</code></a></li><li><a href="#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:BoxPartition{N, T, I}}"><code>GAIO.cover_boxes</code></a></li><li><a href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a></li><li><a href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a></li><li><a href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a></li><li><a href="#GAIO.expon"><code>GAIO.expon</code></a></li><li><a href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a></li><li><a href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a></li><li><a href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a></li><li><a href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a></li><li><a href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a></li><li><a href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a></li><li><a href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a></li><li><a href="#GAIO.maximal_forward_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.maximal_forward_invariant_set</code></a></li><li><a href="#GAIO.maximal_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.maximal_invariant_set</code></a></li><li><a href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a></li><li><a href="#GAIO.plotboxes-Tuple"><code>GAIO.plotboxes</code></a></li><li><a href="#GAIO.plotboxes!-Tuple"><code>GAIO.plotboxes!</code></a></li><li><a href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.preimage-Tuple{BoxMap, BoxSet}"><code>GAIO.preimage</code></a></li><li><a href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a></li><li><a href="#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.relative_attractor</code></a></li><li><a href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a></li><li><a href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a></li><li><a href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a></li><li><a href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}"><code>GAIO.seba</code></a></li><li><a href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a></li><li><a href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a></li><li><a href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}" href="#GAIO.BoxMap-Tuple{Symbol, Vararg{Any}}"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain; no_of_points=ntuple(_-&gt;4, N)) -&gt; SampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>By default uses adaptive test-point sampling.  For SIMD- and GPU-accelerated <code>BoxMap</code>s, uses a grid of test points by default. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{P1}, Tuple{B1}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{B, T, P}, Any}} where {B, T, B1, P1, R, S&lt;:BoxSet{B1, P1, R}, P&lt;:(TransferOperator{B, T, S})}" href="#GAIO.BoxSet-Union{Tuple{P}, Tuple{S}, Tuple{R}, Tuple{P1}, Tuple{B1}, Tuple{T}, Tuple{B}, Tuple{BoxGraph{B, T, P}, Any}} where {B, T, B1, P1, R, S&lt;:BoxSet{B1, P1, R}, P&lt;:(TransferOperator{B, T, S})}"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxSet(boxgraph, graph_index_or_indices) -&gt; BoxSet</code></pre><p>Construct a BoxSet from some  index / indices of vertices in a BoxGraph. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxgraph.jl#L218-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.Node" href="#GAIO.Node"><code>GAIO.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Node structure used for <code>TreePartition</code>s</p><p>Fields:</p><ul><li><code>left</code> and <code>right</code> refer to indices w.r.t. </li></ul><p><code>trp.nodes</code> for a <code>TreePartition</code> <code>trp</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_tree.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.eigs" href="#Arpack.eigs"><code>Arpack.eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigs(gstar::TransferOperator [; kwargs...]) -&gt; (d,[v,],nconv,niter,nmult,resid)</code></pre><p>Compute a set of eigenvalues <code>d</code> and eigenmeasures <code>v</code> of <code>gstar</code>.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.eigs</code> can be passed. See the  documentation for <code>Arpack.eigs</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L178-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Adjoint{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.svds-Tuple{TransferOperator}" href="#Arpack.svds-Tuple{TransferOperator}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}" href="#Arpack.svds-Tuple{Transpose{&lt;:Any, &lt;:TransferOperator}}"><code>Arpack.svds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svds(gstar::TransferOperator [; kwargs...]) -&gt; ([U,], σ, [V,], nconv, niter, nmult, resid)</code></pre><p>Compute a set of </p><ul><li>singular values <code>σ</code></li><li>left singular vectors <code>U</code> </li><li>right singular vectors <code>V</code></li></ul><p>of <code>gstar</code>, where <code>U</code> and <code>V</code> are <code>Vector</code>s of <code>BoxFun</code>s.  Works with the adjoint <em>Koopman operator</em> as well.  All keyword arguments from <code>Arpack.svds</code> can be passed. See the  documentation for <code>Arpack.svds</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}" href="#Base.sum-Union{Tuple{D}, Tuple{P}, Tuple{V}, Tuple{K}, Tuple{B}, Tuple{Any, BoxFun{B, K, V, P, D}}} where {B, K, V, P, D}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(x-&gt;1, μ, B)</code></pre><p>Integrate a function <code>f</code> using <code>μ</code> as a density, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxfun.jl#L58-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.AdaptiveBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:adaptive, f, domain::Box) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to  generate test points as described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_sampled.jl#L165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, map, domain::Box{N}; n_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>n_points</code>, which is  a tuple of length equal to the dimension of the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_sampled.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, map, domain::Box{N}; n_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses <code>n_points</code>  Monte-Carlo test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_sampled.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}" href="#GAIO.PointDiscretizedBoxMap-Tuple{Any, Box, Any}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, map, domain, points) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_sampled.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :gpu, map, domain, points) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses the Vector <code>points</code> as test points.  <code>points</code> must be a VECTOR of test points within the unit cube  <code>[-1,1]^N</code>. </p><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/no_boxmap_cuda.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}" href="#GAIO.PointDiscretizedBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:simd}, Any, Box{N, T}, Any}} where {N, T}"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :simd, map, domain, points) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses the iterator  <code>points</code> as test points. <code>points</code> must have eltype  <code>SVector{N, SIMD.Vec{S,T}}</code> and be within the unit  cube <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_simd.jl#L146-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.adaptive_newton_step" href="#GAIO.adaptive_newton_step"><code>GAIO.adaptive_newton_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_newton_step(g, g_jacobian, x, k=1)</code></pre><p>Return one step of the adaptive Newton algorithm for the point <code>x</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L188-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.approx_lipschitz-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.approx_lipschitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_lipschitz(f, center::SVector, radius::SVector, accel=nothing) -&gt; Matrix</code></pre><p>Compute an approximation of the Lipschitz matrix,  i.e. the matrix that satisifies </p><p class="math-container">\[| f(x) - f(y) | \leq L | x - y | \quad \forall \, x,y \in \text{Box(center, radius)}\]</p><p>componentwise. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_sampled.jl#L183-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.armijo_rule" href="#GAIO.armijo_rule"><code>GAIO.armijo_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">armijo_rule(g, Dg, x, d, σ=1e-4, ρ=0.8, α₀=0.05, α₁=1.0)</code></pre><p>Find a step size multiplier <span>$\alpha \in (\alpha_0, \alpha_1]$</span>  such that </p><p class="math-container">\[g(x + \alpha d) - g(x) \leq \alpha \sigma \, Dg(x) \cdot d\]</p><p>This is done by initializing <span>$\alpha = 1$</span> and testing the  above condition. If it is not satisfied, scale <span>$\alpha$</span>  by some constant <span>$\rho &lt; 1$</span> (i.e. set  <span>$\alpha = \rho \cdot \alpha$</span>), and test the condition  again. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L154-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}" href="#GAIO.bounded_point_to_key-Union{Tuple{B}, Tuple{T}, Tuple{N}, Tuple{AbstractBoxPartition{B}, Any}} where {N, T, B&lt;:Box{N, T}}"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(P::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the partition. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_regular.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.box_dimension-Tuple{Any}" href="#GAIO.box_dimension-Tuple{Any}"><code>GAIO.box_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">box_dimension(boxsets) -&gt; D</code></pre><p>For an iterator <code>boxsets</code> of (successively finer)  <code>BoxSet</code>s, compute the box dimension <code>D</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># F is some BoxMap, S is some BoxSet
box_dimension( relative_attractor(F, S, steps=k) for k in 1:20 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L358-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.center-Tuple{Any, Any}" href="#GAIO.center-Tuple{Any, Any}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(center, radius)</code></pre><p>Return the center of a box as an iterable.  Default function for <code>image_points</code> in <code>SampledBoxMap</code>s. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.center-Tuple{Box}" href="#GAIO.center-Tuple{Box}"><code>GAIO.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(b::Box)</code></pre><p>Return the center of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.chain_recurrent_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.chain_recurrent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain_recurrent_set(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the chain recurrent set over the box set <code>B</code>.  <code>B</code> should be a (coarse) covering of the relative attractor,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition" href="#GAIO.cover-Union{Tuple{P}, Tuple{P, Any}} where P&lt;:AbstractBoxPartition"><code>GAIO.cover</code></a> — <span class="docstring-category">Method</span></header><section><div><ul><li><code>BoxSet</code> constructors:<ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><code>julia   B = cover(P, :)</code><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><code>julia   B = cover(P, x)</code>    <ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><code>julia   S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc...    B = cover(P, S)</code></li></ul><p>Return a subset of the partition or box set <code>P</code> based on the second argument. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxset.jl#L60-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:BoxPartition{N, T, I}}" href="#GAIO.cover_boxes-Union{Tuple{P}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{P, Any}} where {N, T, I, P&lt;:BoxPartition{N, T, I}}"><code>GAIO.cover_boxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_boxes(partition::BoxPartition, boxes)</code></pre><p>Return a covering of an iterator of <code>Box</code>es using <code>Box</code>es from <code>partition</code>.  Only covers the part of <code>boxes</code> which lies within <code>partition.domain</code>.  This is returned by <code>cover(partition, boxes)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxset.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}" href="#GAIO.cover_manifold-Union{Tuple{S}, Tuple{Q}, Tuple{T}, Tuple{N}, Tuple{Any, BoxSet{Box{N, T}, Q, S}}} where {N, T, Q, S}"><code>GAIO.cover_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_manifold(f, B::BoxSet; steps=12)</code></pre><p>Use interval arithmetic to compute a covering of  an implicitly defined manifold <span>$M$</span> of the form </p><p class="math-container">\[f(M) \equiv 0\]</p><p>for some function <span>$f : \mathbb{R}^N \to \mathbb{R}$</span>. </p><p>The starting BoxSet <code>B</code> should (coarsely) cover  the manifold. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L225-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.cover_roots-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.cover_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cover_roots(g, Dg, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute a covering of the roots of <code>g</code> within the  partition <code>P</code>. Generally, <code>B</code> should be  a box set containing the whole partition <code>P</code>, ie  <code>B = cover(P, :)</code>, and should contain a root of <code>g</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L205-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}" href="#GAIO.depth-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}"><code>GAIO.depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">depth(tree::TreePartition)</code></pre><p>Return the depth of the tree structure. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_tree.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.expon" href="#GAIO.expon"><code>GAIO.expon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expon(h, k=1, ϵ=0.2, δ=0.1)</code></pre><p>Return a rough estimate of how many Newton steps  should be taken, given a step size h. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}" href="#GAIO.find_at_depth-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Integer}} where {N, T, I}"><code>GAIO.find_at_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_at_depth(tree, depth)</code></pre><p>Return all node indices at a specified depth. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_tree.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{E}, Tuple{T}, Tuple{N}, Tuple{Any, Any, BoxFun{E, K, V, P} where {K, V, P&lt;:AbstractBoxPartition{E}}}} where {N, T, E&lt;:Box{N, T}}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(f, Df, μ::BoxFun; n=8) -&gt; σ</code></pre><p>Compute the Lyapunov exponents using a spatial integration  method [1] based on Birkhoff&#39;s ergodic theorem. Computes </p><p class="math-container">\[\sigma_j = \frac{1}{n} \int \log R_{jj}( Df^n (x) ) \, dμ (x), \quad j = 1, \ldots, d\]</p><p>with respect to an ergodic invariant measure <span>$\mu$</span>. </p><p>[1] Beyn, WJ., Lust, A. A hybrid method for computing  Lyapunov exponents. Numer. Math. 113, 357–375 (2009).  https://doi.org/10.1007/s00211-009-0236-4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L333-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}" href="#GAIO.finite_time_lyapunov_exponents-Union{Tuple{S}, Tuple{Q}, Tuple{R}, Tuple{V}, Tuple{N}, Tuple{SampledBoxMap, BoxSet{R, Q, S}}} where {N, V, R&lt;:Box{N, V}, Q, S}"><code>GAIO.finite_time_lyapunov_exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finite_time_lyapunov_exponents(F::SampledBoxMap, boxset::BoxSet) -&gt; BoxFun</code></pre><p>Compute the Finite Time Lyapunov Exponent for  every box in <code>boxset</code>, where <code>F</code> represents a time-<code>T</code>  integration of some continuous dynamical system.  It is assumed that all boxes in <code>boxset</code> have radii  of some fixed order ϵ. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L256-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.fixqr!-Tuple{Any, Any}" href="#GAIO.fixqr!-Tuple{Any, Any}"><code>GAIO.fixqr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fixqr!(Q, R)</code></pre><p>Adjust a QR-decomposition such that the  R-factor has positive diagonal entries. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L320-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}" href="#GAIO.hidden_keys-Union{Tuple{Q}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I, Q&lt;:(TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}))}"><code>GAIO.hidden_keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hidden_keys(tree)</code></pre><p>Return all keys within the tree, including  keys not corresponding to leaf nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_tree.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.index_to_key-Tuple{AbstractArray, Any}" href="#GAIO.index_to_key-Tuple{AbstractArray, Any}"><code>GAIO.index_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_to_key(iterable, i)</code></pre><p>Return the object held in the <code>i</code>th position of <code>iterable</code>.  Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L271-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.key_to_box-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_regular.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_index-Tuple{AbstractArray, Any}" href="#GAIO.key_to_index-Tuple{AbstractArray, Any}"><code>GAIO.key_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">key_to_index(iterable, key)</code></pre><p>Find the index in <code>1..length(iterable)</code> which holds <code>key</code>,  or return <code>nothing</code>. Used to enumerate <code>BoxSet</code>s as  <span>$\left\{ B_1, B_2, \ldots, B_n \right\}$</span> in  <code>TransferOperator</code>, <code>BoxGraph</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/transfer_operator.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}" href="#GAIO.leaves-Union{Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}})}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Any}} where {N, T, I}"><code>GAIO.leaves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leaves(tree, initial_node_idx=1)</code></pre><p>Return the node indices of all leaves.  Begins search at <code>initial_node_idx</code>, i.e. only returns node indices of nodes below  <code>initial_node_idx</code> within the tree. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_tree.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.linreg-Tuple{Any, Any}" href="#GAIO.linreg-Tuple{Any, Any}"><code>GAIO.linreg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linreg(xs, ys)</code></pre><p>Simple one-dimensional lunear regression used to  approximate box dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.maximal_forward_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.maximal_forward_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.maximal_forward_invariant_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximal_forward_invariant_set(F::BoxMap, B::BoxSet; steps=12)</code></pre><p>Compute the maximal forward invariant set contained in <code>B</code>.  <code>B</code> should be a (coarse) covering of a forward invariant set,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.maximal_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.maximal_invariant_set-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.maximal_invariant_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximal_invariant_set(F::BoxMap, B::BoxSet; steps=12)</code></pre><p>Compute the maximal invariant set contained in <code>B</code>.  <code>B</code> should be a (coarse) covering of an invariant set,  e.g. <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.nth_iterate_jacobian-NTuple{4, Any}" href="#GAIO.nth_iterate_jacobian-NTuple{4, Any}"><code>GAIO.nth_iterate_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nth_iterate_jacobian(f, Df, x, n; return_QR=false) -&gt; Z[, R]</code></pre><p>Compute the Jacobian of the <code>n</code>-times iterated function  <code>f ∘ f ∘ ... ∘ f</code> at <code>x</code> using a QR iteration based on [1].  Requires an approximation <code>Df</code> of the jacobian of <code>f</code>, e.g.  <code>Df(x) = ForwardDiff.jacobian(f, x)</code>.  Optionally, return the QR decomposition. </p><p>[1] Dieci, L., Russell, R. D., Van Vleck, E. S.: &quot;On the  Computation of Lyapunov Exponents for Continuous Dynamical  Systems,&quot; submitted to SIAM J. Numer. Ana. (1993).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L283-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.plotboxes!-Tuple" href="#GAIO.plotboxes!-Tuple"><code>GAIO.plotboxes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/plot.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.plotboxes-Tuple" href="#GAIO.plotboxes-Tuple"><code>GAIO.plotboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(boxset::BoxSet)
plot(boxfun::BoxFun)
plot!(boxset::BoxSet)
plot!(boxfun::BoxFun)</code></pre><p>Plot a <code>BoxSet</code> or <code>BoxFun</code>. </p><p><strong>Special Attributes:</strong></p><p><code>projection = x -&gt; x[1:3]</code> If the dimension of the system is larger than 3, use this function to project to 3-d space.</p><p><code>color = :red</code> Color used for the boxes.</p><p><code>colormap = :default</code> Colormap used for plotting <code>BoxFun</code>s values.</p><p><code>marker = HyperRectangle(GeometryBasics.Vec3f0(0), GeometryBasics.Vec3f0(1))</code> The marker for an individual box. Only works if using Makie for plotting. </p><p>All other attributes are taken from MeshScatter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/plot.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}" href="#GAIO.point_to_box-Tuple{AbstractBoxPartition, Any}"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::AbstractBoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_regular.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.point_to_key-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_regular.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet, Q::BoxSet) -&gt; BoxSet</code></pre><p>Compute the (restricted to <code>Q</code>) preimage of <code>B</code> under <code>F</code>, i.e.</p><p class="math-container">\[F^{-1} (B) \cap Q . \]</p><p>Note that the larger <span>$Q$</span> is, the more calculation time required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.preimage-Tuple{BoxMap, BoxSet}" href="#GAIO.preimage-Tuple{BoxMap, BoxSet}"><code>GAIO.preimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preimage(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F^{-1} (B) \cap B . \]</p><p>Significantly faster than calling <code>preimage(F, B, B)</code>. </p><div class="admonition is-warning"><header class="admonition-header">This is not the entire preimage in the mathematical sense!</header><div class="admonition-body"><p><code>preimage(F, B)</code> computes the RESTRICTED preimage <span>$F^{-1} (B) \cap B$</span>, NOT the full preimage  <span>$F^{-1} (B)$</span>. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L68-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.radius-Tuple{Box}" href="#GAIO.radius-Tuple{Box}"><code>GAIO.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius(b::Box)</code></pre><p>Return the radius of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}" href="#GAIO.relative_attractor-Union{Tuple{T}, Tuple{N}, Tuple{BoxMap, BoxSet{Box{N, T}, P} where P&lt;:AbstractBoxPartition{Box{N, T}}}} where {N, T}"><code>GAIO.relative_attractor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_attractor(F::BoxMap, B::BoxSet; steps=12) -&gt; BoxSet</code></pre><p>Compute the attractor relative to <code>B</code>. <code>B</code> should be  a (coarse) covering of the relative attractor, e.g.  <code>B = cover(P, :)</code> for a partition <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any, Any, Any}" href="#GAIO.rescale-Tuple{Any, Any, Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(center, radius, points)</code></pre><p>Return an iterable which calls <code>rescale(center, radius, point)</code> for each point in <code>points</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Tuple{Any}" href="#GAIO.rescale-Tuple{Any}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(points)</code></pre><p>Return a function </p><pre><code class="language-julia hljs">(center, radius) -&gt; rescale(center, radius, points)</code></pre><p>Used in <code>domain_points</code> for <code>BoxMap</code>, <code>PointDiscretizedMap</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L192-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.rescale-Union{Tuple{T}, Tuple{N}, Tuple{Any, Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(box, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})
rescale(center, radius, point::Union{&lt;:StaticVector{N,T}, &lt;:NTuple{N,T}})</code></pre><p>Scale a <code>point</code> within the unit box <span>$[-1, 1]^N$</span>  to lie within <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4-Tuple{Any, Any, Any}" href="#GAIO.rk4-Tuple{Any, Any, Any}"><code>GAIO.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rk4(f, x, τ)</code></pre><p>Compute one step with step size <code>τ</code> of the classic  fourth order Runge-Kutta method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L386-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.rk4_flow_map" href="#GAIO.rk4_flow_map"><code>GAIO.rk4_flow_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rk4_flow_map(f, x, step_size=0.01, steps=20)</code></pre><p>Perform <code>steps</code> steps of the classic Runge-Kutta fourth order method, with step size <code>step_size</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L410-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}" href="#GAIO.sample_adaptive-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}}} where {N, T}"><code>GAIO.sample_adaptive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_adaptive(f, center::SVector, radius::SVector)</code></pre><p>Create a grid of test points using the adaptive technique  described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxmap_sampled.jl#L210-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{AbstractArray{U}, Any}, Tuple{AbstractArray{U}, Any, Any}} where U"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seba(V::Matrix{&lt;:Real}, Rinit=nothing, maxiter=5000) -&gt; S, R</code></pre><p>Construct a sparse approximation of the basis <code>V</code>, as described in  [1]. Returns matrices <span>$S$</span>, <span>$R$</span> such that</p><p class="math-container">\[\frac{1}{2} \| V - SR \|_F^2 + \mu \| S \|_{1,1}\]</p><p>is minimized, where <span>$\mu \in \mathbb{R}$</span>, <span>$\| \cdot \|_F$</span> is the Frobenuius-norm,  and <span>$\| \cdot \|_{1,1}$</span> is the element sum norm, and <span>$R$</span>  is orthogonal. See [1] for further information on the argument  <code>Rinit</code>, as well as a description of the algorithm. </p><p>[1] Gary Froyland, Christopher P. Rock, and Konstantinos Sakellariou.  Sparse eigenbasis approximation: multiple feature extraction  across spatiotemporal scales with application to coherent set  identification. Communications in Nonlinear Science and Numerical  Simulation, 77:81-107, 2019. https://arxiv.org/abs/1812.02787</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L492-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}" href="#GAIO.seba-Union{Tuple{AbstractArray{U}}, Tuple{U}, Tuple{D}, Tuple{Q}, Tuple{W}, Tuple{K}, Tuple{B}, Tuple{AbstractArray{U}, Any}} where {B, K, W, Q, D&lt;:OrderedCollections.OrderedDict, U&lt;:BoxFun{B, K, W, Q, D}}"><code>GAIO.seba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seba(V::Vector{&lt;:BoxFun}, Rinit=nothing; which=partition_disjoint, maxiter=5000) -&gt; S, A</code></pre><p>Construct a sparse eigenbasis approximation of <code>V</code>, as described in  [1]. Returns an <code>Array</code> of <code>BoxFun</code>s corresponding to the eigenbasis,  as well as a maximum-likelihood <code>BoxFun</code> that maps a box to the  element of <code>S</code> which has the largest value over the support. </p><p>The keyword <code>which</code> is used to set the threshholding heuristic,  which is used to extract a partition of the supports from the  sparse basis. Builtin options are</p><pre><code class="language-julia hljs">partition_unity, partition_disjoint, partition_likelihood</code></pre><p>which are all exported functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L423-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}" href="#GAIO.subdivide!-Union{Tuple{K}, Tuple{J}, Tuple{I}, Tuple{T}, Tuple{N}, Tuple{TreePartition{N, T, I, V} where V&lt;:(AbstractArray{GAIO.Node{I}}), Tuple{J, Tuple{Vararg{K, N}}}}} where {N, T, I, J, K}"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::TreePartition, key::keytype(tree)) -&gt; TreePartition
subdivide!(tree::TreePartition, depth::Integer) -&gt; TreePartition

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/partition_tree.jl#L137-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}" href="#GAIO.subdivide-Union{Tuple{BoxSet{B, P, S}}, Tuple{S}, Tuple{P}, Tuple{B}, Tuple{BoxSet{B, P, S}, Any}} where {B, P&lt;:TreePartition, S}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(B::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along an axis, giving rise to a new  partition of the domain, with double the amount of boxes.  Axis along which to bisect depends on the depth of the nodes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/boxset.jl#L266-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.symmetric_image-Tuple{BoxMap, BoxSet}" href="#GAIO.symmetric_image-Tuple{BoxMap, BoxSet}"><code>GAIO.symmetric_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetric_image(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Efficiently compute </p><p class="math-container">\[F (B) \cap B \cap F^{-1} (B) . \]</p><p>Internally performs the following computation  (though more efficiently) </p><pre><code class="language-julia hljs"># create a measure with support over B
μ = BoxFun(B)

# compute transfer weights (restricted to B)
T = TransferOperator(F, B, B)

C⁺ = BoxSet(T*μ)    # support of pushforward measure
C⁻ = BoxSet(T&#39;μ)    # support of pullback measure

C = C⁺ ∩ C⁻</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L90-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.unstable_set-Tuple{BoxMap, BoxSet}" href="#GAIO.unstable_set-Tuple{BoxMap, BoxSet}"><code>GAIO.unstable_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstable_set(F::BoxMap, B::BoxSet) -&gt; BoxSet</code></pre><p>Compute the unstable set for a box set <code>B</code>. Generally, <code>B</code> should be  a small box surrounding a fixed point of <code>F</code>. The partition must  be fine enough, since no subdivision occurs in this algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/algorithms.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}" href="#GAIO.vertices-Union{Tuple{R}, Tuple{T}, Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArray{Tuple{N}, T, 1}}, Union{Tuple{Vararg{R, N}}, StaticArray{Tuple{N}, R, 1}}}} where {N, T, R}"><code>GAIO.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertices(box)</code></pre><p>Return an iterator over the vertices of a <code>box = Box(center, radius)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6f3073821aa7cf12762cf29b803ad6ca30ac557c/src/box.jl#L128-L132">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Other Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 3 May 2023 09:42">Wednesday 3 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
