<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BoxMaps · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li class="is-active"><a class="tocitem" href>BoxMaps</a><ul class="internal"><li><a class="tocitem" href="#MonteCarloBoxMap"><span><code>MonteCarloBoxMap</code></span></a></li><li><a class="tocitem" href="#GridBoxMap"><span><code>GridBoxMap</code></span></a></li><li><a class="tocitem" href="#AdaptiveBoxMap"><span><code>AdaptiveBoxMap</code></span></a></li><li><a class="tocitem" href="#IntervalBoxMap"><span><code>IntervalBoxMap</code></span></a></li><li><a class="tocitem" href="#CPUSampledBoxMap"><span><code>CPUSampledBoxMap</code></span></a></li><li><a class="tocitem" href="#GPUSampledBoxmap"><span><code>GPUSampledBoxmap</code></span></a></li><li><a class="tocitem" href="#PointDiscretizedBoxMap"><span><code>PointDiscretizedBoxMap</code></span></a></li><li><a class="tocitem" href="#SampledBoxMap"><span><code>SampledBoxMap</code></span></a></li><li><a class="tocitem" href="#Creating-you-own-BoxMap-type"><span>Creating you own BoxMap type</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>BoxMaps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BoxMaps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/boxmap.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="BoxMap-types"><a class="docs-heading-anchor" href="#BoxMap-types">BoxMap types</a><a id="BoxMap-types-1"></a><a class="docs-heading-anchor-permalink" href="#BoxMap-types" title="Permalink"></a></h1><p>There are multiple techniques one could use to discretize point maps into maps over boxes. In <a href="https://gaioguys.github.io/GAIO.jl/general/">General Usage</a> the discretization <code>BoxMap</code> was already briefly introduced. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxMap" href="#GAIO.BoxMap"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain; no_of_points=ntuple(_-&gt;4, N)) -&gt; SampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>By default uses a grid of sample points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap.jl#L1-L9">source</a></section></article><p>We now introduce a set of <code>BoxMap</code> subtypes for different discretization algorithms. The types fit into a heirarchy described in the diagram below. </p><p><img src="../assets/type_tree.jpg" alt="Type Hierarchy"/></p><p>We will work from the &quot;bottom up&quot;, starting with specific types that are of practical use, and then generalizing these approaches for the reader who wishes to know more. </p><h2 id="MonteCarloBoxMap"><a class="docs-heading-anchor" href="#MonteCarloBoxMap"><code>MonteCarloBoxMap</code></a><a id="MonteCarloBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#MonteCarloBoxMap" title="Permalink"></a></h2><p>The simplest technique for discretization is a Monte-Carlo approach: choose a random set of sample points within a box and record which boxes are hit by the point map. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.MonteCarloBoxMap" href="#GAIO.MonteCarloBoxMap"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, map, domain::Box{N,T}; no_of_points=16*N) -&gt; SampledBoxMap
BoxMap(:montecarlo, map, P::BoxPartition{N,T}; no_of_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses <code>no_of_points</code>  Monte-Carlo test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_sampled.jl#L121-L127">source</a></section><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, :cpu, map, domain; no_of_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses <code>no_of_points</code>  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu&#39;s SIMD capacity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_simd.jl#L163-L169">source</a></section><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, :gpu, map, domain; no_of_points=16*N) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses <code>no_of_points</code>  Monte-Carlo test points. </p><p>Requires a CUDA-capapble gpu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/no_boxmap_cuda.jl#L64-L71">source</a></section></article><h2 id="GridBoxMap"><a class="docs-heading-anchor" href="#GridBoxMap"><code>GridBoxMap</code></a><a id="GridBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#GridBoxMap" title="Permalink"></a></h2><p>Another naive but still useful approach is to place the test points on an equidistant grid within a box. This approach removes an element of randomness from the Monte-Carlo approach. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.GridBoxMap" href="#GAIO.GridBoxMap"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, map, domain::Box{N,T}; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap
GridBoxMap(:grid, P::BoxPartition{N,T}; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>no_of_points</code>, which is  a tuple of length equal to the dimension of the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_sampled.jl#L103-L110">source</a></section><section><div><pre><code class="language-julia hljs">BoxMap(:grid, :cpu, map, domain; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>no_of_points</code>, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu&#39;s SIMD capacity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_simd.jl#L139-L147">source</a></section><section><div><pre><code class="language-julia hljs">BoxMap(:grid, :gpu, map, domain; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>no_of_points</code>, which is  a tuple of length equal to the dimension of the domain. </p><p>Requires a CUDA-capapble gpu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/no_boxmap_cuda.jl#L51-L59">source</a></section></article><h2 id="AdaptiveBoxMap"><a class="docs-heading-anchor" href="#AdaptiveBoxMap"><code>AdaptiveBoxMap</code></a><a id="AdaptiveBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#AdaptiveBoxMap" title="Permalink"></a></h2><p>The above approaches may not necessarily be effective for covering the setwise image of a box. For choosing test points more effectively, we can use some knowledge of the Lipschitz matrix for <span>$f$</span> in a box <code>Box(c, r)</code>, that is, a matrix <span>$L \in \mathbb{R}^{d \times d}$</span> such that </p><p class="math-container">\[| f(y) - f(z) | \leq L \, | y - z | \quad \text{for all } y, z \in \text{Box}(c, r),\]</p><p>where the operations <span>$| \cdot |$</span> and <span>$\leq$</span> are to be understood elementwise. The function <code>AdaptiveBoxMap</code> attempts to approximate <span>$L$</span> before choosing an adaptive grid of test points in each box, as described in [1]. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.AdaptiveBoxMap" href="#GAIO.AdaptiveBoxMap"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:adaptive, f, domain::Box) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to  generate test points as described in </p><p>Oliver Junge. “Rigorous discretization of subdivision techniques”. In:  <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_sampled.jl#L137-L146">source</a></section></article><h2 id="IntervalBoxMap"><a class="docs-heading-anchor" href="#IntervalBoxMap"><code>IntervalBoxMap</code></a><a id="IntervalBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#IntervalBoxMap" title="Permalink"></a></h2><p>All of the above techniques provide a fast, efficient way to cover setwise images of boxes, but are not necessarily guaranteed to provide an complete covering. To avoid this as well as other numerical inaccuracies inherent in floating point arithmetic, one can use <em>interval arithmetic</em> to guarantee a rigorous outer covering of box images. Interval arithmetic is a technique from <em>validated numerics</em> which performs calculations while simultaneously recording the error of such calculations. A more detailed discussion and julia-implementation of interval arithmetic can be found in <a href="https://github.com/JuliaIntervals/IntervalArithmetic.jl"><code>IntervalArithmetic.jl</code></a>. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.IntervalBoxMap" href="#GAIO.IntervalBoxMap"><code>GAIO.IntervalBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:interval, map, domain; no_subintervals::NTuple{N} = ntuple(_-&gt;4, N)) -&gt; IntervalBoxMap
BoxMap(:interval, map, domain; no_subintervals::Function) -&gt; IntervalBoxMap</code></pre><p>Type representing a discretization of a map using  interval arithmetic to construct rigorous outer coverings  of map images. <code>no_subintervals</code> describes how many times  a given box will be subdivided before mapping.  <code>no_subintervals</code> is a Function which  has the signature <code>no_subintervals(center, radius)</code> and  returns a tuple. If a tuple is passed directly for  <code>no_subintervals</code>, then this is converted to a constant Function <code>(_, _) -&gt; no_subintervals</code></p><p>Fields:</p><ul><li><code>map</code>:              Map that defines the dynamical system.</li><li><code>domain</code>:           Domain of the map, <code>B</code>.</li><li><code>no_subintervals</code>:  Function with the signature                      <code>no_subintervals(center, radius)</code> which                      returns a tuple describing how many                      times a box is subdivided in each                      dimension before mapping. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_intervals.jl#L1-L25">source</a></section></article><h2 id="CPUSampledBoxMap"><a class="docs-heading-anchor" href="#CPUSampledBoxMap"><code>CPUSampledBoxMap</code></a><a id="CPUSampledBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#CPUSampledBoxMap" title="Permalink"></a></h2><p>Naturally, if an increase in accuracy is desired in a <code>SampledBoxMap</code>, a larger set of test points may be chosen. This leads to a dilemma: the more accurate we wish our approximation to be, the more we need to map very similar test points forward, causing a considerable slow down for complicated dynamical systems. However, the process of mapping each test point forward is completely independent on other test points. This means we do not need to perform each calculation sequentially; we can parallelize. </p><p>If the point map only uses &quot;basic&quot; instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple funnction calls can be made at the same time, increasing performance. For more details, see the <a href="https://gaioguys.github.io/GAIO.jl/simd/">maximizing performance section</a>. </p><article class="docstring"><header><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, :cpu, map, domain; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>no_of_points</code>, which is  a tuple of length equal to the dimension of the domain.  The number of points is rounded up to the nearest mutiple  of the cpu&#39;s SIMD capacity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_simd.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:cpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, :cpu, map, domain; no_of_points=16*N) -&gt; SampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses <code>no_of_points</code>  Monte-Carlo test points. The number of points is rounded  up to the nearest multiple of the cpu&#39;s SIMD capacity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_simd.jl#L163-L169">source</a></section></article><h2 id="GPUSampledBoxmap"><a class="docs-heading-anchor" href="#GPUSampledBoxmap"><code>GPUSampledBoxmap</code></a><a id="GPUSampledBoxmap-1"></a><a class="docs-heading-anchor-permalink" href="#GPUSampledBoxmap" title="Permalink"></a></h2><p>If an Nvidia gpu is available, the above technique can be improved dramatically. The gpu uses a &quot;massively parallel programming&quot; paradigm, which fits perfectly to the problem of mapping many sample points independently. For more information, see the <a href="https://gaioguys.github.io/GAIO.jl/cuda/">maximizing performance section</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}" href="#GAIO.GridBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.GridBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:grid, :gpu, map, domain; no_of_points::NTuple{N} = ntuple(_-&gt;16, N)) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses a grid of test points.  The size of the grid is defined by <code>no_of_points</code>, which is  a tuple of length equal to the dimension of the domain. </p><p>Requires a CUDA-capapble gpu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/no_boxmap_cuda.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}" href="#GAIO.MonteCarloBoxMap-Union{Tuple{T}, Tuple{N}, Tuple{Val{:gpu}, Any, Box{N, T}}} where {N, T}"><code>GAIO.MonteCarloBoxMap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:montecarlo, :gpu, map, domain; no_of_points=16*N) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses <code>no_of_points</code>  Monte-Carlo test points. </p><p>Requires a CUDA-capapble gpu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/no_boxmap_cuda.jl#L64-L71">source</a></section></article><h2 id="PointDiscretizedBoxMap"><a class="docs-heading-anchor" href="#PointDiscretizedBoxMap"><code>PointDiscretizedBoxMap</code></a><a id="PointDiscretizedBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#PointDiscretizedBoxMap" title="Permalink"></a></h2><p>A generalization of <code>MonteCarloBoxMap</code> and <code>GridBoxMap</code> can be defined as follows: </p><ol><li>we provide a &quot;global&quot; set of test points within the unit cube <span>$[-1,1]^d$</span>. </li><li>For each box <code>Box(c,r)</code>, we rescale the global test points to lie within the box by calculating <code>c .+ r .* p</code> for each global test point <code>p</code>. </li></ol><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedBoxMap" href="#GAIO.PointDiscretizedBoxMap"><code>GAIO.PointDiscretizedBoxMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, map, domain, points) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_sampled.jl#L88-L94">source</a></section><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :cpu, map, domain, points) -&gt; CPUSampledBoxMap</code></pre><p>Construct a <code>CPUSampledBoxMap</code> that uses the iterator  <code>points</code> as test points. <code>points</code> must have eltype  <code>SVector{N, SIMD.Vec{S,T}}</code> and be within the unit  cube <code>[-1,1]^N</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_simd.jl#L115-L122">source</a></section><section><div><pre><code class="language-julia hljs">BoxMap(:pointdiscretized, :gpu, map, domain, points) -&gt; GPUSampledBoxMap</code></pre><p>Construct a <code>GPUSampledBoxMap</code> that uses the Vector <code>points</code> as test points.  <code>points</code> must be a VECTOR of test points within the unit cube  <code>[-1,1]^N</code>. </p><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/no_boxmap_cuda.jl#L38-L46">source</a></section></article><h2 id="SampledBoxMap"><a class="docs-heading-anchor" href="#SampledBoxMap"><code>SampledBoxMap</code></a><a id="SampledBoxMap-1"></a><a class="docs-heading-anchor-permalink" href="#SampledBoxMap" title="Permalink"></a></h2><p>We can even further generalize the concept of <code>MonteCarloBoxMap</code>, <code>GridBoxMap</code>, <code>PointDiscretizedBoxMap</code> as follows: we define two functions <code>domain_points(c, r)</code> and <code>image_points(c, r)</code> for any <code>Box(c, r)</code>. </p><ol><li>for each box <code>Box(c, r)</code> a set of test points within the box is initialized using <code>domain_points(C, r)</code> and mapped forward by the point map. </li><li>For each of the pointwise images <code>fc</code>, an optional set of &quot;perturbations&quot; can be applied. These perturbations are generated with <code>image_points(fc, r)</code>. The boxes which are hit by these perturbations are recorded. </li></ol><article class="docstring"><header><a class="docstring-binding" id="GAIO.SampledBoxMap" href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:sampled, map, domain::Box, domain_points, image_points)</code></pre><p>Type representing a discretization of a map using sample points. </p><p>Fields:</p><ul><li><code>map</code>:              map that defines the dynamical system.</li><li><code>domain</code>:           domain of the map, <code>B</code>.</li><li><code>domain_points</code>:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li><li><code>image_points</code>:     the spread of test points for comparison in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_sampled.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.CPUSampledBoxMap" href="#GAIO.CPUSampledBoxMap"><code>GAIO.CPUSampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:cpu, map, domain; no_of_points) -&gt; CPUSampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>CPUSampledBoxMap</code> defined  on <code>Box</code>es. </p><p>Uses the CPU&#39;s SIMD acceleration capabilities. </p><p>By default uses a grid of sample points. </p><pre><code class="nohighlight hljs">BoxMap(:sampled, :cpu, boxmap, idx_base, temp_vec, temp_points)
CPUSampledBoxMap(boxmap, idx_base, temp_vec, temp_points)</code></pre><p>Type representing a discretization of a map using  sample points which are explicitly vectorized. This  type performs roughly 2x as many floating point  operations per second as standard <code>SampledBoxMap</code>s. </p><p>Fields:</p><ul><li><code>boxmap</code>:         <code>SampledBoxMap</code> with one restriction:                   <code>boxmap.domain_points(c, r)</code> must                    return an iterable with eltype                    <code>SVector{N, SIMD.Vec{S,T}}</code> where <code>N</code>                   is the dimension, <code>S</code> is the cpu&#39;s                    SIMD operation capacity, e.g. <code>4</code>,                    and <code>T</code> is the individual element type,                    e.g. <code>Float64</code>. </li><li><code>idx_base</code>:       <code>SIMD.Vec{S,Int}</code> which is used to                    transform a                    <code>Vector{SVector{N, SIMD.Vec{S,T}}}</code>                   into a                    <code>Vector{SVector{N,T}}</code>. </li><li><code>temp_points</code>:    Raw data <code>Vector{SVector{N,T}}</code>                    which holds the <code>S</code> temporary pointwise                    images of a <code>SVector{N, SIMD.Vec{S,T}}</code>                   under the point map. </li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/boxmap_simd.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.GPUSampledBoxMap" href="#GAIO.GPUSampledBoxMap"><code>GAIO.GPUSampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(:gpu, map, domain; no_of_points) -&gt; GPUSampledBoxMap</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in  the domain <span>$Q ⊂ ℝᴺ$</span> to a <code>GPUSampledBoxMap</code> defined  on <code>Box</code>es. </p><p>Uses the GPU&#39;s acceleration capabilities. </p><p>By default uses a grid of sample points. </p><pre><code class="nohighlight hljs">BoxMap(:sampled, :gpu, boxmap)</code></pre><p>Type representing a dicretization of a map using  sample points, which are mapped on the gpu. This  type performs orders of magnitude faster than  standard <code>SampledBoxMap</code>s. </p><div class="admonition is-warning"><header class="admonition-header">`image_points` with `GPUSampledBoxMap`</header><div class="admonition-body"><p><code>GPUSampledBoxMap</code> makes NO use of the <code>image_points</code>  field in <code>SampledBoxMap</code>s. </p></div></div><p>Fields:</p><ul><li><code>boxmap</code>:     <code>SampledBoxMap</code> with one restriction:                <code>boxmap.image_points</code> will not be used. </li></ul><p>Requires a CUDA-capable gpu. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/49e6de7135ee254cd78030b8e3c53cd1e701825b/src/no_boxmap_cuda.jl#L3-L32">source</a></section></article><h2 id="Creating-you-own-BoxMap-type"><a class="docs-heading-anchor" href="#Creating-you-own-BoxMap-type">Creating you own BoxMap type</a><a id="Creating-you-own-BoxMap-type-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-you-own-BoxMap-type" title="Permalink"></a></h2><p>Subtypes of the abstract type <code>BoxMap</code> must have three restrictions:</p><ol><li>There must be a <code>domain</code> field within the type, i.e.<pre><code class="language-julia hljs">struct MyBoxMap{N,T}
    domain::Box{N,T}
    # other things ...
end</code></pre></li><li>There must be a method <code>map_boxes(g::MyBoxMap, source::BoxSet)</code> which computes the setwise image of <code>source</code> under <code>g</code> and returns a <code>BoxSet</code>. </li><li>There must be a method <code>construct_transfers(g::MyBoxMap, source::BoxSet)</code> which computes a dictionary-of-keys sparse matrix <code>mat</code> with <code>mat[(hit_key, source_key)] = weight</code> for the TransferOperator, as well as a <code>BoxSet</code> called <code>variant_set</code> which is <code>setdiff(g(source), source)</code>. These are both returned by <code>construct_transfers(g::MyBoxMap, source::BoxSet)</code>. </li></ol><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Oliver Junge. “Rigorous discretization of subdivision techniques”. In: <em>International Conference on Differential Equations</em>. Ed. by B. Fiedler, K. Gröger, and J. Sprekels. 1999.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algorithms/">« Algorithms</a><a class="docs-footer-nextpage" href="../simd/">Using the CPU »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 6 March 2023 15:47">Monday 6 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
