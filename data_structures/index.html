<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Structures · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../boxmap/">BoxMaps</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Data Structures</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Data Structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Structures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/data_structures.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h1><ul><li><a href="#GAIO.Box"><code>GAIO.Box</code></a></li><li><a href="#GAIO.BoxFun"><code>GAIO.BoxFun</code></a></li><li><a href="#GAIO.BoxGraph"><code>GAIO.BoxGraph</code></a></li><li><a href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a></li><li><a href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a></li><li><a href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a></li><li><a href="#Base.:∘-Tuple{Any, BoxFun}"><code>Base.:∘</code></a></li><li><a href="#Base.sum-Tuple{Any, BoxFun}"><code>Base.sum</code></a></li><li><a href="#GAIO.bounded_point_to_key"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.key_to_box"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.point_to_box"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.Box" href="#GAIO.Box"><code>GAIO.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box{N,T}(center, radius)
Box(center, radius)</code></pre><p>A generalized box in dimension <code>N</code> with element type <code>T</code>.  Mathematically, this is a set</p><p class="math-container">\[[center_1 - radius_1,\ center_1 + radius_1) \ \times \ [center_N - radius_N,\ center_N + radius_N)\]</p><p>Fields:</p><ul><li><code>center</code>:   vector where the box&#39;s center is located</li><li><code>radius</code>:   vector of radii, length of the box in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), in #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/box.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.volume-Tuple{Box}" href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volume(box::Box)</code></pre><p>Compute the volume of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/box.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxPartition" href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxPartition(domain::Box{N}, dims::NTuple{N,&lt;:Integer} = ntuple(_-&gt;1, N))</code></pre><p>Data structure to partition a domain into a  <code>dims[1] x dims[2] x ... dims[N]</code> equidistant box grid. </p><p>Fields:</p><ul><li><code>domain</code>:         box defining the entire domain</li><li><code>left</code>:           leftmost / bottom edge of the domain</li><li><code>scale</code>:          1 / diameter of each box in the new partition (componentwise)</li><li><code>dims</code>:           tuple, number of boxes in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), ndims, size, length, keys, keytype #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_regular.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_key" href="#GAIO.point_to_key"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_regular.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.bounded_point_to_key" href="#GAIO.bounded_point_to_key"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(partition::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the partition. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_regular.jl#L117-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_box" href="#GAIO.key_to_box"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_regular.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_box" href="#GAIO.point_to_box"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::AbstractBoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_regular.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(P::BoxPartition, dim) -&gt; BoxPartition
subdivide(B::BoxSet, dim) -&gt; BoxSet</code></pre><p>Bisect every box in the <code>BoxPartition</code> or <code>BoxSet</code>  along the axis <code>dim</code>, giving rise to a new partition  of the domain, with double the amount of boxes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_regular.jl#L73-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.TreePartition" href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreePartition(domain::Box)</code></pre><p>Binary tree structure to partition <code>domain</code> into (variably sized) boxes. </p><p>Fields:</p><ul><li><code>domain</code>: <code>Box</code> denoting the full domain.</li><li><code>nodes</code>:  vector of <code>Node</code>s. Each node holds two indices pointing to            other nodes in the vector, or 0 if the node is a leaf. </li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">copy, keytype, keys, subdivide #, etc...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_tree.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!" href="#GAIO.subdivide!"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::TreePartition, key::keytype(tree)) -&gt; TreePartition
subdivide!(tree::TreePartition, depth::Integer) -&gt; TreePartition

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/partition_tree.jl#L137-L146">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>BoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MonteCarloBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GridBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>PointDiscretizedBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AdaptiveBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SampledBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>IntervalBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>CPUSampledBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>GPUSampledBoxMap</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxSet" href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxSet(partition, indices::AbstractSet)</code></pre><p>Internal data structure to hold boxes within a partition. </p><p>Constructors (all constructors work with box sets as well):</p><ul><li>For all boxes in a partition: </li></ul><pre><code class="language-julia hljs">partition[:]</code></pre><ul><li>For one box containing a point <code>x</code>: </li></ul><pre><code class="language-julia hljs">partition[x]</code></pre><ul><li>For a covering of an iterable <code>S = [Box(c_1, r_1), Box(c_2, r_r)] # etc...</code>: </li></ul><pre><code class="language-julia hljs">partition[S]</code></pre><p>Fields:</p><ul><li><code>partition</code>:  the partition that the set is defined over</li><li><code>set</code>:        set of partition-keys corresponding to the boxes in the set</li></ul><p>Most set operations such as </p><pre><code class="language-julia hljs">union, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...</code></pre><p>are supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/boxset.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.TransferOperator" href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransferOperator(map::BoxMap, domain::BoxSet)
TransferOperator(map::BoxMap, domain::BoxSet, codomain::BoxSet)</code></pre><p>Discretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with indices referring to  two <code>BoxSet</code>s: <code>domain</code> and <code>codomain</code>. </p><p>There exists two constructors:</p><ul><li>only provide a <code>boxmap</code> and a <code>domain</code>. In this case,  the <code>codomain</code> is generated as the image of <code>domain</code> under  the <code>boxmap</code>. <pre><code class="language-julia hljs">julia&gt; P = BoxPartition( Box((0,0), (1,0)), (10,10) )
  10 x 10 - element BoxPartition

julia&gt; domain = BoxSet( P, Set((1,2), (2,3), (3,4)) )
  3 - element Boxset over 10 x 10 - element BoxPartition

julia&gt; T = TransferOperator(boxmap, domain)
  TransferOperator over [...]</code></pre></li><li>provide <code>domain</code> and <code>codomain</code>. In this case,  the size of the transition matrix is given. <pre><code class="language-julia hljs">julia&gt; codomain = domain
  3 - element Boxset over 10 x 10 - element BoxPartition

julia&gt; T = TransferOperator(boxmap, domain, codomain)
  TransferOperator over [...]</code></pre></li></ul><p>Fields:</p><ul><li><code>mat</code>:            <code>SparseMatrixCSC</code> containing transfer weights. The index                    <code>T.mat[i,j]</code> represents the transfer weight FROM the <code>j</code>&#39;th                   box in <code>codomain</code> TO the <code>i</code>&#39;th box in <code>domain</code>. </li><li><code>boxmap</code>:         <code>SampledBoxMap</code> map which dictates the transfer weights. </li><li><code>domain</code>:         <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are column pointers, i.e. the                    <code>j</code>th column of <code>T.mat</code> contains transfer weights FROM                    box B<em>j, where B</em>j is the <code>j</code>th box of <code>domain</code>. </li><li><code>codomain</code>:       <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are row pointers, i.e. the                    <code>i</code>th row of <code>T.mat</code> contains transfer weights TO                    box B<em>i, where B</em>i is the <code>i</code>th box of <code>codomain</code>. </li></ul><pre><code class="language-julia hljs">        domain --&gt;
codomain  .   .   .   .   .
    |     .   .   .   .   .
    |     .   .   .   .   .
    v     .   .  mat  .   .
          .   .   .   .   .
          .   .   .   .   .
          .   .   .   .   .
          .   .   .   .   .</code></pre><p>It is important to note that <code>TranferOperator</code> is only supported over the  box set <code>domain</code>, but if one lets a <code>TranferOperator</code> act on a <code>BoxFun</code>, e.g.  by multiplication, then the <code>domain</code> is extended &quot;on the fly&quot; to  include the support of the <code>BoxFun</code>.</p><p>Methods Implemented: </p><pre><code class="language-julia hljs">:(==), axes, size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...</code></pre><p>Implementation detail:</p><p>The reader may have noticed that the matrix representation  depends on the order of boxes in <code>support</code>. For this reason  an <code>OrderedSet</code> is used. <code>BoxSet</code>s using regular <code>Set</code>s  will be copied and converted to <code>OrderedSet</code>s. </p><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/transfer_operator.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxFun" href="#GAIO.BoxFun"><code>GAIO.BoxFun</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxFun(partition, vals)</code></pre><p>Discretization of a measure over the domain <code>partition.domain</code>, as a piecewise constant function over the boxes of <code>partition</code>. </p><p>Implemented as a sparse vector over the indices of <code>partition</code>. </p><p>Fields:</p><ul><li><code>partition</code>: An <code>AbstractBoxPartition</code> whose indices are used </li></ul><p>for <code>vals</code></p><ul><li><code>vals</code>: A dictionary whose keys are the box indices from </li></ul><p><code>partition</code>, and whose values represent the values of the function. </p><p>Methods implemented:</p><pre><code class="nohighlight hljs">length, sum, iterate, values, isapprox, ∘, LinearAlgebra.norm, LinearAlgebra.normalize!</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/boxfun.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Any, BoxFun}" href="#Base.sum-Tuple{Any, BoxFun}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(identity, μ, B)</code></pre><p>Integrate a function <code>f</code> using <code>μ</code> as a density, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/boxfun.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{Any, BoxFun}" href="#Base.:∘-Tuple{Any, BoxFun}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∘(f, boxfun::BoxFun) -&gt; BoxFun
∘(boxfun::BoxFun, F::BoxMap) -&gt; BoxFun</code></pre><p>Postcompose the function <code>f</code> with the <code>boxfun</code>, or precompose a BoxMap <code>F</code> with the <code>boxfun</code>  (by applying the Koopman operator). Note that  the support of <code>BoxFun</code> must be forward-invariant under <code>F</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/boxfun.jl#L134-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxGraph" href="#GAIO.BoxGraph"><code>GAIO.BoxGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(gstar::TransferOperator) -&gt; BoxGraph
Graph(g::BoxMap, boxset::BoxSet) = Graph(TransferOperator(g, boxset, boxset))</code></pre><p>Directed Graph representation of a <code>TransferOperator</code>. The  boxes in a <code>BoxSet</code> are enumerated as in TransferOperator.  This means if the <code>domain</code>, <code>codomain</code> are taken from a  <code>TranferOperator</code>, then the graph vertices are numbered  <code>1 .. length(domain ∪ codomain)</code>. </p><p>A directed edge exists from the i&#39;th box <code>b_i</code> to the j&#39;th  box <code>b_j</code> if the BoxMap <code>g</code> has <code>b_j ∩ g⁻¹(b_i) ≠ ∅</code>.  Equivalently, </p><pre><code class="language-julia hljs">has_edge(g::BoxGraph, i, j) = !iszero( Matrix(g.gstar)[j,i] )</code></pre><p><code>Graphs.jl</code> operations like </p><pre><code class="language-julia hljs">vertices, edges, weights, inneighbors, outneighbors, # etc...</code></pre><p>are supported. Algorithms in <code>Graphs.jl</code>  should work &quot;out of the box&quot;, but will return whatever <code>Graphs.jl</code>  returns by default. To convert a (integer) vertex index from the  graph into a box index from the partition, one can call </p><pre><code class="language-julia hljs">BoxSet(boxgraph, graph_index_or_indices)</code></pre><p>If you would like to see specific behavior  implemented, please open an issue! </p><p><strong>Implementation details, not important for use:</strong></p><p>We want to turn a matrix representation </p><pre><code class="language-julia hljs">        domain --&gt;
codomain  .   .   .   .   .
    |     .   .   .   .   .
    |     .   .   .   .   .
    v     .   .  mat  .   .
          .   .   .   .   .
          .   .   .   .   .</code></pre><p>into a graph representation </p><pre><code class="language-julia hljs">  domain ∪ codomain
  .---------.   .
 / \       /   /
.   .-----.---.</code></pre><p>!! efficiently !!</p><p>Julia&#39;s Graphs package only allows integer-indexed vertices so we need to enumerate domain ∪ codomain.  To do this, we enumerate the domain, then skip  the boxes in the codomain which are already in the  domain, then continue enumerating the rest of the  codomain. </p><p>We therefore permute the row indices of the weight  matrix so that the skipped elements of the codomain come first. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/a923c4c93d8c585711bf7c7ff3a9767080afff5a/src/boxgraph.jl#L1-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../library_reference/">Library Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 7 March 2023 14:59">Tuesday 7 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
