<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Structures · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../algorithms/chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Data Structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Structures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/data_structures.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h1><ul><li><a href="#GAIO.Box"><code>GAIO.Box</code></a></li><li><a href="#GAIO.BoxGraph"><code>GAIO.BoxGraph</code></a></li><li><a href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a></li><li><a href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a></li><li><a href="#GAIO.bounded_point_to_key"><code>GAIO.bounded_point_to_key</code></a></li><li><a href="#GAIO.key_to_box"><code>GAIO.key_to_box</code></a></li><li><a href="#GAIO.point_to_box"><code>GAIO.point_to_box</code></a></li><li><a href="#GAIO.point_to_key"><code>GAIO.point_to_key</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.Box" href="#GAIO.Box"><code>GAIO.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box{N,T}(center, radius)
Box(center, radius)</code></pre><p>A generalized box in dimension <code>N</code> with element type <code>T</code>.  Mathematically, this is a set</p><p class="math-container">\[[center_1 - radius_1,\ center_1 + radius_1) \ \times \ \ldots \ \times \ [center_N - radius_N,\ center_N + radius_N)\]</p><p>Fields:</p><ul><li><code>center</code>:   vector where the box&#39;s center is located</li><li><code>radius</code>:   vector of radii, length of the box in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), in #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/box.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.volume-Tuple{Box}" href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">volume(box::Box)</code></pre><p>Compute the volume of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/box.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxPartition" href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxPartition(domain::Box{N}, dims::NTuple{N,&lt;:Integer} = ntuple(_-&gt;1, N))</code></pre><p>Data structure to partition a domain into a  <code>dims[1] x dims[2] x ... dims[N]</code> equidistant box grid. </p><p>Fields:</p><ul><li><code>domain</code>:         box defining the entire domain</li><li><code>left</code>:           leftmost / bottom edge of the domain</li><li><code>scale</code>:          1 / diameter of each box in the new partition (componentwise)</li><li><code>dims</code>:           tuple, number of boxes in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), ndims, size, length, keys, keytype #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_regular.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_key" href="#GAIO.point_to_key"><code>GAIO.point_to_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_to_key(P::BoxPartition, point)</code></pre><p>Find the index for the box within a <code>BoxPartition</code>  contatining a point, or <code>nothing</code> if the point does  not lie in the domain. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_regular.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.bounded_point_to_key" href="#GAIO.bounded_point_to_key"><code>GAIO.bounded_point_to_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bounded_point_to_key(P::BoxPartition, point)</code></pre><p>Find the cartesian index of the nearest box within a  <code>BoxPartition</code> to a point. Conicides with <code>point_to_key</code>  if the point lies in the partition. Default behavior  is to set <code>NaN = Inf</code> if <code>NaN</code>s are present in <code>point</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_regular.jl#L123-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.key_to_box" href="#GAIO.key_to_box"><code>GAIO.key_to_box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">key_to_box(P::BoxPartition, key)</code></pre><p>Return the box associated with the index  within a <code>BoxPartition</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_regular.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.point_to_box" href="#GAIO.point_to_box"><code>GAIO.point_to_box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_to_box(P::AbstractBoxPartition, point)</code></pre><p>Find the box within a <code>BoxPartition</code> containing a point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_regular.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(P::BoxPartition, dim) -&gt; BoxPartition
subdivide(B::BoxSet, dim) -&gt; BoxSet</code></pre><p>Bisect every box in the <code>BoxPartition</code> or <code>BoxSet</code>  along the axis <code>dim</code>, giving rise to a new partition  of the domain, with double the amount of boxes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_regular.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.TreePartition" href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreePartition(domain::Box)</code></pre><p>Binary tree structure to partition <code>domain</code> into (variably sized) boxes. </p><p>Fields:</p><ul><li><code>domain</code>: <code>Box</code> denoting the full domain.</li><li><code>nodes</code>:  vector of <code>Node</code>s. Each node holds two indices pointing to            other nodes in the vector, or 0 if the node is a leaf. </li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">copy, keytype, keys, subdivide #, etc...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_tree.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!" href="#GAIO.subdivide!"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree::TreePartition, key::keytype(tree)) -&gt; TreePartition
subdivide!(tree::TreePartition, depth::Integer) -&gt; TreePartition

subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key) -&gt; BoxSet
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, depth) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/partition_tree.jl#L143-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxSet" href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxSet(partition, indices::AbstractSet)</code></pre><p>Internal data structure to hold boxes within a partition. </p><p>Constructors:</p><ul><li>set of all boxes in partition / box set <code>P</code>:</li></ul><pre><code class="language-julia hljs">B = cover(P, :)    </code></pre><ul><li>cover the point <code>x</code>, or points <code>x = [x_1, x_2, x_3] # etc ...</code> using boxes from <code>P</code></li></ul><pre><code class="language-julia hljs">B = cover(P, x)</code></pre><ul><li>a covering of <code>S</code> using boxes from <code>P</code></li></ul><pre><code class="language-julia hljs">S = [Box(center_1, radius_1), Box(center_2, radius_2), Box(center_3, radius_3)] # etc... 
B = cover(P, S)</code></pre><p>Fields:</p><ul><li><code>partition</code>:  the partition that the set is defined over</li><li><code>set</code>:        set of partition-keys corresponding to the boxes in the set</li></ul><p>Most set operations such as </p><pre><code class="language-julia hljs">union, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...</code></pre><p>are supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/boxset.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxGraph" href="#GAIO.BoxGraph"><code>GAIO.BoxGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(gstar::TransferOperator) -&gt; BoxGraph
Graph(g::BoxMap, boxset::BoxSet) = Graph(TransferOperator(g, boxset, boxset))</code></pre><p>Directed Graph representation of a <code>TransferOperator</code>. The  boxes in a <code>BoxSet</code> are enumerated as in TransferOperator.  This means if the <code>domain</code>, <code>codomain</code> are taken from a  <code>TranferOperator</code>, then the graph vertices are numbered  <code>1 .. length(domain ∪ codomain)</code>. </p><p>A directed edge exists from the i&#39;th box <code>b_i</code> to the j&#39;th  box <code>b_j</code> if the BoxMap <code>g</code> has <code>b_j ∩ g⁻¹(b_i) ≠ ∅</code>.  Equivalently, </p><pre><code class="language-julia hljs">has_edge(g::BoxGraph, i, j) = !iszero( Matrix(g.gstar)[j,i] )</code></pre><p><code>Graphs.jl</code> operations like </p><pre><code class="language-julia hljs">vertices, edges, weights, inneighbors, outneighbors, # etc...</code></pre><p>are supported. Algorithms in <code>Graphs.jl</code>  should work &quot;out of the box&quot;, but will return whatever <code>Graphs.jl</code>  returns by default. To convert a (integer) vertex index from the  graph into a box index from the partition, one can call </p><pre><code class="language-julia hljs">BoxSet(boxgraph, graph_index_or_indices)</code></pre><p>If you would like to see specific behavior  implemented, please open an issue! </p><p><strong>Implementation details, not important for use:</strong></p><p>We want to turn a matrix representation </p><pre><code class="language-julia hljs">        domain --&gt;
codomain  .   .   .   .   .
    |     .   .   .   .   .
    |     .   .   .   .   .
    v     .   .  mat  .   .
          .   .   .   .   .
          .   .   .   .   .</code></pre><p>into a graph representation </p><pre><code class="language-julia hljs">  domain ∪ codomain
  .---------.   .
 / \       /   /
.   .-----.---.</code></pre><p>!! efficiently !!</p><p>Julia&#39;s Graphs package only allows integer-indexed vertices so we need to enumerate domain ∪ codomain.  To do this, we enumerate the domain, then skip  the boxes in the codomain which are already in the  domain, then continue enumerating the rest of the  codomain. </p><p>We therefore permute the row indices of the weight  matrix so that the skipped elements of the codomain come first. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6ad74fbfc51bd52e969ce0580aeb0bb65ccf602f/src/boxgraph.jl#L1-L63">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 19 December 2023 14:17">Tuesday 19 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
