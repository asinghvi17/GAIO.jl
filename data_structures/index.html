<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Structures · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li><a class="tocitem" href="../simd/">Using the CPU</a></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Data Structures</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Data Structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Structures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/data_structures.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h1><ul><li><a href="#GAIO.Box"><code>GAIO.Box</code></a></li><li><a href="#GAIO.BoxFun"><code>GAIO.BoxFun</code></a></li><li><a href="#GAIO.BoxGraph"><code>GAIO.BoxGraph</code></a></li><li><a href="#GAIO.BoxMap"><code>GAIO.BoxMap</code></a></li><li><a href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a></li><li><a href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a></li><li><a href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a></li><li><a href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a></li><li><a href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a></li><li><a href="#Base.:∘-Tuple{Any, BoxFun}"><code>Base.:∘</code></a></li><li><a href="#Base.sum-Tuple{Any, BoxFun}"><code>Base.sum</code></a></li><li><a href="#GAIO.AdaptiveBoxMap"><code>GAIO.AdaptiveBoxMap</code></a></li><li><a href="#GAIO.PointDiscretizedMap"><code>GAIO.PointDiscretizedMap</code></a></li><li><a href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a></li><li><a href="#GAIO.subdivide!"><code>GAIO.subdivide!</code></a></li><li><a href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GAIO.Box" href="#GAIO.Box"><code>GAIO.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Box{N,T}(center, radius)
Box(center, radius)</code></pre><p>A generalized box in dimension <code>N</code> with element type <code>T</code>.  Mathematically, this is a set</p><p class="math-container">\[[center_1 - radius_1,\ center_1 + radius_1) \ \times \ [center_N - radius_N,\ center_N + radius_N)\]</p><p>Fields:</p><ul><li><code>center</code>:   vector where the box&#39;s center is located</li><li><code>radius</code>:   vector of radii, length of the box in each dimension</li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), in #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.volume-Tuple{Box}" href="#GAIO.volume-Tuple{Box}"><code>GAIO.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the volume of a box. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/box.jl#L50-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxPartition" href="#GAIO.BoxPartition"><code>GAIO.BoxPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxPartition(
    domain::Box{N}, 
    dims::NTuple{N,&lt;:Integer} = ntuple(_-&gt;1, N)
    ; indextype = (N &lt; 9 : IndexLinear() : IndexCartesian())
)</code></pre><p>Data structure to partition a domain into a  <code>dims[1] x dims[2] x ... dims[N]</code> equidistant box grid. </p><p>Fields:</p><ul><li><code>domain</code>:         box defining the entire domain</li><li><code>left</code>:           leftmost / bottom edge of the domain</li><li><code>scale</code>:          1 / diameter of each box in the new partition (componentwise)</li><li><code>dims</code>:           tuple, number of boxes in each dimension</li><li><code>dimsprod</code>:       for indexing the partition. <code>BoxPartition</code> uses linear indices, i.e.                   keys are counted up in first dimension first,                    then second dimension, etc... </li><li><code>indextype</code>:      whether the partition will use cartesian or                    linear indices by default. Values can be                    <code>IndexLinear()</code>, <code>IndexCartesian()</code></li></ul><p>Methods implemented:</p><pre><code class="nohighlight hljs">:(==), ndims, size, length, keys, keytype #, etc ...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}" href="#GAIO.subdivide-Union{Tuple{I}, Tuple{T}, Tuple{N}, Tuple{BoxPartition{N, T, I}, Any}} where {N, T, I}"><code>GAIO.subdivide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subdivide(P::BoxPartition, dim) -&gt; BoxPartition
subdivide(B::BoxSet, dim) -&gt; BoxSet</code></pre><p>Bisect every box in <code>boxset</code> along the axis <code>dim</code>,  giving rise to a new partition of the domain, with  double the amount of boxes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_regular.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.TreePartition" href="#GAIO.TreePartition"><code>GAIO.TreePartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreePartition(domain::Box)</code></pre><p>Binary tree structure to partition <code>domain</code> into (variably sized) boxes. </p><p>Fields:</p><ul><li><code>domain</code>: <code>Box</code> denoting the full domain.</li><li><code>nodes</code>: vector of <code>Node</code>s. Each node holds two indices pointing to </li></ul><p>other nodes in the vector, or 0. </p><ul><li><code>regular_partitions</code>: vector of <code>BoxPartition</code>s. The indices held in </li></ul><p>a node also refer to this vector. </p><p>Methods implemented:</p><pre><code class="nohighlight hljs">copy, keytype #, etc...</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_tree.jl#L17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.subdivide!" href="#GAIO.subdivide!"><code>GAIO.subdivide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">subdivide!(tree:TreePartition), key::NTuple{2,&lt;:Integer}) -&gt; TreePartition
subdivide!(boxset::BoxSet{&lt;:Any,&lt;:Any,&lt;:TreePartition}, key::NTuple{2,&lt;:Integer}) -&gt; BoxSet</code></pre><p>Subdivide a <code>TreePartition</code> at the node <code>key</code>. Dimension along which  the node is subdivided depends on the depth of the node. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/partition_tree.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.SampledBoxMap" href="#GAIO.SampledBoxMap"><code>GAIO.SampledBoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampledBoxMap(map, domain::Box, domain_points, image_points, acceleration)</code></pre><p>Transforms a <span>$map: Q → Q$</span> defined on points in the box <span>$Q ⊂ ℝᴺ$</span> to a <code>SampledBoxMap</code> defined  on <code>Box</code>es. </p><p>Constructors:</p><ul><li><code>BoxMap</code></li><li><code>PointDiscretizedMap</code></li><li><code>AdaptiveBoxMap</code></li></ul><p>Fields:</p><ul><li><code>map</code>:              map that defines the dynamical system.</li><li><code>domain</code>:           domain of the map, <code>B</code>.</li><li><code>domain_points</code>:    the spread of test points to be mapped forward in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li><li><code>image_points</code>:     the spread of test points for comparison in intersection algorithms.                     Must have the signature <code>domain_points(center, radius)</code> and return                      an iterator of points within <code>Box(center, radius)</code>. </li><li><code>acceleration</code>:     Whether to use optimized functions in intersection algorithms.                     Accepted values: <code>nothing</code>, <code>BoxMapCPUCache</code>, <code>BoxMapGPUCache</code>.                     <code>BoxMapGPUCache</code> does nothing unless you have a CUDA capable gpu.</li></ul><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L2-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxMap" href="#GAIO.BoxMap"><code>GAIO.BoxMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxMap(map, domain::Box{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -&gt; SampledBoxMap
BoxMap(map, P::BoxPartition{N,T}, accel=nothing; no_of_points=4*N*pick_vector_width(T)) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>no_of_points</code> Monte-Carlo  test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.PointDiscretizedMap" href="#GAIO.PointDiscretizedMap"><code>GAIO.PointDiscretizedMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PointDiscretizedMap(map, domain, points, accel=nothing) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> that uses the iterator <code>points</code> as test points.  <code>points</code> must be an array or iterator of test points within the unit cube  <span>$[-1,1]^N$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.AdaptiveBoxMap" href="#GAIO.AdaptiveBoxMap"><code>GAIO.AdaptiveBoxMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AdaptiveBoxMap(f, domain::Box, accel=nothing) -&gt; SampledBoxMap</code></pre><p>Construct a <code>SampledBoxMap</code> which uses <code>sample_adaptive</code> to generate  test points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxmap.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxSet" href="#GAIO.BoxSet"><code>GAIO.BoxSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxSet(partition, indices::AbstractSet)</code></pre><p>Internal data structure to hold boxes within a partition. </p><p>Constructors:</p><ul><li>For all boxes in a partition: </li></ul><pre><code class="language-julia hljs">partition[:]</code></pre><ul><li>For one box containing a point <code>x</code>: </li></ul><pre><code class="language-julia hljs">partition[x]</code></pre><ul><li>For a covering of an iterable <code>S = [Box(c_1, r_1), Box(c_2, r_r)] # etc...</code>: </li></ul><pre><code class="language-julia hljs">partition[S]</code></pre><p>Fields:</p><ul><li><code>partition</code>:  the partition that the set is defined over</li><li><code>set</code>:        set of partition-keys corresponding to the boxes in the set</li></ul><p>Most set operations such as </p><pre><code class="language-julia hljs">union, intersect, setdiff, symdiff, issubset, isdisjoint, issetequal, isempty, length, # etc...</code></pre><p>are supported. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxset.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.TransferOperator" href="#GAIO.TransferOperator"><code>GAIO.TransferOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransferOperator(map::BoxMap, support::BoxSet)</code></pre><p>Discretization of the Perron-Frobenius operator, or transfer operator.  Implemented as a sparse matrix with the same linear indices as <code>support</code>, e.g. if </p><pre><code class="language-julia hljs">julia&gt; B = BoxSet(partition, [3,10,30])
  Boxset over [...] partition

julia&gt; T = TransferOperator(boxmap, B)
  TransferOperator over [...] BoxSet</code></pre><p>for some <code>partition</code> and <code>boxmap</code>, then </p><pre><code class="language-julia hljs">julia&gt; axes(T)
  ([3, 10, 30], [3, 10, 30])</code></pre><p>Fields:</p><ul><li><code>boxmap</code>:         <code>SampledBoxMap</code> map which relates to the transfers.</li><li><code>support</code>:        <code>BoxSet</code> which contains keys for the already calculated transfers.                    Effectively, these are row/column pointers, i.e. the                    first column of <code>T.mat</code> contains transfer weights FROM                    box B<em>1, where B</em>1 is the first box of <code>support</code>. </li><li><code>variant_set</code>:    <code>BoxSet</code> which contains keys for potential boxes lying                    outside of <code>support</code>, i.e. it could be that <code>support</code> is                    not an invariant set. In this case, <code>variant_set</code> contains                    the boxes which were not in <code>support</code>, but whose preimage                    lies in <code>support</code>. </li><li><code>mat</code>:            <code>SparseMatrixCSC</code> containing transfer weights. The index                    <code>T.mat[i,j]</code> represents the transfer weight FROM the <code>j</code>&#39;th                   box in <code>support</code> TO the <code>i</code>&#39;th box in <code>support</code>. If <code>support</code>                    is not invariant, then the matrix will be tall. In this case                    the rows are counted in <code>support</code> and then in <code>variant_set</code>. </li></ul><pre><code class="language-julia hljs">support --&gt;
  |     .   .   .   .   .
  |     .   .   .   .   .
  v     .   .   .   .   .
        .   .  mat  .   .
        .   .   .   .   .
 var-   .   .   .   .   .
 ian-   .   .   .   .   .
 t_set  .   .   .   .   .     
  |     .   .   .   .   .
  |     .   .   .   .   .
  v     .   .   .   .   .</code></pre><p>It is important to note that <code>TranferOperator</code> is only supported over the  box set <code>B</code>, but if one lets a <code>TranferOperator</code> act on a <code>BoxFun</code>, then  the support <code>B</code> is extended &quot;on the fly&quot; to include the support of the <code>BoxFun</code>.</p><p>Methods Implemented: </p><pre><code class="language-julia hljs">:(==), axes, size, eltype, getindex, setindex!, SparseArrays.sparse, Arpack.eigs, LinearAlgebra.mul! #, etc ...</code></pre><p>Implementation detail:</p><p>The reader may have noticed that the matrix representation  depends on the order of boxes in <code>support</code>. For this reason  an <code>OrderedSet</code> is used. <code>BoxSet</code>s using regular <code>Set</code>s  will be copied and converted to <code>OrderedSet</code>s. </p><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/transfer_operator.jl#L1-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxFun" href="#GAIO.BoxFun"><code>GAIO.BoxFun</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoxFun(partition, vals)</code></pre><p>Discretization of a measure over the domain <code>partition.domain</code>, as a piecewise constant function over the boxes of <code>partition</code>. </p><p>Implemented as a sparse vector over the indices of <code>partition</code>. </p><p>Fields:</p><ul><li><code>partition</code>: An <code>AbstractBoxPartition</code> whose indices are used </li></ul><p>for <code>vals</code></p><ul><li><code>vals</code>: A dictionary whose keys are the box indices from </li></ul><p><code>partition</code>, and whose values represent the values of the function. </p><p>Methods implemented:</p><pre><code class="nohighlight hljs">length, sum, iterate, values, isapprox, ∘, LinearAlgebra.norm, LinearAlgebra.normalize!</code></pre><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxfun.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Any, BoxFun}" href="#Base.sum-Tuple{Any, BoxFun}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, μ::BoxFun)
sum(f, μ::BoxFun, B::BoxSet)
μ(B) = sum(identity, μ, B)</code></pre><p>Integrate a function <code>f</code> using <code>μ</code> as a density, that is, if <code>boxfun</code> is the discretization of a measure <span>$\mu$</span> over the domain  <span>$Q$</span>, then approximate the value of </p><p class="math-container">\[\int_Q f \, d\mu .\]</p><p>If a BoxSet <code>B</code> is passed as the third argument, then the  integration is restricted to the boxes in <code>B</code></p><p class="math-container">\[\int_{Q \cap \bigcup_{b \in B} b} f \, d\mu .\]</p><p>The notation <code>μ(B)</code> is offered to compute  <span>$\mu (\bigcup_{b \in B} b)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxfun.jl#L29-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{Any, BoxFun}" href="#Base.:∘-Tuple{Any, BoxFun}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∘(f, boxfun::BoxFun) -&gt; BoxFun
∘(boxfun::BoxFun, F::BoxMap) -&gt; BoxFun</code></pre><p>Postcompose the function <code>f</code> with the <code>boxfun</code>, or precompose a BoxMap <code>F</code> with the <code>boxfun</code>  (by applying the Koopman operator). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxfun.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAIO.BoxGraph" href="#GAIO.BoxGraph"><code>GAIO.BoxGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(gstar::TransferOperator) -&gt; BoxGraph
Graph(g::BoxMap, boxset::BoxSet) = Graph(TransferOperator(g, boxset))</code></pre><p>Directed Graph representation of a TransferOperator. The  boxes in a BoxSet are enumerated as in TransferOperator.  This means the vertices are numbered <code>1 .. size(gstar)[1]</code>.  A directed edge exists from the i&#39;th box <code>b_i</code> to the j&#39;th  box <code>b_j</code> in <code>boxgraph.gstar.support</code> if the BoxMap <code>g</code>  has <code>b_j ∩ g⁻¹(b_i) ≠ ∅</code>. Equivalently, </p><pre><code class="language-julia hljs">has_edge(g::BoxGraph, i, j) = !iszero( Matrix(g.gstar)[j,i] )</code></pre><p><code>Graphs.jl</code> operations like </p><pre><code class="language-julia hljs">vertices, edges, weights, inneighbors, outneighbors, # etc...</code></pre><p>are supported. Some algorithms are adapted like </p><pre><code class="language-julia hljs">strongly_connected_components</code></pre><p>to return custom objects. All other algorightms in <code>Graphs.jl</code>  should work &quot;out of the box&quot;, but will return whatever <code>Graphs.jl</code>  returns by default. To convert a (integer) vertex index from the  graph into a box index from the partition, one can call </p><pre><code class="language-julia hljs">BoxSet(boxgraph, graph_index_or_indices)</code></pre><p>If you would like to see specific behavior  implemented, please open an issue! </p><p>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaioguys/GAIO.jl/blob/6c6342c8191b4850bf06556c97f2653658b04745/src/boxgraph.jl#L1-L34">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../library_reference/">Library Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 December 2022 08:21">Tuesday 6 December 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
