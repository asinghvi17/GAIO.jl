<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using the CPU · GAIO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GAIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GAIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../general/">General usage</a></li><li><span class="tocitem">BoxMaps</span><ul><li><a class="tocitem" href="../boxmaps/boxmaps_general/">An Overview of BoxMap Types</a></li><li><a class="tocitem" href="../boxmaps/montecarlo/"><code>MonteCarloBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/grid/"><code>GridBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/adaptive/"><code>AdaptiveBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/interval/"><code>IntervalBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_simd/"><code>CPUSampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/boxmaps_cuda/"><code>GPUSampledBoxmap</code></a></li><li><a class="tocitem" href="../boxmaps/pointdiscretized/"><code>PointDiscretizedBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/sampled/"><code>SampledBoxMap</code></a></li><li><a class="tocitem" href="../boxmaps/new_types/">Creating you own BoxMap type</a></li></ul></li><li><span class="tocitem">Invariant Sets</span><ul><li><a class="tocitem" href="../algorithms/relative_attractor/">Relative Attractor</a></li><li><a class="tocitem" href="../algorithms/chain_recurrent_set/">Chain Reccurent Set</a></li><li><a class="tocitem" href="../algorithms/maximal_invariant_set/">Maximal Invariant Set</a></li><li><a class="tocitem" href="../algorithms/unstable_manifold/">Stable and Unstable Manifold</a></li></ul></li><li><span class="tocitem">Transfer- and Koopman Operators</span><ul><li><a class="tocitem" href="../algorithms/transfer_operator/">Ulam&#39;s method and Invariant Measures</a></li><li><a class="tocitem" href="../algorithms/almost_invariant/">Almost Invariant (metastable) Sets</a></li><li><a class="tocitem" href="../algorithms/cyclic/">Cyclic Sets</a></li><li><a class="tocitem" href="../algorithms/coherent/">Coherent Sets</a></li><li><a class="tocitem" href="../algorithms/seba/">Extracting Multiple Sets via SEBA</a></li></ul></li><li><span class="tocitem">Scalar Diagnostics</span><ul><li><a class="tocitem" href="../algorithms/box_dimension/">Fractal Dimension</a></li><li><a class="tocitem" href="../algorithms/ftle/">Lyapunov Exponents / FTLEs</a></li></ul></li><li><span class="tocitem">Misceallenous Algorithms</span><ul><li><a class="tocitem" href="../algorithms/root_covering/">Root Covering</a></li><li><a class="tocitem" href="../algorithms/implicit_manifold/">Covering Implicitly Defined Manifolds</a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><span class="tocitem">Maximizing Performance</span><ul><li class="is-active"><a class="tocitem" href>Using the CPU</a><ul class="internal"><li><a class="tocitem" href="#Tutorial"><span>Tutorial</span></a></li><li><a class="tocitem" href="#I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})"><span>I get <code>MethodError: No method matching f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})</code></span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../cuda/">Using the GPU (Nvidia)</a></li></ul></li><li><a class="tocitem" href="../examples/">Other Examples</a></li><li><a class="tocitem" href="../library_reference/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Maximizing Performance</a></li><li class="is-active"><a href>Using the CPU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using the CPU</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaioguys/GAIO.jl/blob/master/docs/src/simd.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-the-CPU"><a class="docs-heading-anchor" href="#Using-the-CPU">Using the CPU</a><a id="Using-the-CPU-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-CPU" title="Permalink"></a></h1><h2 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h2><p>This example demonstrates how to get a ~2x speedup in your code using your CPU&#39;s SIMD capabilities. </p><p>Consider the point map <code>f</code>:</p><pre><code class="language-julia hljs">using GAIO

const σ, ρ, β = 10.0, 28.0, 0.4
function v(x)
    # Some map, here we use the Lorenz equation
    dx = (
           σ * x[2] -    σ * x[1],
           ρ * x[1] - x[1] * x[3] - x[2],
        x[1] * x[2] -    β * x[3]
    )
    return dx
end

# set f as 20 steps of the classic 4th order RK method
f(x) = rk4_flow_map(v, x, 0.01, 20)</code></pre><p>Internally, GAIO calls this function on many test points within the various boxes. This means many function calls have to be made. Notably, all of these function calls are independent of one another, meaning that they can be performed in parallel. If your function only uses &quot;basic&quot; instructions, then it is possible to simultaneously apply Single Instructions to Multiple Data (SIMD). This way multiple funnction calls can be made at the same time, increasing performance. </p><div class="admonition is-success"><header class="admonition-header">Which instructions are supported?</header><div class="admonition-body"><p>GAIO.jl uses SIMD.jl to explicitly vectorize operations. To see precisely which instructions are supported, refer to <a href="https://github.com/eschnett/SIMD.jl.git">the documentation for SIMD.jl</a>. </p></div></div><p>All we need to do is pass <code>:simd</code> as the second argument to one of the box map constructors, eg. <code>BoxMap(:montecarlo, ...)</code>, <code>BoxMap(:grid, ...)</code>. </p><pre><code class="language-julia hljs">center, radius = (0,0,25), (30,30,30)
Q = Box(center, radius)
P = BoxPartition(Q, (128,128,128))
F = BoxMap(:montecarlo, :simd, f, Q)

x = (sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1)
S = cover(P, x)
@time W = unstable_set(F, S)</code></pre><p>Using SIMD vectorization, one can roughly double the effective floating point operations per second. For more detail, see [1]. </p><p><img src="../assets/flops_cpu_loglog.png" alt="performance metrics"/></p><h2 id="I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})"><a class="docs-heading-anchor" href="#I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})">I get <code>MethodError: No method matching f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})</code></a><a id="I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})-1"></a><a class="docs-heading-anchor-permalink" href="#I-get-MethodError:-No-method-matching-f(::StaticArrays.SVector{SIMD.Vec{simd,Float64},N})" title="Permalink"></a></h2><p>If your code returns a <code>MethodError</code> with reference to <code>SIMD.Vec</code> somewhere, this most likely means that your pointmap <code>f</code> uses operations not explicitly supported by SIMD.jl. In this case, one you may need to rewrite sections of <code>f</code> to use only supported operations. For example, consider a &quot;scaled&quot; Lorenz flow map </p><pre><code class="language-julia hljs">function v(x_in)
    
    x = x_in ./ sqrt(norm(x_in))

    dx = (
           σ * x[2] -    σ * x[1],
           ρ * x[1] - x[1] * x[3] - x[2],
        x[1] * x[2] -    β * x[3]
    )
    return dx
end

f(x) = rk4_flow_map(v, x)</code></pre><p>This code will return a <code>MethodError</code> due to <code>LinearAlgebra.norm</code>. For the <span>$L^2$</span> norm, this can be manually rewritten as follows: </p><pre><code class="language-julia hljs">function v(x_in)
    
    sqnorm = sum(y -&gt; y*y, x_in)
    sqnorm = sqrt(sqrt(sqnorm))

    x = (
        x_in[1] / sqnorm,
        x_in[2] / sqnorm,
        x_in[3] / sqnorm
    )

    dx = (
           σ * x[2] -    σ * x[1],
           ρ * x[1] - x[1] * x[3] - x[2],
        x[1] * x[2] -    β * x[3]
    )
    return dx
end

f(x) = rk4_flow_map(v, x)</code></pre><p>Generally, most &quot;simple&quot; functions can be rewritten (if needed) to support SIMD.jl. However, more complicated functions can make rewriting unnecessarily difficult. </p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] April Herwig. “GAIO.jl: Set-oriented Methods for Approximating Invariant Objects, and their Implementation in Julia”.Thesis. 2022. url: https://github.com/April-Hannah-Lena/schoolwork/blob/2eada059678d91bad8a813c3e6b657a1ac72e86f/Thesis/main.pdf. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">« Plotting</a><a class="docs-footer-nextpage" href="../cuda/">Using the GPU (Nvidia) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 24 April 2023 09:26">Monday 24 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
